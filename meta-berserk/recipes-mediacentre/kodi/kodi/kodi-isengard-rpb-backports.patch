diff -Naur c/addons/resource.language.en_gb/resources/strings.po d/addons/resource.language.en_gb/resources/strings.po
--- c/addons/resource.language.en_gb/resources/strings.po	2015-10-21 00:52:11.000000000 +0300
+++ d/addons/resource.language.en_gb/resources/strings.po	2016-04-06 18:32:36.000000000 +0300
@@ -6321,7 +6321,22 @@
 msgid "Use OMXPlayer for decoding of video files."
 msgstr ""
 
-#empty strings from id 13460 to 13504
+#empty strings from id 13460 to 13499
+
+#: system/settings/settings.xml
+msgctxt "#13500"
+msgid "A/V sync method"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#13503"
+msgid "Resample audio"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#13504"
+msgid "Adjust PLL"
+msgstr ""
 
 #: system/settings/settings.xml
 msgctxt "#13505"
@@ -7488,7 +7503,7 @@
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
 msgctxt "#16313"
-msgid "VDPAU - Sharpness"
+msgid "Sharpness"
 msgstr ""
 
 #: xbmc/video/dialogs/GUIDialogVideoSettings.cpp
@@ -11000,7 +11015,7 @@
 
 #: system/settings/settings.xml
 msgctxt "#20433"
-msgid "Extract thumbnails and video information"
+msgid "Extract video information from files"
 msgstr ""
 
 #: xbmc/dialogs/GUIDialogSmartPlaylistRule.cpp
@@ -14557,7 +14572,7 @@
 #. Description of setting "Videos -> File lists -> Extract thumbnails and video information" with label #20433
 #: system/settings/settings.xml
 msgctxt "#36178"
-msgid "Extract thumbnails and metadata information such as codec and aspect ratio from videos."
+msgid "Extract metadata information such as codec and aspect ratio from videos."
 msgstr ""
 
 #. Description of setting "Videos -> File lists -> Replace file names with library titles" with label #20419
@@ -14569,7 +14584,7 @@
 #. Description of setting "Videos -> File lists -> Extract thumbnails and video information" with label #20433
 #: system/settings/settings.xml
 msgctxt "#36180"
-msgid "Extract thumbnails and information, such as codecs and aspect ratio, to display in library mode."
+msgid "Extract thumbnails, to display in library Mode."
 msgstr ""
 
 #: system/settings/settings.xml
@@ -16605,6 +16620,15 @@
 #: system/settings/rbp.xml
 msgctxt "#38010"
 msgid "GPU accelerated"
+
+#: system/settings/settings.xml
+msgctxt "#38020"
+msgid "Support browsing into archives"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38021"
+msgid "Allow viewing and playing files in archives (e.g. zip, rar)"
 msgstr ""
 
 #. Setting #38011 "Videos -> Library -> Show All Items entry"
@@ -16642,3 +16666,64 @@
 msgctxt "#38016"
 msgid "%d fps"
 msgstr ""
+
+#. Description of setting "Videos -> Playback -> A/V sync method" with label #13500
+#: system/settings/settings.xml
+msgctxt "#38006"
+msgid "Audio has to stay in sync, this can either be done by resampling, or adjusting the PLL"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38007"
+msgid "Boost centre channel when downmixing"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38008"
+msgid "Increase this value to make the dialogue louder compared to background sounds when downmixing multichannel audio"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38009"
+msgid "%i dB"
+msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38050"
+msgid "Remote button press delay before repeating (ms)"
+msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38051"
+msgid "Remote button press repeat rate (ms)"
+msgstr ""
+
+#: system/peripherals.xml
+msgctxt "#38052"
+msgid "Remote button press release time (ms)"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38110"
+msgid "Support MVC video (full frame 3D)"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38111"
+msgid "This option decodes frames for both eyes of MVC video. Disabling may improve performance if you don't require 3D"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38112"
+msgid "Use Full HD HDMI modes for 3D"
+msgstr ""
+
+#: system/settings/rbp.xml
+msgctxt "#38113"
+msgid "This option uses frame-packing to output full resolution for 3D through HDMI"
+msgstr ""
+
+#: system/settings/settings.xml
+msgctxt "#38103"
+msgid "Extract thumbnails from video files"
+msgstr ""
diff -Naur c/configure.ac d/configure.ac
--- c/configure.ac	2015-10-21 00:51:55.000000000 +0300
+++ d/configure.ac	2017-01-24 23:37:44.261427690 +0300
@@ -744,8 +744,17 @@
   raspberry-pi)
      target_platform=target_raspberry_pi
      use_neon=no
-     use_arch="arm"
      use_cpu=arm1176jzf-s
+     ;;
+  raspberry-pi2)
+     target_platform=target_raspberry_pi
+     use_neon=yes
+     use_cpu=cortex-a7
+     ;;
+esac
+
+if test "$target_platform" = "target_raspberry_pi" ; then
+     use_arch="arm"
      use_hardcoded_tables="yes"
      use_openmax=no
      ARCH="arm"
@@ -754,8 +763,7 @@
      USE_MMAL=1; AC_DEFINE([HAS_MMAL],[1],["Define to 1 if MMAL libs is enabled"])
      CFLAGS="$CFLAGS"
      CXXFLAGS="$CXXFLAGS"
-     ;;
-esac
+fi
 
 if test "$host_vendor" = "apple"; then
   use_avahi=no
@@ -1051,7 +1059,7 @@
       AC_DEFINE([HAVE_LIBEGL],[1],["Define to 1 if you have the `EGL' library (-lEGL)."])
       AC_DEFINE([HAVE_LIBGLESV2],[1],["Define to 1 if you have the `GLESv2' library (-lGLESv2)."])
       AC_MSG_RESULT(== WARNING: OpenGLES support is assumed.)
-      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm -lmmal -lmmal_core -lmmal_util"
+      LIBS="$LIBS -lEGL -lGLESv2 -lbcm_host -lvcos -lvchiq_arm -lmmal -lmmal_core -lmmal_util -lvcsm -ltinyxml -llzma -lx264 -ltheoraenc -ltheoradec"
     else
       AC_CHECK_LIB([EGL],   [main],, AC_MSG_ERROR($missing_library))
       AC_CHECK_LIB([GLESv2],[main],, AC_MSG_ERROR($missing_library))
diff -Naur c/m4/xbmc_arch.m4 d/m4/xbmc_arch.m4
--- c/m4/xbmc_arch.m4	2015-10-21 00:52:08.000000000 +0300
+++ d/m4/xbmc_arch.m4	2016-04-06 18:32:36.000000000 +0300
@@ -77,9 +77,7 @@
   AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -DTARGET_ANDROID")
 fi
 
-case $use_platform in
-  raspberry-pi)
-     AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
-     ;;
-esac
+if test "$target_platform" = "target_raspberry_pi" ; then
+  AC_SUBST(ARCH_DEFINES, "-DTARGET_POSIX -DTARGET_LINUX -D_LINUX -D_ARMEL -DTARGET_RASPBERRY_PI")
+fi
 ])
diff -Naur c/system/peripherals.xml d/system/peripherals.xml
--- c/system/peripherals.xml	2015-10-21 00:52:08.000000000 +0300
+++ d/system/peripherals.xml	2016-04-06 18:32:36.000000000 +0300
@@ -30,7 +30,9 @@
     <setting key="device_type" type="int" value="1" configurable="0" />
     <setting key="wake_devices_advanced" type="string" value="" configurable="0" />
     <setting key="standby_devices_advanced" type="string" value="" configurable="0" />
-    <setting key="double_tap_timeout_ms" type="int" min="0" value="300" configurable="0" />
+    <setting key="double_tap_timeout_ms" type="int" min="50" max="1000" step="50" value="300" label="38050" order="16" />
+    <setting key="button_repeat_rate_ms" type="int" min="0" max="250" step="10" value="0" label="38051" order="17" />
+    <setting key="button_release_delay_ms" type="int" min="0" max="500" step="50" value="0" label="38052" order="18" />
   </peripheral>
 
   <peripheral vendor_product="2548:1001,2548:1002" bus="usb" name="Pulse-Eight CEC Adapter" mapTo="cec">
diff -Naur c/system/settings/rbp2.xml d/system/settings/rbp2.xml
--- c/system/settings/rbp2.xml	2015-10-21 00:52:08.000000000 +0300
+++ d/system/settings/rbp2.xml	2016-04-06 18:53:08.000000000 +0300
@@ -23,6 +23,11 @@
         <setting id="audiooutput.ac3transcode" help="36429">
         </setting>
       </group>
+      <group id="1">
+        <setting id="audiooutput.processquality">
+          <default>30</default> <!-- AE_QUALITY_MID -->
+        </setting>
+      </group>
     </category>
   </section>
 </settings>
diff -Naur c/system/settings/rbp.xml d/system/settings/rbp.xml
--- c/system/settings/rbp.xml	2015-10-21 00:52:08.000000000 +0300
+++ d/system/settings/rbp.xml	2016-04-06 18:32:36.000000000 +0300
@@ -1,6 +1,13 @@
 <?xml version="1.0" encoding="utf-8" ?>
 <settings>
   <section id="videos">
+    <category id="videoplayer">
+      <group id="3">
+        <setting id="videoplayer.usedisplayasclock">
+          <default>true</default>
+        </setting>
+      </group>
+    </category>
     <category id="videoacceleration">
       <group id="1">
         <visible>false</visible>
@@ -27,6 +34,21 @@
           <control type="edit" format="integer" />
         </setting>
       </group>
+      <group id="3">
+        <setting id="videoplayer.supportmvc" type="boolean" label="38110" help="38111">
+          <level>2</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
+        <setting id="videoplayer.framepacking" type="boolean" label="38112" help="38113">
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.supportmvc">true</dependency>
+          </dependencies>
+          <level>2</level>
+          <default>false</default>
+          <control type="toggle" />
+        </setting>
+      </group>
     </category>
     <category id="myvideos">
       <group id="1">
@@ -34,6 +56,16 @@
           <default>false</default>
         </setting>
       </group>
+    </category>
+    <category id="myvideos">
+      <group id="1">
+        <setting id="myvideos.extractflags">
+          <default>false</default>
+        </setting>
+        <setting id="myvideos.extractthumb">
+          <default>false</default>
+        </setting>
+      </group>
     </category>
   </section>
 
diff -Naur c/system/settings/settings.xml d/system/settings/settings.xml
--- c/system/settings/settings.xml	2015-10-21 00:52:08.000000000 +0300
+++ d/system/settings/settings.xml	2016-04-06 18:32:36.000000000 +0300
@@ -304,6 +304,11 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="filelists.browsearchives" type="boolean" label="38020" help="38021">
+          <level>1</level>
+          <default>true</default>
+          <control type="toggle" />
+        </setting>
       </group>
     </category>
     <category id="screensaver" label="360" help="36128">
@@ -567,6 +572,20 @@
           <default>false</default>
           <control type="toggle" />
         </setting>
+        <setting id="videoplayer.synctype" type="integer" parent="videoplayer.usedisplayasclock" label="13500" help="38006">
+          <level>2</level>
+          <default>2</default> <!-- SYNC_RESAMPLE -->
+          <constraints>
+            <options>
+              <option label="13503">2</option> <!-- SYNC_RESAMPLE -->
+              <option label="13504">3</option> <!-- SYNC_PLLADJUST -->
+            </options>
+          </constraints>
+          <dependencies>
+            <dependency type="enable" setting="videoplayer.usedisplayasclock" operator="is">true</dependency>
+          </dependencies>
+          <control type="spinner" format="string" />
+        </setting>
         <setting id="videoplayer.errorinaspect" type="integer" label="22021" help="36170">
           <level>2</level>
           <default>0</default>
@@ -842,8 +861,8 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
-        <setting id="myvideos.extractthumb" type="boolean" label="20433" help="36180">
-          <level>4</level>
+        <setting id="myvideos.extractthumb" type="boolean" label="38103" help="36180">
+          <level>1</level>
           <default>true</default>
           <control type="toggle" />
         </setting>
@@ -2578,6 +2597,18 @@
           <default>true</default>
           <control type="toggle" />
         </setting>
+         <setting id="audiooutput.boostcenter" type="integer" label="38007" help="38008">
+          <level>2</level>
+          <default>0</default>
+          <constraints>
+            <minimum>0</minimum>
+            <step>1</step>
+            <maximum>30</maximum>
+          </constraints>
+          <control type="spinner" format="string">
+            <formatlabel>38009</formatlabel>
+          </control>
+        </setting>
         <setting id="audiooutput.processquality" type="integer" label="13505" help="36169">
           <requirement>HAS_AE_QUALITY_LEVELS</requirement>
           <level>2</level>
@@ -2886,12 +2917,12 @@
         </setting>
         <setting id="debug.extralogging" type="boolean" label="666" help="36394">
           <level>1</level>
-          <default>true</default>
+          <default>false</default>
           <control type="toggle" />
         </setting>
         <setting id="debug.setextraloglevel" type="list[integer]" parent="debug.extralogging" label="668" help="36534">
           <level>1</level>
-          <default>32768</default>
+          <default></default>
           <constraints>
             <options>loggingcomponents</options>
             <delimiter>,</delimiter>
diff -Naur c/tools/depends/configure.ac d/tools/depends/configure.ac
--- c/tools/depends/configure.ac	2015-10-21 00:52:07.000000000 +0300
+++ d/tools/depends/configure.ac	2016-04-06 18:32:36.000000000 +0300
@@ -17,7 +17,8 @@
 AC_ARG_WITH([platform],
   [AS_HELP_STRING([--with-platform],
   [target platform [auto]])],
-  [use_platform=$withval])
+  [use_platform=$withval],
+  [target_platform=$withval])
 
 AC_ARG_WITH([firmware],
   [AS_HELP_STRING([--with-firmware],
@@ -300,34 +301,49 @@
     AC_MSG_ERROR(unsupported host ($use_host))
 esac
 
-if test "$use_platform" = "raspberry-pi"; then
+case $use_platform in
+  raspberry-pi)
+     target_platform=raspberry_pi
+     use_neon=no
+     use_cpu=arm1176jzf-s
+     platform_cflags="-mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp"
+     platform_cxxflags="-mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard -mfpu=vfp"
+     platform_ldflags=""
+     ;;
+  raspberry-pi2)
+     target_platform=raspberry_pi
+     use_neon=yes
+     use_cpu=cortex-a7
+     platform_cflags="-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_cxxflags="-fPIC -mcpu=cortex-a7 -mfloat-abi=hard -mfpu=neon-vfpv4"
+     platform_ldflags="-lpthread"
+     ;;
+esac
+
+if test "$target_platform" = "raspberry_pi" ; then
   if test -d "${use_firmware}/opt/vc/include"; then
     :
   else
     AC_MSG_ERROR([Raspberry Pi firmware not found])
   fi
-  use_neon=no
   use_arch="arm"
-  use_cpu="arm1176jzf-s"
   use_hardcoded_tables="yes"
-  use_alsa="no"
   ARCH="arm"
   platform_os="linux"
   cross_compiling="yes"
   use_host="arm-linux-gnueabihf"
   deps_dir="$use_host"
-  platform_cflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s -mfloat-abi=hard \
-   -mfpu=vfp -mabi=aapcs-linux -Wno-psabi -Wa,-mno-warn-deprecated \
-   -Wno-deprecated-declarations -isystem${use_firmware}/opt/vc/include \
+  platform_cflags+=" -pipe -mabi=aapcs-linux -Wno-psabi \
+   -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
+   -isystem${use_firmware}/opt/vc/include \
    -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
    -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
-  platform_cxxflags="-pipe -mcpu=arm1176jzf-s -mtune=arm1176jzf-s \
-   -mfloat-abi=hard -mfpu=vfp -mabi=aapcs-linux -Wno-psabi \
+  platform_cxxflags+=" -pipe -mabi=aapcs-linux -Wno-psabi \
    -Wa,-mno-warn-deprecated -Wno-deprecated-declarations \
    -isystem${use_firmware}/opt/vc/include \
    -isystem${use_firmware}/opt/vc/include/interface/vcos/pthreads \
    -isystem${use_firmware}/opt/vc/include/interface/vmcs_host/linux"
-  platform_ldflags="-L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
+  platform_ldflags+=" -L${use_firmware}/opt/vc/lib -lEGL -lGLESv2 -lbcm_host -lvcos \
    -lvchiq_arm"
 fi
 
diff -Naur c/tools/depends/Makefile.include.in d/tools/depends/Makefile.include.in
--- c/tools/depends/Makefile.include.in	2015-10-21 00:52:07.000000000 +0300
+++ d/tools/depends/Makefile.include.in	2016-04-06 18:32:36.000000000 +0300
@@ -20,7 +20,7 @@
 CROSS_COMPILING=@cross_compiling@
 ARCH_DEFINES=@ARCH_DEFINES@
 NATIVE_ARCH_DEFINES=@NATIVE_ARCH_DEFINES@
-TARGET_PLATFORM=@use_platform@
+TARGET_PLATFORM=@target_platform@
 XCODE_VERSION=@use_xcode@
 AAPT=@AAPT@
 DX=@DX@
diff -Naur c/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch d/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch
--- c/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch	1970-01-01 03:00:00.000000000 +0300
+++ d/tools/depends/target/ffmpeg/0001-mpeg4video-Signal-unsupported-GMC-with-more-than-one.patch	2016-04-06 18:32:36.000000000 +0300
@@ -0,0 +1,48 @@
+From 84e9a1784bbd3182b68cefa5e5feae8da8b9e184 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 5 Jun 2015 22:48:33 +0100
+Subject: [PATCH] mpeg4video: Signal unsupported GMC with more than one warp
+ point
+
+---
+ libavcodec/avcodec.h       | 1 +
+ libavcodec/mpeg4videodec.c | 4 ++++
+ 2 files changed, 5 insertions(+)
+
+diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
+index 8c7c420..e63dc2d 100644
+--- a/libavcodec/avcodec.h
++++ b/libavcodec/avcodec.h
+@@ -2527,6 +2527,7 @@ typedef struct AVCodecContext {
+ #define FF_BUG_DC_CLIP          4096
+ #define FF_BUG_MS               8192 ///< Work around various bugs in Microsoft's broken decoders.
+ #define FF_BUG_TRUNCATED       16384
++#define FF_BUG_GMC_UNSUPPORTED 32768
+ 
+     /**
+      * strictly follow the standard (MPEG4, ...).
+diff --git a/libavcodec/mpeg4videodec.c b/libavcodec/mpeg4videodec.c
+index 9bf33dd..0b5d3b9 100644
+--- a/libavcodec/mpeg4videodec.c
++++ b/libavcodec/mpeg4videodec.c
+@@ -2179,6 +2179,9 @@ int ff_mpeg4_workaround_bugs(AVCodecContext *avctx)
+ 
+         if (ctx->divx_version >= 0)
+             s->workaround_bugs |= FF_BUG_HPEL_CHROMA;
++
++        if (ctx->num_sprite_warping_points > 1)
++            s->workaround_bugs |= FF_BUG_GMC_UNSUPPORTED;
+     }
+ 
+     if (s->workaround_bugs & FF_BUG_STD_QPEL) {
+@@ -2203,6 +2206,7 @@ int ff_mpeg4_workaround_bugs(AVCodecContext *avctx)
+                s->workaround_bugs, ctx->lavc_build, ctx->xvid_build,
+                ctx->divx_version, ctx->divx_build, s->divx_packed ? "p" : "");
+ 
++    avctx->workaround_bugs = s->workaround_bugs;
+     if (CONFIG_MPEG4_DECODER && ctx->xvid_build >= 0 &&
+         s->codec_id == AV_CODEC_ID_MPEG4 &&
+         avctx->idct_algo == FF_IDCT_AUTO) {
+-- 
+1.9.1
+
diff -Naur c/tools/depends/target/libcec/Makefile d/tools/depends/target/libcec/Makefile
--- c/tools/depends/target/libcec/Makefile	2015-10-21 00:52:07.000000000 +0300
+++ d/tools/depends/target/libcec/Makefile	2016-04-06 18:32:36.000000000 +0300
@@ -21,6 +21,7 @@
 $(PLATFORM): $(TARBALLS_LOCATION)/$(ARCHIVE) $(DEPS)
 	rm -rf $(PLATFORM); mkdir -p $(PLATFORM)/build
 	cd $(PLATFORM); $(ARCHIVE_TOOL) $(ARCHIVE_TOOL_FLAGS) $(TARBALLS_LOCATION)/$(ARCHIVE)
+	cd $(PLATFORM); patch -p1 < ../popcornmix.patch
 	cd $(PLATFORM)/build; $(CMAKE) -DBUILD_SHARED_LIBS=1 -DSKIP_PYTHON_WRAPPER:STRING=1 -DCMAKE_INSTALL_LIBDIR=$(PREFIX)/lib ..
 
 $(LIBDYLIB): $(PLATFORM)
diff -Naur c/tools/depends/target/libcec/popcornmix.patch d/tools/depends/target/libcec/popcornmix.patch
--- c/tools/depends/target/libcec/popcornmix.patch	1970-01-01 03:00:00.000000000 +0300
+++ d/tools/depends/target/libcec/popcornmix.patch	2016-04-06 18:32:36.000000000 +0300
@@ -0,0 +1,859 @@
+From ec982e9800ae312972d306b67779215a2add6cde Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 24 Oct 2014 13:45:21 +0100
+Subject: [PATCH 1/6] Make released key polling wait for exact time until key
+ gets released
+
+---
+ src/libcec/CECClient.cpp    | 16 ++++++++++++++--
+ src/libcec/CECClient.h      |  2 +-
+ src/libcec/CECProcessor.cpp |  8 +++++---
+ src/libcec/LibCEC.cpp       | 10 ++++++++--
+ src/libcec/LibCEC.h         |  4 +++-
+ 5 files changed, 31 insertions(+), 9 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 35c2d3e..e307c0e 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -1067,7 +1067,7 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
+   AddKey(key);
+ }
+ 
+-void CCECClient::CheckKeypressTimeout(void)
++uint16_t CCECClient::CheckKeypressTimeout(void)
+ {
+   cec_keypress key;
+ 
+@@ -1091,12 +1091,24 @@ void CCECClient::CheckKeypressTimeout(void)
+     }
+     else
+     {
+-      return;
++      // time when this keypress will be released and we'd like to be called again
++      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
++        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
++      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
++        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
++      if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
++      {
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++      }
++      return timeout;
+     }
+   }
+ 
+   LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
+   QueueAddKey(key);
++  return CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+ }
+ 
+ bool CCECClient::EnableCallbacks(void *cbParam, ICECCallbacks *callbacks)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index 12f8a3b..c9ce5e3 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -272,7 +272,7 @@ namespace CEC
+     virtual void                  AddKey(bool bSendComboKey = false);
+     virtual void                  AddKey(const cec_keypress &key);
+     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
+-    virtual void                  CheckKeypressTimeout(void);
++    virtual uint16_t              CheckKeypressTimeout(void);
+     virtual void                  SourceActivated(const cec_logical_address logicalAddress);
+     virtual void                  SourceDeactivated(const cec_logical_address logicalAddress);
+ 
+diff --git a/src/libcec/CECProcessor.cpp b/src/libcec/CECProcessor.cpp
+index 99f71aa..604b950 100644
+--- a/src/libcec/CECProcessor.cpp
++++ b/src/libcec/CECProcessor.cpp
+@@ -52,7 +52,6 @@
+ using namespace CEC;
+ using namespace PLATFORM;
+ 
+-#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
+ #define ACTIVE_SOURCE_CHECK_INTERVAL   500
+ #define TV_PRESENT_CHECK_INTERVAL      30000
+ 
+@@ -260,6 +259,7 @@ bool CCECProcessor::OnCommandReceived(const cec_command &command)
+ 
+ void *CCECProcessor::Process(void)
+ {
++  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   m_libcec->AddLog(CEC_LOG_DEBUG, "processor thread started");
+ 
+   if (!m_connCheck)
+@@ -274,13 +274,13 @@ void *CCECProcessor::Process(void)
+   while (!IsStopped() && m_communication->IsOpen())
+   {
+     // wait for a new incoming command, and process it
+-    if (m_inBuffer.Pop(command, CEC_PROCESSOR_SIGNAL_WAIT_TIME))
++    if (m_inBuffer.Pop(command, timeout))
+       ProcessCommand(command);
+ 
+     if (CECInitialised() && !IsStopped())
+     {
+       // check clients for keypress timeouts
+-      m_libcec->CheckKeypressTimeout();
++      timeout = m_libcec->CheckKeypressTimeout();
+ 
+       // check if we need to replace handlers
+       ReplaceHandlers();
+@@ -311,6 +311,8 @@ void *CCECProcessor::Process(void)
+         tvPresentCheck.Init(TV_PRESENT_CHECK_INTERVAL);
+       }
+     }
++    else
++      timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   }
+ 
+   return NULL;
+diff --git a/src/libcec/LibCEC.cpp b/src/libcec/LibCEC.cpp
+index af36b79..5ccb8dd 100644
+--- a/src/libcec/LibCEC.cpp
++++ b/src/libcec/LibCEC.cpp
+@@ -361,11 +361,17 @@ bool CLibCEC::IsValidPhysicalAddress(uint16_t iPhysicalAddress)
+          iPhysicalAddress <= CEC_MAX_PHYSICAL_ADDRESS;
+ }
+ 
+-void CLibCEC::CheckKeypressTimeout(void)
++uint16_t CLibCEC::CheckKeypressTimeout(void)
+ {
++  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   // check all clients
+   for (std::vector<CECClientPtr>::iterator it = m_clients.begin(); it != m_clients.end(); it++)
+-    (*it)->CheckKeypressTimeout();
++  {
++    uint16_t t = (*it)->CheckKeypressTimeout();
++    if (t < timeout)
++      timeout = t;
++  }
++  return timeout;
+ }
+ 
+ void CLibCEC::AddLog(const cec_log_level level, const char *strFormat, ...)
+diff --git a/src/libcec/LibCEC.h b/src/libcec/LibCEC.h
+index 6d9a229..d9d1e7b 100644
+--- a/src/libcec/LibCEC.h
++++ b/src/libcec/LibCEC.h
+@@ -39,6 +39,8 @@
+ #include "CECTypeUtils.h"
+ #include <memory>
+ 
++#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
++
+ namespace CEC
+ {
+   class CAdapterCommunication;
+@@ -125,7 +127,7 @@ namespace CEC
+ 
+       void AddLog(const cec_log_level level, const char *strFormat, ...);
+       void AddCommand(const cec_command &command);
+-      void CheckKeypressTimeout(void);
++      uint16_t CheckKeypressTimeout(void);
+       void Alert(const libcec_alert type, const libcec_parameter &param);
+ 
+       static bool IsValidPhysicalAddress(uint16_t iPhysicalAddress);
+-- 
+1.9.1
+
+
+From 41f0f3ec9ac136da3565c96fd5a7075499f3938d Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Fri, 24 Oct 2014 13:51:34 +0100
+Subject: [PATCH 2/6] Keep track of time since initial button press and last
+ button update
+
+---
+ src/libcec/CECClient.cpp | 44 +++++++++++++++++++++++++++-----------------
+ src/libcec/CECClient.h   |  3 ++-
+ 2 files changed, 29 insertions(+), 18 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index e307c0e..e7935b9 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -54,7 +54,8 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_bInitialised(false),
+     m_bRegistered(false),
+     m_iCurrentButton(CEC_USER_CONTROL_CODE_UNKNOWN),
+-    m_buttontime(0),
++    m_initialButtontime(0),
++    m_updateButtontime(0),
+     m_iPreventForwardingPowerOffCommand(0),
+     m_iLastKeypressTime(0)
+ {
+@@ -981,9 +982,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+     {
+-      key.duration = (unsigned int) (GetTimeMs() - m_buttontime);
++      unsigned int duration = (unsigned int) (GetTimeMs() - m_updateButtontime);
++      key.duration = (unsigned int) (GetTimeMs() - m_initialButtontime);
+ 
+-      if (key.duration > m_configuration.iComboKeyTimeoutMs ||
++      if (duration > m_configuration.iComboKeyTimeoutMs ||
+           m_configuration.iComboKeyTimeoutMs == 0 ||
+           m_iCurrentButton != m_configuration.comboKey ||
+           bSendComboKey)
+@@ -991,14 +993,15 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+         key.keycode = m_iCurrentButton;
+ 
+         m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+-        m_buttontime = 0;
++        m_initialButtontime = 0;
++        m_updateButtontime = 0;
+       }
+     }
+   }
+ 
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+   {
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x)", ToString(key.keycode), key.keycode);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+     QueueAddKey(key);
+   }
+ }
+@@ -1012,7 +1015,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+     AddKey();
+     return;
+   }
+-
++  bool isrepeat = false;
+   cec_keypress transmitKey(key);
+   cec_user_control_code comboKey(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+       m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
+@@ -1035,22 +1038,27 @@ void CCECClient::AddKey(const cec_keypress &key)
+         AddKey(true);
+     }
+ 
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x) current(%lx) duration(%d)", ToString(transmitKey.keycode), transmitKey.keycode, m_iCurrentButton, key.duration);
++
+     if (m_iCurrentButton == key.keycode)
+     {
+-      m_buttontime = GetTimeMs();
++      m_updateButtontime = GetTimeMs();
++      isrepeat = true;
+     }
+     else
+     {
+-      AddKey();
++      if (m_iCurrentButton != transmitKey.keycode)
++        AddKey();
+       if (key.duration == 0)
+       {
+         m_iCurrentButton = transmitKey.keycode;
+-        m_buttontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
++        m_initialButtontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
++        m_updateButtontime = m_initialButtontime;
+       }
+     }
+   }
+ 
+-  if (key.keycode != comboKey || key.duration > 0)
++  if (!isrepeat && (key.keycode != comboKey || key.duration > 0))
+   {
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x)", ToString(transmitKey.keycode), transmitKey.keycode);
+     QueueAddKey(transmitKey);
+@@ -1074,32 +1082,34 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   {
+     CLockObject lock(m_mutex);
+     uint64_t iNow = GetTimeMs();
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s T:%.3f", __FUNCTION__, iNow*1e-3);
+     cec_user_control_code comboKey(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
+     uint32_t iTimeoutMs(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_buttontime > iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && iNow - m_buttontime > CEC_BUTTON_TIMEOUT)))
++          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime > iTimeoutMs) ||
++          (m_iCurrentButton != comboKey && iNow - m_updateButtontime > CEC_BUTTON_TIMEOUT)))
+     {
+-      key.duration = (unsigned int) (iNow - m_buttontime);
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+ 
+       m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+-      m_buttontime = 0;
++      m_initialButtontime = 0;
++      m_updateButtontime = 0;
+     }
+     else
+     {
+       // time when this keypress will be released and we'd like to be called again
+       unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
+-        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
++        timeout = iTimeoutMs - (iNow - m_updateButtontime) + 1;
+       else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
+-        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
++        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_updateButtontime) + 1;
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+       return timeout;
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index c9ce5e3..611c68b 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -404,7 +404,8 @@ namespace CEC
+     PLATFORM::CMutex      m_mutex;                             /**< mutex for changes to this instance */
+     PLATFORM::CMutex      m_cbMutex;                           /**< mutex that is held when doing anything with callbacks */
+     cec_user_control_code m_iCurrentButton;                    /**< the control code of the button that's currently held down (if any) */
+-    int64_t               m_buttontime;                        /**< the timestamp when the button was pressed (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_initialButtontime;                 /**< the timestamp when the button was initially pressed (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_updateButtontime;                  /**< the timestamp when the button was updated (in seconds since epoch), or 0 if none was pressed. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+     int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+     cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+-- 
+1.9.1
+
+
+From 273ead6980b69eddf98810eb1eb33d94a7d74fce Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Tue, 28 Oct 2014 00:09:18 +0000
+Subject: [PATCH 3/6] Support repeating button presses with configurable repeat
+ rate
+
+---
+ include/cectypes.h                               |   6 ++
+ src/libcec/CECClient.cpp                         | 100 +++++++++++++++++++----
+ src/libcec/CECClient.h                           |   6 +-
+ src/libcec/implementations/CECCommandHandler.cpp |   2 +-
+ 4 files changed, 96 insertions(+), 18 deletions(-)
+
+diff --git a/include/cectypes.h b/include/cectypes.h
+index acff259..8f098ef 100644
+--- a/include/cectypes.h
++++ b/include/cectypes.h
+@@ -1493,6 +1493,8 @@ struct libcec_configuration
+                                                    XXX changed meaning in 2.2.0 to not break binary compatibility. next major (3.0) release will fix it in a nicer way */
+   cec_user_control_code comboKey;             /*!< key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_F1_BLUE. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5 */
+   uint32_t              iComboKeyTimeoutMs;   /*!< timeout until the combo key is sent as normal keypress */
++  uint32_t              iButtonRepeatRateMs;  /*!< rate at which buttons autorepeat. 0 means rely on CEC device */
++  uint32_t              iButtonReleaseDelayMs;/*!< duration after last update until a button is considered released */
+ 
+ #ifdef __cplusplus
+    libcec_configuration(void) { Clear(); }
+@@ -1527,6 +1529,8 @@ struct libcec_configuration
+                  cecVersion                == other.cecVersion &&
+                  adapterType               == other.adapterType &&
+                  iDoubleTapTimeout50Ms     == other.iDoubleTapTimeout50Ms &&
++                 iButtonRepeatRateMs       == other.iButtonRepeatRateMs &&
++                 iButtonReleaseDelayMs     == other.iButtonReleaseDelayMs &&
+                  (other.clientVersion <= LIBCEC_VERSION_TO_UINT(2, 0, 4) || comboKey            == other.comboKey) &&
+                  (other.clientVersion <= LIBCEC_VERSION_TO_UINT(2, 0, 4) || iComboKeyTimeoutMs  == other.iComboKeyTimeoutMs) &&
+                  (other.clientVersion <  LIBCEC_VERSION_TO_UINT(2, 1, 0) || bPowerOnScreensaver == other.bPowerOnScreensaver));
+@@ -1567,6 +1571,8 @@ struct libcec_configuration
+     iDoubleTapTimeout50Ms =           CEC_DOUBLE_TAP_TIMEOUT_50_MS;
+     comboKey =                        CEC_USER_CONTROL_CODE_STOP;
+     iComboKeyTimeoutMs =              CEC_DEFAULT_COMBO_TIMEOUT_MS;
++    iButtonRepeatRateMs =             0;
++    iButtonReleaseDelayMs =           CEC_BUTTON_TIMEOUT;
+ 
+     memset(strDeviceName, 0, 13);
+     deviceTypes.Clear();
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index e7935b9..598628d 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -56,6 +56,10 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_iCurrentButton(CEC_USER_CONTROL_CODE_UNKNOWN),
+     m_initialButtontime(0),
+     m_updateButtontime(0),
++    m_repeatButtontime(0),
++    m_releaseButtontime(0),
++    m_pressedButtoncount(0),
++    m_releasedButtoncount(0),
+     m_iPreventForwardingPowerOffCommand(0),
+     m_iLastKeypressTime(0)
+ {
+@@ -851,6 +855,9 @@ bool CCECClient::GetCurrentConfiguration(libcec_configuration &configuration)
+   configuration.bMonitorOnly              = m_configuration.bMonitorOnly;
+   configuration.cecVersion                = m_configuration.cecVersion;
+   configuration.adapterType               = m_configuration.adapterType;
++  configuration.iDoubleTapTimeout50Ms     = m_configuration.iDoubleTapTimeout50Ms;
++  configuration.iButtonRepeatRateMs       = m_configuration.iButtonRepeatRateMs;
++  configuration.iButtonReleaseDelayMs     = m_configuration.iButtonReleaseDelayMs;
+ 
+   return true;
+ }
+@@ -894,6 +901,9 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
+     m_configuration.cecVersion                 = configuration.cecVersion;
+     m_configuration.adapterType                = configuration.adapterType;
+     m_configuration.iDoubleTapTimeout50Ms      = configuration.iDoubleTapTimeout50Ms;
++    m_configuration.iButtonRepeatRateMs        = configuration.iButtonRepeatRateMs;
++    m_configuration.iButtonReleaseDelayMs      = configuration.iButtonReleaseDelayMs;
++
+     m_configuration.deviceTypes.Add(configuration.deviceTypes[0]);
+ 
+     if (m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5))
+@@ -950,6 +960,7 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
+     primary->ActivateSource();
+   }
+ 
++  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %d:%d:%d", __FUNCTION__, DoubleTapTimeoutMS(), m_configuration.iButtonRepeatRateMs, m_configuration.iButtonReleaseDelayMs);
+   return true;
+ }
+ 
+@@ -973,11 +984,15 @@ void CCECClient::AddCommand(const cec_command &command)
+   }
+ }
+ 
+-void CCECClient::AddKey(bool bSendComboKey /* = false */)
++void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /* = false */)
+ {
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
++  // we ignore button releases when supporting repeating keys
++  if (bButtonRelease && m_configuration.iButtonRepeatRateMs && m_configuration.iButtonReleaseDelayMs)
++    return;
++
+   {
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+@@ -995,6 +1010,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */)
+         m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+         m_initialButtontime = 0;
+         m_updateButtontime = 0;
++        m_repeatButtontime = 0;
++        m_releaseButtontime = 0;
++        m_pressedButtoncount = 0;
++        m_releasedButtoncount = 0;
+       }
+     }
+   }
+@@ -1012,6 +1031,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+       key.keycode < CEC_USER_CONTROL_CODE_SELECT)
+   {
+     // send back the previous key if there is one
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Unexpected key %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+     AddKey();
+     return;
+   }
+@@ -1035,7 +1055,10 @@ void CCECClient::AddKey(const cec_keypress &key)
+         transmitKey.keycode = CEC_USER_CONTROL_CODE_DOT;
+       // default, send back the previous key
+       else
++      {
++        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Combo key %s (%1x) D%dms:", ToString(key.keycode), key.keycode, key.duration);
+         AddKey(true);
++      }
+     }
+ 
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x) current(%lx) duration(%d)", ToString(transmitKey.keycode), transmitKey.keycode, m_iCurrentButton, key.duration);
+@@ -1043,17 +1066,44 @@ void CCECClient::AddKey(const cec_keypress &key)
+     if (m_iCurrentButton == key.keycode)
+     {
+       m_updateButtontime = GetTimeMs();
+-      isrepeat = true;
++      m_releaseButtontime = m_updateButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
++      // want to have seen some updated before considering a repeat
++      if (m_configuration.iButtonRepeatRateMs)
++      {
++        if (!m_repeatButtontime && m_pressedButtoncount > 1)
++          m_repeatButtontime = m_initialButtontime + DoubleTapTimeoutMS();
++        isrepeat = true;
++      }
++      m_pressedButtoncount++;
+     }
+     else
+     {
+       if (m_iCurrentButton != transmitKey.keycode)
++      {
++        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Changed key %s (%1x) D:%dms cur:%lx", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration, m_iCurrentButton);
+         AddKey();
++      }
+       if (key.duration == 0)
+       {
+         m_iCurrentButton = transmitKey.keycode;
+-        m_initialButtontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
+-        m_updateButtontime = m_initialButtontime;
++        if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
++        {
++          m_initialButtontime = 0;
++          m_updateButtontime = 0;
++          m_repeatButtontime = 0;
++          m_releaseButtontime = 0;
++          m_pressedButtoncount = 0;
++          m_releasedButtoncount = 0;
++        }
++        else
++        {
++          m_initialButtontime = GetTimeMs();
++          m_updateButtontime = m_initialButtontime;
++          m_repeatButtontime = 0; // set this on next update
++          m_releaseButtontime = m_initialButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
++          m_pressedButtoncount = 1;
++          m_releasedButtoncount = 0;
++        }
+       }
+     }
+   }
+@@ -1072,12 +1122,16 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
+   key.duration = 0;
+   key.keycode = iButtonCode;
+ 
++  LIB_CEC->AddLog(CEC_LOG_DEBUG, "SetCurrentButton %s (%1x) D:%dms cur:%lx", ToString(key.keycode), key.keycode, key.duration);
+   AddKey(key);
+ }
+ 
+ uint16_t CCECClient::CheckKeypressTimeout(void)
+ {
++  // time when we'd like to be called again
++  unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   cec_keypress key;
++  key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
+   {
+     CLockObject lock(m_mutex);
+@@ -1089,8 +1143,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime > iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && iNow - m_updateButtontime > CEC_BUTTON_TIMEOUT)))
++          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs) ||
++          (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)))
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1098,27 +1152,41 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+       m_initialButtontime = 0;
+       m_updateButtontime = 0;
++      m_repeatButtontime = 0;
++      m_releaseButtontime = 0;
++      m_pressedButtoncount = 0;
++      m_releasedButtoncount = 0;
++    }
++    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
++          (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
++    {
++      key.duration = 0;
++      key.keycode = m_iCurrentButton;
++      m_repeatButtontime = iNow + m_configuration.iButtonRepeatRateMs;
++      timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+     }
+     else
+     {
+-      // time when this keypress will be released and we'd like to be called again
+-      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
+-        timeout = iTimeoutMs - (iNow - m_updateButtontime) + 1;
+-      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
+-        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_updateButtontime) + 1;
++        timeout = std::min((uint64_t)timeout, m_updateButtontime - iNow + iTimeoutMs);
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_releaseButtontime)
++        timeout = std::min((uint64_t)timeout, m_releaseButtontime - iNow);
++      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_repeatButtontime)
++        timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
++        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, m_releaseButtontime*1e-3, m_iCurrentButton);
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+-      return timeout;
+     }
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key %s: %s (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : key.duration ? "released" : "repeated",
++        ToString(m_iCurrentButton), m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
+   }
+ 
+-  LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
+-  QueueAddKey(key);
+-  return CEC_PROCESSOR_SIGNAL_WAIT_TIME;
++  if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
++    QueueAddKey(key);
++
++  return timeout;
+ }
+ 
+ bool CCECClient::EnableCallbacks(void *cbParam, ICECCallbacks *callbacks)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index 611c68b..adeb5af 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -269,7 +269,7 @@ namespace CEC
+     // callbacks
+     virtual void                  Alert(const libcec_alert type, const libcec_parameter &param) { QueueAlert(type, param); }
+     virtual void                  AddLog(const cec_log_message &message) { QueueAddLog(message); }
+-    virtual void                  AddKey(bool bSendComboKey = false);
++    virtual void                  AddKey(bool bSendComboKey = false, bool bButtonRelease = false);
+     virtual void                  AddKey(const cec_keypress &key);
+     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
+     virtual uint16_t              CheckKeypressTimeout(void);
+@@ -406,6 +406,10 @@ namespace CEC
+     cec_user_control_code m_iCurrentButton;                    /**< the control code of the button that's currently held down (if any) */
+     int64_t               m_initialButtontime;                 /**< the timestamp when the button was initially pressed (in seconds since epoch), or 0 if none was pressed. */
+     int64_t               m_updateButtontime;                  /**< the timestamp when the button was updated (in seconds since epoch), or 0 if none was pressed. */
++    int64_t               m_repeatButtontime;                  /**< the timestamp when the button will next repeat (in seconds since epoch), or 0 if repeat is disabled. */
++    int64_t               m_releaseButtontime;                 /**< the timestamp when the button will be released (in seconds since epoch), or 0 if none was pressed. */
++    int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
++    int32_t               m_releasedButtoncount;               /**< the number of times a button pressed message has been seen for this press. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+     int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+     cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+diff --git a/src/libcec/implementations/CECCommandHandler.cpp b/src/libcec/implementations/CECCommandHandler.cpp
+index 6d6244e..d64186f 100644
+--- a/src/libcec/implementations/CECCommandHandler.cpp
++++ b/src/libcec/implementations/CECCommandHandler.cpp
+@@ -770,7 +770,7 @@ int CCECCommandHandler::HandleUserControlRelease(const cec_command &command)
+ 
+   CECClientPtr client = m_processor->GetClient(command.destination);
+   if (client)
+-    client->AddKey();
++    client->AddKey(false, true);
+ 
+   return COMMAND_HANDLED;
+ }
+-- 
+1.9.1
+
+
+From 3336d0827f7fd159430f3431642b07090c06c869 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Tue, 28 Oct 2014 01:21:35 +0000
+Subject: [PATCH 4/6] Skip double press removal. It is handled through other
+ means.
+
+---
+ src/libcec/CECClient.cpp | 18 +-----------------
+ src/libcec/CECClient.h   |  2 --
+ 2 files changed, 1 insertion(+), 19 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 598628d..dccd874 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -60,11 +60,8 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
+     m_releaseButtontime(0),
+     m_pressedButtoncount(0),
+     m_releasedButtoncount(0),
+-    m_iPreventForwardingPowerOffCommand(0),
+-    m_iLastKeypressTime(0)
++    m_iPreventForwardingPowerOffCommand(0)
+ {
+-  m_lastKeypress.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+-  m_lastKeypress.duration = 0;
+   m_configuration.Clear();
+   // set the initial configuration
+   SetConfiguration(configuration);
+@@ -1647,20 +1644,7 @@ void CCECClient::CallbackAddKey(const cec_keypress &key)
+ {
+   CLockObject lock(m_cbMutex);
+   if (m_configuration.callbacks && m_configuration.callbacks->CBCecKeyPress)
+-  {
+-    // prevent double taps
+-    int64_t now = GetTimeMs();
+-    if (m_lastKeypress.keycode != key.keycode ||
+-        key.duration > 0 ||
+-        now - m_iLastKeypressTime >= DoubleTapTimeoutMS())
+-    {
+-      // no double tap
+-      if (key.duration == 0)
+-        m_iLastKeypressTime = now;
+-      m_lastKeypress = key;
+       m_configuration.callbacks->CBCecKeyPress(m_configuration.callbackParam, key);
+-    }
+-  }
+ }
+ 
+ void CCECClient::CallbackAddLog(const cec_log_message &message)
+diff --git a/src/libcec/CECClient.h b/src/libcec/CECClient.h
+index adeb5af..43a713b 100644
+--- a/src/libcec/CECClient.h
++++ b/src/libcec/CECClient.h
+@@ -411,8 +411,6 @@ namespace CEC
+     int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
+     int32_t               m_releasedButtoncount;               /**< the number of times a button pressed message has been seen for this press. */
+     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
+-    int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
+-    cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
+     PLATFORM::SyncedBuffer<CCallbackWrap*> m_callbackCalls;
+   };
+ }
+-- 
+1.9.1
+
+
+From 0dd0234f620a546bfa843172648383f83d88088c Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Mon, 3 Nov 2014 23:28:04 +0000
+Subject: [PATCH 5/6] Pass through duration on all button repeats
+
+---
+ src/libcec/CECClient.cpp | 34 ++++++++++++++++++++++++----------
+ 1 file changed, 24 insertions(+), 10 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index dccd874..1946148 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -986,10 +986,6 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+ 
+-  // we ignore button releases when supporting repeating keys
+-  if (bButtonRelease && m_configuration.iButtonRepeatRateMs && m_configuration.iButtonReleaseDelayMs)
+-    return;
+-
+   {
+     CLockObject lock(m_mutex);
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
+@@ -1015,6 +1011,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
+     }
+   }
+ 
++  // we don't forward releases when supporting repeating keys
++  if (bButtonRelease && m_configuration.iButtonRepeatRateMs)
++    return;
++
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+   {
+     LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
+@@ -1107,7 +1107,7 @@ void CCECClient::AddKey(const cec_keypress &key)
+ 
+   if (!isrepeat && (key.keycode != comboKey || key.duration > 0))
+   {
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x)", ToString(transmitKey.keycode), transmitKey.keycode);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x, %d)", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration);
+     QueueAddKey(transmitKey);
+   }
+ }
+@@ -1129,6 +1129,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+   cec_keypress key;
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
++  key.duration = 0;
+ 
+   {
+     CLockObject lock(m_mutex);
+@@ -1140,8 +1141,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs) ||
+-          (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)))
++          m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1155,9 +1155,23 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_releasedButtoncount = 0;
+     }
+     else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
++          m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
++    {
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
++      key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
++
++      m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
++      m_initialButtontime = 0;
++      m_updateButtontime = 0;
++      m_repeatButtontime = 0;
++      m_releaseButtontime = 0;
++      m_pressedButtoncount = 0;
++      m_releasedButtoncount = 0;
++    }
++    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+           (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
+     {
+-      key.duration = 0;
++      key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+       m_repeatButtontime = iNow + m_configuration.iButtonRepeatRateMs;
+       timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+@@ -1176,8 +1190,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+       }
+     }
+-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key %s: %s (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : key.duration ? "released" : "repeated",
+-        ToString(m_iCurrentButton), m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
++    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Key %s: %s (duration:%d) (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d,rel:%d)", ToString(m_iCurrentButton), key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : m_repeatButtontime ? "repeated" : "released", key.duration,
++        m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount, m_releasedButtoncount);
+   }
+ 
+   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+-- 
+1.9.1
+
+
+From 1ea01f59d8186d4d53af41961aaccbbc11651115 Mon Sep 17 00:00:00 2001
+From: popcornmix <popcornmix@gmail.com>
+Date: Wed, 5 Nov 2014 21:04:25 +0000
+Subject: [PATCH 6/6] squash: Fix for stop needing to be pressed twice
+
+---
+ src/libcec/CECClient.cpp | 17 ++++++++---------
+ 1 file changed, 8 insertions(+), 9 deletions(-)
+
+diff --git a/src/libcec/CECClient.cpp b/src/libcec/CECClient.cpp
+index 1946148..f4f114b 100644
+--- a/src/libcec/CECClient.cpp
++++ b/src/libcec/CECClient.cpp
+@@ -1131,6 +1131,8 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+   key.duration = 0;
+ 
++  if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
++    return timeout;
+   {
+     CLockObject lock(m_mutex);
+     uint64_t iNow = GetTimeMs();
+@@ -1140,8 +1142,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+     uint32_t iTimeoutMs(m_configuration.clientVersion >= LIBCEC_VERSION_TO_UINT(2, 0, 5) ?
+         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);
+ 
+-    if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
++    if (m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1154,8 +1155,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_pressedButtoncount = 0;
+       m_releasedButtoncount = 0;
+     }
+-    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
++    else if (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+@@ -1168,8 +1168,7 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+       m_pressedButtoncount = 0;
+       m_releasedButtoncount = 0;
+     }
+-    else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
+-          (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime))
++    else if (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime)
+     {
+       key.duration = (unsigned int) (iNow - m_initialButtontime);
+       key.keycode = m_iCurrentButton;
+@@ -1178,11 +1177,11 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
+     }
+     else
+     {
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
++      if (m_iCurrentButton == comboKey && iTimeoutMs > 0)
+         timeout = std::min((uint64_t)timeout, m_updateButtontime - iNow + iTimeoutMs);
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_releaseButtontime)
++      if (m_iCurrentButton != comboKey && m_releaseButtontime)
+         timeout = std::min((uint64_t)timeout, m_releaseButtontime - iNow);
+-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey && m_repeatButtontime)
++      if (m_iCurrentButton != comboKey && m_repeatButtontime)
+         timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
+       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+       {
+-- 
+1.9.1
+
diff -Naur c/tools/depends/target/Toolchain_binaddons.cmake.in d/tools/depends/target/Toolchain_binaddons.cmake.in
--- c/tools/depends/target/Toolchain_binaddons.cmake.in	2015-10-21 00:52:07.000000000 +0300
+++ d/tools/depends/target/Toolchain_binaddons.cmake.in	2016-04-06 18:32:36.000000000 +0300
@@ -1,7 +1,7 @@
 set(CMAKE_SYSTEM_VERSION 1)
 set(OS "@platform_os@")
 set(CPU "@use_cpu@")
-set(PLATFORM "@use_platform@")
+set(PLATFORM "@target_platform@")
 if("${OS}" STREQUAL "linux" OR "${OS}" STREQUAL "android")
   set(CMAKE_SYSTEM_NAME Linux)
 endif()
diff -Naur c/tools/depends/target/Toolchain.cmake.in d/tools/depends/target/Toolchain.cmake.in
--- c/tools/depends/target/Toolchain.cmake.in	2015-10-21 00:52:07.000000000 +0300
+++ d/tools/depends/target/Toolchain.cmake.in	2016-04-06 18:32:36.000000000 +0300
@@ -1,6 +1,6 @@
 SET(OS "@platform_os@")
 SET(CPU "@use_cpu@")
-SET(PLATFORM "@use_platform@")
+SET(PLATFORM "@target_platform@")
 IF("${OS}" STREQUAL "linux" OR "${OS}" STREQUAL "android")
 SET(CMAKE_SYSTEM_NAME Linux)
 ENDIF()
diff -Naur c/xbmc/Application.cpp d/xbmc/Application.cpp
--- c/xbmc/Application.cpp	2015-10-21 00:51:47.000000000 +0300
+++ d/xbmc/Application.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -2503,7 +2503,7 @@
 #if defined(TARGET_RASPBERRY_PI) || defined(HAS_IMXVPU)
     // This code reduces rendering fps of the GUI layer when playing videos in fullscreen mode
     // it makes only sense on architectures with multiple layers
-    if (g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback() && g_renderManager.IsVideoLayer())
+    if (m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPausedPlayback() && g_renderManager.IsVideoLayer())
       fps = CSettings::Get().GetInt("videoplayer.limitguiupdate");
 #endif
 
@@ -2516,6 +2516,8 @@
     {
       if (!m_skipGuiRender)
         g_windowManager.Process(CTimeUtils::GetFrameTime());
+      else if (!g_graphicsContext.IsFullScreenVideo())
+        g_renderManager.FrameMove();
     }
     g_windowManager.FrameMove();
   }
@@ -4995,3 +4997,13 @@
   
   return false;
 }
+
+bool CApplication::ScreenSaverDisablesAutoScrolling()
+{
+  bool onBlackDimScreenSaver = IsInScreenSaver() && m_screenSaver &&
+    (m_screenSaver->ID() == "screensaver.xbmc.builtin.black" ||
+     m_screenSaver->ID() == "screensaver.xbmc.builtin.dim");
+  bool openingStreams = m_pPlayer->IsPlaying() && g_windowManager.IsWindowActive(WINDOW_DIALOG_BUSY);
+
+  return onBlackDimScreenSaver || openingStreams;
+}
diff -Naur c/xbmc/Application.cpp.orig d/xbmc/Application.cpp.orig
--- c/xbmc/Application.cpp.orig	1970-01-01 03:00:00.000000000 +0300
+++ d/xbmc/Application.cpp.orig	2015-10-21 00:51:47.000000000 +0300
@@ -0,0 +1,4997 @@
+/*
+ *      Copyright (C) 2005-2013 Team XBMC
+ *      http://xbmc.org
+ *
+ *  This Program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2, or (at your option)
+ *  any later version.
+ *
+ *  This Program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with XBMC; see the file COPYING.  If not, see
+ *  <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "network/Network.h"
+#include "threads/SystemClock.h"
+#include "system.h"
+#include "Application.h"
+#include "interfaces/Builtins.h"
+#include "utils/Variant.h"
+#include "utils/Splash.h"
+#include "LangInfo.h"
+#include "utils/Screenshot.h"
+#include "Util.h"
+#include "URL.h"
+#include "guilib/TextureManager.h"
+#include "cores/IPlayer.h"
+#include "cores/dvdplayer/DVDFileInfo.h"
+#include "cores/AudioEngine/AEFactory.h"
+#include "cores/AudioEngine/Utils/AEUtil.h"
+#include "PlayListPlayer.h"
+#include "Autorun.h"
+#include "video/Bookmark.h"
+#include "video/VideoLibraryQueue.h"
+#include "guilib/GUIControlProfiler.h"
+#include "utils/LangCodeExpander.h"
+#include "GUIInfoManager.h"
+#include "playlists/PlayListFactory.h"
+#include "guilib/GUIFontManager.h"
+#include "guilib/GUIColorManager.h"
+#include "guilib/StereoscopicsManager.h"
+#include "addons/LanguageResource.h"
+#include "addons/Skin.h"
+#include "interfaces/generic/ScriptInvocationManager.h"
+#ifdef HAS_PYTHON
+#include "interfaces/python/XBPython.h"
+#endif
+#include "input/ButtonTranslator.h"
+#include "guilib/GUIAudioManager.h"
+#include "GUIPassword.h"
+#include "input/InertialScrollingHandler.h"
+#include "ApplicationMessenger.h"
+#include "SectionLoader.h"
+#include "cores/DllLoader/DllLoaderContainer.h"
+#include "GUIUserMessages.h"
+#include "filesystem/Directory.h"
+#include "filesystem/DirectoryCache.h"
+#include "filesystem/StackDirectory.h"
+#include "filesystem/SpecialProtocol.h"
+#include "filesystem/DllLibCurl.h"
+#include "filesystem/PluginDirectory.h"
+#ifdef HAS_FILESYSTEM_SAP
+#include "filesystem/SAPDirectory.h"
+#endif
+#include "utils/SystemInfo.h"
+#include "utils/TimeUtils.h"
+#include "GUILargeTextureManager.h"
+#include "TextureCache.h"
+#include "playlists/SmartPlayList.h"
+#ifdef HAS_FILESYSTEM_RAR
+#include "filesystem/RarManager.h"
+#endif
+#include "playlists/PlayList.h"
+#include "profiles/ProfilesManager.h"
+#include "windowing/WindowingFactory.h"
+#include "powermanagement/PowerManager.h"
+#include "powermanagement/DPMSSupport.h"
+#include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
+#include "settings/DisplaySettings.h"
+#include "settings/MediaSettings.h"
+#include "guilib/LocalizeStrings.h"
+#include "utils/CPUInfo.h"
+#include "utils/SeekHandler.h"
+
+#include "input/KeyboardLayoutManager.h"
+
+#if SDL_VERSION == 1
+#include <SDL/SDL.h>
+#elif SDL_VERSION == 2
+#include <SDL2/SDL.h>
+#endif
+
+#ifdef HAS_UPNP
+#include "network/upnp/UPnP.h"
+#include "filesystem/UPnPDirectory.h"
+#endif
+#if defined(TARGET_POSIX) && defined(HAS_FILESYSTEM_SMB)
+#include "filesystem/SMBDirectory.h"
+#endif
+#ifdef HAS_FILESYSTEM_NFS
+#include "filesystem/NFSFile.h"
+#endif
+#ifdef HAS_FILESYSTEM_SFTP
+#include "filesystem/SFTPFile.h"
+#endif
+#include "PartyModeManager.h"
+#ifdef HAS_VIDEO_PLAYBACK
+#include "cores/VideoRenderers/RenderManager.h"
+#endif
+#ifdef HAS_KARAOKE
+#include "music/karaoke/karaokelyricsmanager.h"
+#endif
+#include "network/ZeroconfBrowser.h"
+#ifndef TARGET_POSIX
+#include "threads/platform/win/Win32Exception.h"
+#endif
+#ifdef HAS_EVENT_SERVER
+#include "network/EventServer.h"
+#endif
+#ifdef HAS_DBUS
+#include <dbus/dbus.h>
+#endif
+#ifdef HAS_JSONRPC
+#include "interfaces/json-rpc/JSONRPC.h"
+#endif
+#include "interfaces/AnnouncementManager.h"
+#include "peripherals/Peripherals.h"
+#include "peripherals/dialogs/GUIDialogPeripheralManager.h"
+#include "peripherals/devices/PeripheralImon.h"
+#include "music/infoscanner/MusicInfoScanner.h"
+
+// Windows includes
+#include "guilib/GUIWindowManager.h"
+#include "video/dialogs/GUIDialogVideoInfo.h"
+#include "windows/GUIWindowScreensaver.h"
+#include "video/VideoInfoScanner.h"
+#include "video/PlayerController.h"
+
+// Dialog includes
+#include "video/dialogs/GUIDialogVideoBookmarks.h"
+#include "dialogs/GUIDialogYesNo.h"
+#include "dialogs/GUIDialogOK.h"
+#include "dialogs/GUIDialogKaiToast.h"
+#include "dialogs/GUIDialogSubMenu.h"
+#include "dialogs/GUIDialogButtonMenu.h"
+#include "dialogs/GUIDialogSimpleMenu.h"
+#include "addons/GUIDialogAddonSettings.h"
+
+// PVR related include Files
+#include "pvr/PVRManager.h"
+
+#include "epg/EpgContainer.h"
+
+#include "video/dialogs/GUIDialogFullScreenInfo.h"
+#include "guilib/GUIControlFactory.h"
+#include "dialogs/GUIDialogCache.h"
+#include "dialogs/GUIDialogPlayEject.h"
+#include "utils/URIUtils.h"
+#include "utils/XMLUtils.h"
+#include "addons/AddonInstaller.h"
+#include "addons/AddonManager.h"
+#include "music/tags/MusicInfoTag.h"
+#include "music/tags/MusicInfoTagLoaderFactory.h"
+#include "CompileInfo.h"
+
+#ifdef HAS_PERFORMANCE_SAMPLE
+#include "utils/PerformanceSample.h"
+#else
+#define MEASURE_FUNCTION
+#endif
+
+#ifdef TARGET_WINDOWS
+#include "win32util.h"
+#endif
+
+#ifdef TARGET_DARWIN_OSX
+#include "osx/CocoaInterface.h"
+#include "osx/XBMCHelper.h"
+#endif
+#ifdef TARGET_DARWIN
+#include "osx/DarwinUtils.h"
+#endif
+
+#ifdef HAS_DVD_DRIVE
+#include <cdio/logging.h>
+#endif
+
+#include "storage/MediaManager.h"
+#include "utils/JobManager.h"
+#include "utils/SaveFileStateJob.h"
+#include "utils/AlarmClock.h"
+#include "utils/StringUtils.h"
+#include "DatabaseManager.h"
+#include "input/InputManager.h"
+
+#ifdef TARGET_POSIX
+#include "XHandle.h"
+#endif
+
+#if defined(TARGET_ANDROID)
+#include "android/activity/XBMCApp.h"
+#include "android/activity/AndroidFeatures.h"
+#include "android/jni/Build.h"
+#endif
+
+#ifdef TARGET_WINDOWS
+#include "utils/Environment.h"
+#endif
+
+#if defined(HAS_LIBAMCODEC)
+#include "utils/AMLUtils.h"
+#endif
+
+#include "cores/FFmpeg.h"
+#include "utils/CharsetConverter.h"
+
+using namespace std;
+using namespace ADDON;
+using namespace XFILE;
+#ifdef HAS_DVD_DRIVE
+using namespace MEDIA_DETECT;
+#endif
+using namespace PLAYLIST;
+using namespace VIDEO;
+using namespace MUSIC_INFO;
+#ifdef HAS_EVENT_SERVER
+using namespace EVENTSERVER;
+#endif
+#ifdef HAS_JSONRPC
+using namespace JSONRPC;
+#endif
+using namespace ANNOUNCEMENT;
+using namespace PVR;
+using namespace EPG;
+using namespace PERIPHERALS;
+
+using namespace XbmcThreads;
+
+// uncomment this if you want to use release libs in the debug build.
+// Atm this saves you 7 mb of memory
+#define USE_RELEASE_LIBS
+
+#define MAX_FFWD_SPEED 5
+
+//extern IDirectSoundRenderer* m_pAudioDecoder;
+CApplication::CApplication(void)
+  : m_pPlayer(new CApplicationPlayer)
+  , m_itemCurrentFile(new CFileItem)
+  , m_stackFileItemToUpdate(new CFileItem)
+  , m_progressTrackingVideoResumeBookmark(*new CBookmark)
+  , m_progressTrackingItem(new CFileItem)
+  , m_musicInfoScanner(new CMusicInfoScanner)
+  , m_playerController(new CPlayerController)
+  , m_fallbackLanguageLoaded(false)
+{
+  m_network = NULL;
+  TiXmlBase::SetCondenseWhiteSpace(false);
+  m_bInhibitIdleShutdown = false;
+  m_bScreenSave = false;
+  m_dpms = NULL;
+  m_dpmsIsActive = false;
+  m_dpmsIsManual = false;
+  m_iScreenSaveLock = 0;
+  m_bInitializing = true;
+  m_eForcedNextPlayer = EPC_NONE;
+  m_strPlayListFile = "";
+  m_nextPlaylistItem = -1;
+  m_bPlaybackStarting = false;
+  m_ePlayState = PLAY_STATE_NONE;
+  m_skinReverting = false;
+  m_loggingIn = false;
+
+#ifdef HAS_GLX
+  XInitThreads();
+#endif
+
+
+  /* for now always keep this around */
+#ifdef HAS_KARAOKE
+  m_pKaraokeMgr = new CKaraokeLyricsManager();
+#endif
+  m_currentStack = new CFileItemList;
+
+  m_bPresentFrame = false;
+  m_bPlatformDirectories = true;
+
+  m_bStandalone = false;
+  m_bEnableLegacyRes = false;
+  m_bSystemScreenSaverEnable = false;
+  m_pInertialScrollingHandler = new CInertialScrollingHandler();
+#ifdef HAS_DVD_DRIVE
+  m_Autorun = new CAutorun();
+#endif
+
+  m_threadID = 0;
+  m_progressTrackingPlayCountUpdate = false;
+  m_currentStackPosition = 0;
+  m_lastFrameTime = 0;
+  m_lastRenderTime = 0;
+  m_skipGuiRender = false;
+  m_bTestMode = false;
+
+  m_muted = false;
+  m_volumeLevel = VOLUME_MAXIMUM;
+}
+
+CApplication::~CApplication(void)
+{
+  delete m_musicInfoScanner;
+  delete &m_progressTrackingVideoResumeBookmark;
+#ifdef HAS_DVD_DRIVE
+  delete m_Autorun;
+#endif
+  delete m_currentStack;
+
+#ifdef HAS_KARAOKE
+  delete m_pKaraokeMgr;
+#endif
+
+  delete m_dpms;
+  delete m_playerController;
+  delete m_pInertialScrollingHandler;
+  delete m_pPlayer;
+
+  m_actionListeners.clear();
+}
+
+bool CApplication::OnEvent(XBMC_Event& newEvent)
+{
+  switch(newEvent.type)
+  {
+    case XBMC_QUIT:
+      if (!g_application.m_bStop)
+        CApplicationMessenger::Get().Quit();
+      break;
+    case XBMC_VIDEORESIZE:
+      if (g_windowManager.Initialized() &&
+          !g_advancedSettings.m_fullScreen)
+      {
+        g_Windowing.SetWindowResolution(newEvent.resize.w, newEvent.resize.h);
+        g_graphicsContext.SetVideoResolution(RES_WINDOW, true);
+        CSettings::Get().SetInt("window.width", newEvent.resize.w);
+        CSettings::Get().SetInt("window.height", newEvent.resize.h);
+        CSettings::Get().Save();
+      }
+      break;
+    case XBMC_VIDEOMOVE:
+#ifdef TARGET_WINDOWS
+      if (g_advancedSettings.m_fullScreen)
+      {
+        // when fullscreen, remain fullscreen and resize to the dimensions of the new screen
+        RESOLUTION newRes = (RESOLUTION) g_Windowing.DesktopResolution(g_Windowing.GetCurrentScreen());
+        if (newRes != g_graphicsContext.GetVideoResolution())
+          CDisplaySettings::Get().SetCurrentResolution(newRes, true);
+      }
+      else
+#endif
+      {
+        g_Windowing.OnMove(newEvent.move.x, newEvent.move.y);
+      }
+      break;
+    case XBMC_USEREVENT:
+      CApplicationMessenger::Get().UserEvent(newEvent.user.code);
+      break;
+    case XBMC_APPCOMMAND:
+      return g_application.OnAppCommand(newEvent.appcommand.action);
+    case XBMC_SETFOCUS:
+      // Reset the screensaver
+      g_application.ResetScreenSaver();
+      g_application.WakeUpScreenSaverAndDPMS();
+      // Send a mouse motion event with no dx,dy for getting the current guiitem selected
+      g_application.OnAction(CAction(ACTION_MOUSE_MOVE, 0, static_cast<float>(newEvent.focus.x), static_cast<float>(newEvent.focus.y), 0, 0));
+      break;
+    default:
+      return CInputManager::Get().OnEvent(newEvent);
+  }
+  return true;
+}
+
+extern "C" void __stdcall init_emu_environ();
+extern "C" void __stdcall update_emu_environ();
+extern "C" void __stdcall cleanup_emu_environ();
+
+//
+// Utility function used to copy files from the application bundle
+// over to the user data directory in Application Support/Kodi.
+//
+static void CopyUserDataIfNeeded(const std::string &strPath, const std::string &file)
+{
+  std::string destPath = URIUtils::AddFileToFolder(strPath, file);
+  if (!CFile::Exists(destPath))
+  {
+    // need to copy it across
+    std::string srcPath = URIUtils::AddFileToFolder("special://xbmc/userdata/", file);
+    CFile::Copy(srcPath, destPath);
+  }
+}
+
+void CApplication::Preflight()
+{
+#ifdef HAS_DBUS
+  // call 'dbus_threads_init_default' before any other dbus calls in order to
+  // avoid race conditions with other threads using dbus connections
+  dbus_threads_init_default();
+#endif
+
+  // run any platform preflight scripts.
+#if defined(TARGET_DARWIN_OSX)
+  std::string install_path;
+
+  CUtil::GetHomePath(install_path);
+  setenv("KODI_HOME", install_path.c_str(), 0);
+  install_path += "/tools/darwin/runtime/preflight";
+  system(install_path.c_str());
+#endif
+}
+
+bool CApplication::SetupNetwork()
+{
+#if defined(HAS_LINUX_NETWORK)
+  m_network = new CNetworkLinux();
+#elif defined(HAS_WIN32_NETWORK)
+  m_network = new CNetworkWin32();
+#else
+  m_network = new CNetwork();
+#endif
+
+  return m_network != NULL;
+}
+
+bool CApplication::Create()
+{
+  SetupNetwork();
+  Preflight();
+
+  for (int i = RES_HDTV_1080i; i <= RES_PAL60_16x9; i++)
+  {
+    g_graphicsContext.ResetScreenParameters((RESOLUTION)i);
+    g_graphicsContext.ResetOverscan((RESOLUTION)i, CDisplaySettings::Get().GetResolutionInfo(i).Overscan);
+  }
+
+#ifdef TARGET_POSIX
+  tzset();   // Initialize timezone information variables
+#endif
+
+  // Grab a handle to our thread to be used later in identifying the render thread.
+  m_threadID = CThread::GetCurrentThreadId();
+
+#ifndef TARGET_POSIX
+  //floating point precision to 24 bits (faster performance)
+  _controlfp(_PC_24, _MCW_PC);
+
+  /* install win32 exception translator, win32 exceptions
+   * can now be caught using c++ try catch */
+  win32_exception::install_handler();
+
+#endif
+
+  // only the InitDirectories* for the current platform should return true
+  // putting this before the first log entries saves another ifdef for g_advancedSettings.m_logFolder
+  bool inited = InitDirectoriesLinux();
+  if (!inited)
+    inited = InitDirectoriesOSX();
+  if (!inited)
+    inited = InitDirectoriesWin32();
+
+  // copy required files
+  CopyUserDataIfNeeded("special://masterprofile/", "RssFeeds.xml");
+  CopyUserDataIfNeeded("special://masterprofile/", "favourites.xml");
+  CopyUserDataIfNeeded("special://masterprofile/", "Lircmap.xml");
+
+  if (!CLog::Init(CSpecialProtocol::TranslatePath(g_advancedSettings.m_logFolder).c_str()))
+  {
+    std::string lcAppName = CCompileInfo::GetAppName();
+    StringUtils::ToLower(lcAppName);
+    fprintf(stderr,"Could not init logging classes. Permission errors on ~/.%s (%s)\n", lcAppName.c_str(),
+      CSpecialProtocol::TranslatePath(g_advancedSettings.m_logFolder).c_str());
+    return false;
+  }
+
+  // Init our DllLoaders emu env
+  init_emu_environ();
+
+  CProfilesManager::Get().Load();
+
+  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+  CLog::Log(LOGNOTICE, "Starting %s (%s). Platform: %s %s %d-bit", g_infoManager.GetAppName().c_str(), g_infoManager.GetVersion().c_str(),
+            g_sysinfo.GetBuildTargetPlatformName().c_str(), g_sysinfo.GetBuildTargetCpuFamily().c_str(), g_sysinfo.GetXbmcBitness());
+
+  std::string buildType;
+#if defined(_DEBUG)
+  buildType = "Debug";
+#elif defined(NDEBUG)
+  buildType = "Release";
+#else
+  buildType = "Unknown";
+#endif
+  std::string specialVersion;
+#if defined(TARGET_DARWIN_IOS_ATV2)
+  specialVersion = " (version for AppleTV2)";
+#elif defined(TARGET_RASPBERRY_PI)
+  specialVersion = " (version for Raspberry Pi)";
+//#elif defined(some_ID) // uncomment for special version/fork
+//  specialVersion = " (version for XXXX)";
+#endif
+  CLog::Log(LOGNOTICE, "Using %s %s x%d build%s", buildType.c_str(), g_infoManager.GetAppName().c_str(), g_sysinfo.GetXbmcBitness(), specialVersion.c_str());
+  CLog::Log(LOGNOTICE, "%s compiled " __DATE__ " by %s for %s %s %d-bit %s (%s)", g_infoManager.GetAppName().c_str(), g_sysinfo.GetUsedCompilerNameAndVer().c_str(), g_sysinfo.GetBuildTargetPlatformName().c_str(),
+            g_sysinfo.GetBuildTargetCpuFamily().c_str(), g_sysinfo.GetXbmcBitness(), g_sysinfo.GetBuildTargetPlatformVersionDecoded().c_str(),
+            g_sysinfo.GetBuildTargetPlatformVersion().c_str());
+
+  std::string deviceModel(g_sysinfo.GetModelName());
+  if (!g_sysinfo.GetManufacturerName().empty())
+    deviceModel = g_sysinfo.GetManufacturerName() + " " + (deviceModel.empty() ? std::string("device") : deviceModel);
+  if (!deviceModel.empty())
+    CLog::Log(LOGNOTICE, "Running on %s with %s, kernel: %s %s %d-bit version %s", deviceModel.c_str(), g_sysinfo.GetOsPrettyNameWithVersion().c_str(),
+              g_sysinfo.GetKernelName().c_str(), g_sysinfo.GetKernelCpuFamily().c_str(), g_sysinfo.GetKernelBitness(), g_sysinfo.GetKernelVersionFull().c_str());
+  else
+    CLog::Log(LOGNOTICE, "Running on %s, kernel: %s %s %d-bit version %s", g_sysinfo.GetOsPrettyNameWithVersion().c_str(),
+              g_sysinfo.GetKernelName().c_str(), g_sysinfo.GetKernelCpuFamily().c_str(), g_sysinfo.GetKernelBitness(), g_sysinfo.GetKernelVersionFull().c_str());
+
+#if defined(TARGET_LINUX)
+#if USE_STATIC_FFMPEG
+  CLog::Log(LOGNOTICE, "FFmpeg statically linked, version: %s", FFMPEG_VERSION);
+#else  // !USE_STATIC_FFMPEG
+  CLog::Log(LOGNOTICE, "FFmpeg version: %s", FFMPEG_VERSION);
+#endif // !USE_STATIC_FFMPEG
+  if (!strstr(FFMPEG_VERSION, FFMPEG_VER_SHA))
+  {
+    if (strstr(FFMPEG_VERSION, "kodi"))
+      CLog::Log(LOGNOTICE, "WARNING: unknown ffmpeg-kodi version detected");
+    else
+      CLog::Log(LOGNOTICE, "WARNING: unsupported ffmpeg version detected");
+  }
+#endif
+  
+  std::string cpuModel(g_cpuInfo.getCPUModel());
+  if (!cpuModel.empty())
+    CLog::Log(LOGNOTICE, "Host CPU: %s, %d core%s available", cpuModel.c_str(), g_cpuInfo.getCPUCount(), (g_cpuInfo.getCPUCount() == 1) ? "" : "s");
+  else
+    CLog::Log(LOGNOTICE, "%d CPU core%s available", g_cpuInfo.getCPUCount(), (g_cpuInfo.getCPUCount() == 1) ? "" : "s");
+#if defined(TARGET_WINDOWS)
+  CLog::Log(LOGNOTICE, "%s", CWIN32Util::GetResInfoString().c_str());
+  CLog::Log(LOGNOTICE, "Running with %s rights", (CWIN32Util::IsCurrentUserLocalAdministrator() == TRUE) ? "administrator" : "restricted");
+  CLog::Log(LOGNOTICE, "Aero is %s", (g_sysinfo.IsAeroDisabled() == true) ? "disabled" : "enabled");
+#endif
+#if defined(TARGET_ANDROID)
+  CLog::Log(LOGNOTICE,
+        "Product: %s, Device: %s, Board: %s - Manufacturer: %s, Brand: %s, Model: %s, Hardware: %s",
+        CJNIBuild::PRODUCT.c_str(), CJNIBuild::DEVICE.c_str(), CJNIBuild::BOARD.c_str(),
+        CJNIBuild::MANUFACTURER.c_str(), CJNIBuild::BRAND.c_str(), CJNIBuild::MODEL.c_str(), CJNIBuild::HARDWARE.c_str());
+  std::string extstorage;
+  bool extready = CXBMCApp::GetExternalStorage(extstorage);
+  CLog::Log(LOGNOTICE, "External storage path = %s; status = %s", extstorage.c_str(), extready ? "ok" : "nok");
+#endif
+
+#if defined(__arm__)
+  if (g_cpuInfo.GetCPUFeatures() & CPU_FEATURE_NEON)
+    CLog::Log(LOGNOTICE, "ARM Features: Neon enabled");
+  else
+    CLog::Log(LOGNOTICE, "ARM Features: Neon disabled");
+#endif
+  CSpecialProtocol::LogPaths();
+
+  std::string executable = CUtil::ResolveExecutablePath();
+  CLog::Log(LOGNOTICE, "The executable running is: %s", executable.c_str());
+  std::string hostname("[unknown]");
+  m_network->GetHostName(hostname);
+  CLog::Log(LOGNOTICE, "Local hostname: %s", hostname.c_str());
+  std::string lowerAppName = CCompileInfo::GetAppName();
+  StringUtils::ToLower(lowerAppName);
+  CLog::Log(LOGNOTICE, "Log File is located: %s%s.log", g_advancedSettings.m_logFolder.c_str(), lowerAppName.c_str());
+  CRegExp::LogCheckUtf8Support();
+  CLog::Log(LOGNOTICE, "-----------------------------------------------------------------------");
+
+  std::string strExecutablePath;
+  CUtil::GetHomePath(strExecutablePath);
+
+  // for python scripts that check the OS
+#if defined(TARGET_DARWIN)
+  setenv("OS","OS X",true);
+#elif defined(TARGET_POSIX)
+  setenv("OS","Linux",true);
+#elif defined(TARGET_WINDOWS)
+  CEnvironment::setenv("OS", "win32");
+#endif
+
+  // register ffmpeg lockmanager callback
+  av_lockmgr_register(&ffmpeg_lockmgr_cb);
+  // register avcodec
+  avcodec_register_all();
+  // register avformat
+  av_register_all();
+  // register avfilter
+  avfilter_register_all();
+  // set avutil callback
+  av_log_set_callback(ff_avutil_log);
+
+  g_powerManager.Initialize();
+
+  // Load the AudioEngine before settings as they need to query the engine
+  if (!CAEFactory::LoadEngine())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Failed to load an AudioEngine");
+    return false;
+  }
+
+  // Initialize default Settings - don't move
+  CLog::Log(LOGNOTICE, "load settings...");
+  if (!CSettings::Get().Initialize())
+    return false;
+
+  g_powerManager.SetDefaults();
+
+  // load the actual values
+  if (!CSettings::Get().Load())
+  {
+    CLog::Log(LOGFATAL, "unable to load settings");
+    return false;
+  }
+  CSettings::Get().SetLoaded();
+
+  CLog::Log(LOGINFO, "creating subdirectories");
+  CLog::Log(LOGINFO, "userdata folder: %s", CProfilesManager::Get().GetProfileUserDataFolder().c_str());
+  CLog::Log(LOGINFO, "recording folder: %s", CSettings::Get().GetString("audiocds.recordingpath").c_str());
+  CLog::Log(LOGINFO, "screenshots folder: %s", CSettings::Get().GetString("debug.screenshotpath").c_str());
+  CDirectory::Create(CProfilesManager::Get().GetUserDataFolder());
+  CDirectory::Create(CProfilesManager::Get().GetProfileUserDataFolder());
+  CProfilesManager::Get().CreateProfileFolders();
+
+  update_emu_environ();//apply the GUI settings
+
+#ifdef TARGET_WINDOWS
+  CWIN32Util::SetThreadLocalLocale(true); // enable independent locale for each thread, see https://connect.microsoft.com/VisualStudio/feedback/details/794122
+#endif // TARGET_WINDOWS
+
+  // start the AudioEngine
+  if (!CAEFactory::StartEngine())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Failed to start the AudioEngine");
+    return false;
+  }
+
+  // restore AE's previous volume state
+  SetHardwareVolume(m_volumeLevel);
+  CAEFactory::SetMute     (m_muted);
+  CAEFactory::SetSoundMode(CSettings::Get().GetInt("audiooutput.guisoundmode"));
+
+  // initialize m_replayGainSettings
+  m_replayGainSettings.iType = CSettings::Get().GetInt("musicplayer.replaygaintype");
+  m_replayGainSettings.iPreAmp = CSettings::Get().GetInt("musicplayer.replaygainpreamp");
+  m_replayGainSettings.iNoGainPreAmp = CSettings::Get().GetInt("musicplayer.replaygainnogainpreamp");
+  m_replayGainSettings.bAvoidClipping = CSettings::Get().GetBool("musicplayer.replaygainavoidclipping");
+
+  // initialize the addon database (must be before the addon manager is init'd)
+  CDatabaseManager::Get().Initialize(true);
+
+#ifdef HAS_PYTHON
+  CScriptInvocationManager::Get().RegisterLanguageInvocationHandler(&g_pythonParser, ".py");
+#endif // HAS_PYTHON
+
+  // start-up Addons Framework
+  // currently bails out if either cpluff Dll is unavailable or system dir can not be scanned
+  if (!CAddonMgr::Get().Init())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to start CAddonMgr");
+    return false;
+  }
+
+  // Create the Mouse, Keyboard, Remote, and Joystick devices
+  // Initialize after loading settings to get joystick deadzone setting
+  CInputManager::Get().InitializeInputs();
+
+  // load the keyboard layouts
+  if (!CKeyboardLayoutManager::Get().Load())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to load keyboard layouts");
+    return false;
+  }
+
+#if defined(TARGET_DARWIN_OSX)
+  // Configure and possible manually start the helper.
+  XBMCHelper::GetInstance().Configure();
+#endif
+
+  CUtil::InitRandomSeed();
+
+  g_mediaManager.Initialize();
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
+  m_lastRenderTime = m_lastFrameTime;
+  return true;
+}
+
+bool CApplication::CreateGUI()
+{
+  m_renderGUI = true;
+#ifdef HAS_SDL
+  CLog::Log(LOGNOTICE, "Setup SDL");
+
+  /* Clean up on exit, exit on window close and interrupt */
+  atexit(SDL_Quit);
+
+  uint32_t sdlFlags = 0;
+
+#if defined(TARGET_DARWIN_OSX)
+  sdlFlags |= SDL_INIT_VIDEO;
+#endif
+
+#if defined(HAS_SDL_JOYSTICK) && !defined(TARGET_WINDOWS)
+  sdlFlags |= SDL_INIT_JOYSTICK;
+#endif
+
+  //depending on how it's compiled, SDL periodically calls XResetScreenSaver when it's fullscreen
+  //this might bring the monitor out of standby, so we have to disable it explicitly
+  //by passing 0 for overwrite to setsenv, the user can still override this by setting the environment variable
+#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
+  setenv("SDL_VIDEO_ALLOW_SCREENSAVER", "1", 0);
+#endif
+
+#endif // HAS_SDL
+
+#ifdef TARGET_POSIX
+  // for nvidia cards - vsync currently ALWAYS enabled.
+  // the reason is that after screen has been setup changing this env var will make no difference.
+  setenv("__GL_SYNC_TO_VBLANK", "1", 0);
+  setenv("__GL_YIELD", "USLEEP", 0);
+#endif
+
+  m_bSystemScreenSaverEnable = g_Windowing.IsSystemScreenSaverEnabled();
+  g_Windowing.EnableSystemScreenSaver(false);
+
+#ifdef HAS_SDL
+  if (SDL_Init(sdlFlags) != 0)
+  {
+    CLog::Log(LOGFATAL, "XBAppEx: Unable to initialize SDL: %s", SDL_GetError());
+    return false;
+  }
+  #if defined(TARGET_DARWIN)
+  // SDL_Init will install a handler for segfaults, restore the default handler.
+  signal(SIGSEGV, SIG_DFL);
+  #endif
+#endif
+
+  // Initialize core peripheral port support. Note: If these parameters
+  // are 0 and NULL, respectively, then the default number and types of
+  // controllers will be initialized.
+  if (!g_Windowing.InitWindowSystem())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to init windowing system");
+    return false;
+  }
+
+  // Retrieve the matching resolution based on GUI settings
+  bool sav_res = false;
+  CDisplaySettings::Get().SetCurrentResolution(CDisplaySettings::Get().GetDisplayResolution());
+  CLog::Log(LOGNOTICE, "Checking resolution %i", CDisplaySettings::Get().GetCurrentResolution());
+  if (!g_graphicsContext.IsValidResolution(CDisplaySettings::Get().GetCurrentResolution()))
+  {
+    CLog::Log(LOGNOTICE, "Setting safe mode %i", RES_DESKTOP);
+    // defer saving resolution after window was created
+    CDisplaySettings::Get().SetCurrentResolution(RES_DESKTOP);
+    sav_res = true;
+  }
+
+  // update the window resolution
+  g_Windowing.SetWindowResolution(CSettings::Get().GetInt("window.width"), CSettings::Get().GetInt("window.height"));
+
+  if (g_advancedSettings.m_startFullScreen && CDisplaySettings::Get().GetCurrentResolution() == RES_WINDOW)
+  {
+    // defer saving resolution after window was created
+    CDisplaySettings::Get().SetCurrentResolution(RES_DESKTOP);
+    sav_res = true;
+  }
+
+  if (!g_graphicsContext.IsValidResolution(CDisplaySettings::Get().GetCurrentResolution()))
+  {
+    // Oh uh - doesn't look good for starting in their wanted screenmode
+    CLog::Log(LOGERROR, "The screen resolution requested is not valid, resetting to a valid mode");
+    CDisplaySettings::Get().SetCurrentResolution(RES_DESKTOP);
+    sav_res = true;
+  }
+  if (!InitWindow())
+  {
+    return false;
+  }
+
+  if (sav_res)
+    CDisplaySettings::Get().SetCurrentResolution(RES_DESKTOP, true);
+
+  if (g_advancedSettings.m_splashImage)
+    CSplash::Get().Show();
+
+  // The key mappings may already have been loaded by a peripheral
+  CLog::Log(LOGINFO, "load keymapping");
+  if (!CButtonTranslator::GetInstance().Load())
+    return false;
+
+  RESOLUTION_INFO info = g_graphicsContext.GetResInfo();
+  CLog::Log(LOGINFO, "GUI format %ix%i, Display %s",
+            info.iWidth,
+            info.iHeight,
+            info.strMode.c_str());
+
+  g_windowManager.Initialize();
+
+  return true;
+}
+
+bool CApplication::InitWindow()
+{
+  RESOLUTION res = CDisplaySettings::Get().GetCurrentResolution();
+
+#ifdef TARGET_DARWIN_OSX
+  // force initial window creation to be windowed, if fullscreen, it will switch to it below
+  // fixes the white screen of death if starting fullscreen and switching to windowed.
+  bool bFullScreen = false;
+  if (!g_Windowing.CreateNewWindow(CSysInfo::GetAppName(), bFullScreen, CDisplaySettings::Get().GetResolutionInfo(RES_WINDOW), OnEvent))
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to create window");
+    return false;
+  }
+#elif defined(TARGET_ANDROID)
+  // We might come from a refresh rate switch destroying the native window; use the renderer resolution
+  if (g_graphicsContext.GetVideoResolution() != RES_INVALID)
+    res = g_graphicsContext.GetVideoResolution();
+  RESOLUTION_INFO res_info = CDisplaySettings::Get().GetResolutionInfo(res);
+
+  bool bFullScreen = res != RES_WINDOW;
+  if (!g_Windowing.CreateNewWindow(CSysInfo::GetAppName(), bFullScreen, res_info, OnEvent))
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to create window");
+    return false;
+  }
+#else
+  bool bFullScreen = CDisplaySettings::Get().GetCurrentResolution() != RES_WINDOW;
+  if (!g_Windowing.CreateNewWindow(CSysInfo::GetAppName(), bFullScreen, CDisplaySettings::Get().GetCurrentResolutionInfo(), OnEvent))
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to create window");
+    return false;
+  }
+#endif
+
+  if (!g_Windowing.InitRenderSystem())
+  {
+    CLog::Log(LOGFATAL, "CApplication::Create: Unable to init rendering system");
+    return false;
+  }
+  // set GUI res and force the clear of the screen
+  g_graphicsContext.SetVideoResolution(res);
+  return true;
+}
+
+bool CApplication::DestroyWindow()
+{
+  return g_Windowing.DestroyWindow();
+}
+
+bool CApplication::InitDirectoriesLinux()
+{
+/*
+   The following is the directory mapping for Platform Specific Mode:
+
+   special://xbmc/          => [read-only] system directory (/usr/share/kodi)
+   special://home/          => [read-write] user's directory that will override special://kodi/ system-wide
+                               installations like skins, screensavers, etc.
+                               ($HOME/.kodi)
+                               NOTE: XBMC will look in both special://xbmc/addons and special://home/addons for addons.
+   special://masterprofile/ => [read-write] userdata of master profile. It will by default be
+                               mapped to special://home/userdata ($HOME/.kodi/userdata)
+   special://profile/       => [read-write] current profile's userdata directory.
+                               Generally special://masterprofile for the master profile or
+                               special://masterprofile/profiles/<profile_name> for other profiles.
+
+   NOTE: All these root directories are lowercase. Some of the sub-directories
+         might be mixed case.
+*/
+
+#if defined(TARGET_POSIX) && !defined(TARGET_DARWIN)
+  std::string userName;
+  if (getenv("USER"))
+    userName = getenv("USER");
+  else
+    userName = "root";
+
+  std::string userHome;
+  if (getenv("HOME"))
+    userHome = getenv("HOME");
+  else
+    userHome = "/root";
+
+  std::string appBinPath, appPath;
+  std::string appName = CCompileInfo::GetAppName();
+  std::string dotLowerAppName = "." + appName;
+  StringUtils::ToLower(dotLowerAppName);
+  const char* envAppHome = "KODI_HOME";
+  const char* envAppBinHome = "KODI_BIN_HOME";
+  const char* envAppTemp = "KODI_TEMP";
+
+  CUtil::GetHomePath(appBinPath, envAppBinHome);
+  if (getenv(envAppHome))
+    appPath = getenv(envAppHome);
+  else
+  {
+    appPath = appBinPath;
+    /* Check if binaries and arch independent data files are being kept in
+     * separate locations. */
+    if (!CDirectory::Exists(URIUtils::AddFileToFolder(appPath, "userdata")))
+    {
+      /* Attempt to locate arch independent data files. */
+      CUtil::GetHomePath(appPath);
+      if (!CDirectory::Exists(URIUtils::AddFileToFolder(appPath, "userdata")))
+      {
+        fprintf(stderr, "Unable to find path to %s data files!\n", appName.c_str());
+        exit(1);
+      }
+    }
+  }
+
+  /* Set some environment variables */
+  setenv(envAppBinHome, appBinPath.c_str(), 0);
+  setenv(envAppHome, appPath.c_str(), 0);
+
+  if (m_bPlatformDirectories)
+  {
+    // map our special drives
+    CSpecialProtocol::SetXBMCBinPath(appBinPath);
+    CSpecialProtocol::SetXBMCPath(appPath);
+    CSpecialProtocol::SetHomePath(userHome + "/" + dotLowerAppName);
+    CSpecialProtocol::SetMasterProfilePath(userHome + "/" + dotLowerAppName + "/userdata");
+
+    std::string strTempPath = userHome;
+    strTempPath = URIUtils::AddFileToFolder(strTempPath, dotLowerAppName + "/temp");
+    if (getenv(envAppTemp))
+      strTempPath = getenv(envAppTemp);
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_advancedSettings.m_logFolder = strTempPath;
+
+    CreateUserDirs();
+
+  }
+  else
+  {
+    URIUtils::AddSlashAtEnd(appPath);
+    g_advancedSettings.m_logFolder = appPath;
+
+    CSpecialProtocol::SetXBMCBinPath(appBinPath);
+    CSpecialProtocol::SetXBMCPath(appPath);
+    CSpecialProtocol::SetHomePath(URIUtils::AddFileToFolder(appPath, "portable_data"));
+    CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(appPath, "portable_data/userdata"));
+
+    std::string strTempPath = appPath;
+    strTempPath = URIUtils::AddFileToFolder(strTempPath, "portable_data/temp");
+    if (getenv(envAppTemp))
+      strTempPath = getenv(envAppTemp);
+    CSpecialProtocol::SetTempPath(strTempPath);
+    CreateUserDirs();
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_advancedSettings.m_logFolder = strTempPath;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CApplication::InitDirectoriesOSX()
+{
+#if defined(TARGET_DARWIN)
+  std::string userName;
+  if (getenv("USER"))
+    userName = getenv("USER");
+  else
+    userName = "root";
+
+  std::string userHome;
+  if (getenv("HOME"))
+    userHome = getenv("HOME");
+  else
+    userHome = "/root";
+
+  std::string appPath;
+  CUtil::GetHomePath(appPath);
+  setenv("KODI_HOME", appPath.c_str(), 0);
+
+#if defined(TARGET_DARWIN_IOS)
+  std::string fontconfigPath;
+  fontconfigPath = appPath + "/system/players/dvdplayer/etc/fonts/fonts.conf";
+  setenv("FONTCONFIG_FILE", fontconfigPath.c_str(), 0);
+#endif
+
+  // setup path to our internal dylibs so loader can find them
+  std::string frameworksPath = CUtil::GetFrameworksPath();
+  CSpecialProtocol::SetXBMCFrameworksPath(frameworksPath);
+
+  // OSX always runs with m_bPlatformDirectories == true
+  if (m_bPlatformDirectories)
+  {
+    // map our special drives
+    CSpecialProtocol::SetXBMCBinPath(appPath);
+    CSpecialProtocol::SetXBMCPath(appPath);
+    #if defined(TARGET_DARWIN_IOS)
+      std::string appName = CCompileInfo::GetAppName();
+      CSpecialProtocol::SetHomePath(userHome + "/" + CDarwinUtils::GetAppRootFolder() + "/" + appName);
+      CSpecialProtocol::SetMasterProfilePath(userHome + "/" + CDarwinUtils::GetAppRootFolder() + "/" + appName + "/userdata");
+    #else
+      std::string appName = CCompileInfo::GetAppName();
+      CSpecialProtocol::SetHomePath(userHome + "/Library/Application Support/" + appName);
+      CSpecialProtocol::SetMasterProfilePath(userHome + "/Library/Application Support/" + appName + "/userdata");
+    #endif
+
+    std::string dotLowerAppName = "." + appName;
+    StringUtils::ToLower(dotLowerAppName);
+    // location for temp files
+    #if defined(TARGET_DARWIN_IOS)
+      std::string strTempPath = URIUtils::AddFileToFolder(userHome,  std::string(CDarwinUtils::GetAppRootFolder()) + "/" + appName + "/temp");
+    #else
+      std::string strTempPath = URIUtils::AddFileToFolder(userHome, dotLowerAppName + "/");
+      CDirectory::Create(strTempPath);
+      strTempPath = URIUtils::AddFileToFolder(userHome, dotLowerAppName + "/temp");
+    #endif
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    // xbmc.log file location
+    #if defined(TARGET_DARWIN_IOS)
+      strTempPath = userHome + "/" + std::string(CDarwinUtils::GetAppRootFolder());
+    #else
+      strTempPath = userHome + "/Library/Logs";
+    #endif
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_advancedSettings.m_logFolder = strTempPath;
+
+    CreateUserDirs();
+  }
+  else
+  {
+    URIUtils::AddSlashAtEnd(appPath);
+    g_advancedSettings.m_logFolder = appPath;
+
+    CSpecialProtocol::SetXBMCBinPath(appPath);
+    CSpecialProtocol::SetXBMCPath(appPath);
+    CSpecialProtocol::SetHomePath(URIUtils::AddFileToFolder(appPath, "portable_data"));
+    CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(appPath, "portable_data/userdata"));
+
+    std::string strTempPath = URIUtils::AddFileToFolder(appPath, "portable_data/temp");
+    CSpecialProtocol::SetTempPath(strTempPath);
+
+    URIUtils::AddSlashAtEnd(strTempPath);
+    g_advancedSettings.m_logFolder = strTempPath;
+  }
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+bool CApplication::InitDirectoriesWin32()
+{
+#ifdef TARGET_WINDOWS
+  std::string xbmcPath;
+
+  CUtil::GetHomePath(xbmcPath);
+  CEnvironment::setenv("KODI_HOME", xbmcPath);
+  CSpecialProtocol::SetXBMCBinPath(xbmcPath);
+  CSpecialProtocol::SetXBMCPath(xbmcPath);
+
+  std::string strWin32UserFolder = CWIN32Util::GetProfilePath();
+
+  g_advancedSettings.m_logFolder = strWin32UserFolder;
+  CSpecialProtocol::SetHomePath(strWin32UserFolder);
+  CSpecialProtocol::SetMasterProfilePath(URIUtils::AddFileToFolder(strWin32UserFolder, "userdata"));
+  CSpecialProtocol::SetTempPath(URIUtils::AddFileToFolder(strWin32UserFolder,"cache"));
+
+  CEnvironment::setenv("KODI_PROFILE_USERDATA", CSpecialProtocol::TranslatePath("special://masterprofile/"));
+
+  CreateUserDirs();
+
+  // Expand the DLL search path with our directories
+  CWIN32Util::ExtendDllPath();
+
+  return true;
+#else
+  return false;
+#endif
+}
+
+void CApplication::CreateUserDirs()
+{
+  CDirectory::Create("special://home/");
+  CDirectory::Create("special://home/addons");
+  CDirectory::Create("special://home/addons/packages");
+  CDirectory::Create("special://home/media");
+  CDirectory::Create("special://home/sounds");
+  CDirectory::Create("special://home/system");
+  CDirectory::Create("special://masterprofile/");
+  CDirectory::Create("special://temp/");
+  CDirectory::Create("special://temp/temp"); // temp directory for python and dllGetTempPathA
+}
+
+bool CApplication::Initialize()
+{
+#if defined(HAS_DVD_DRIVE) && !defined(TARGET_WINDOWS) // somehow this throws an "unresolved external symbol" on win32
+  // turn off cdio logging
+  cdio_loglevel_default = CDIO_LOG_ERROR;
+#endif
+
+#ifdef TARGET_POSIX // TODO: Win32 has no special://home/ mapping by default, so we
+              //       must create these here. Ideally this should be using special://home/ and
+              //       be platform agnostic (i.e. unify the InitDirectories*() functions)
+  if (!m_bPlatformDirectories)
+#endif
+  {
+    CDirectory::Create("special://xbmc/addons");
+    CDirectory::Create("special://xbmc/sounds");
+  }
+
+  // load the language and its translated strings
+  if (!LoadLanguage(false))
+    return false;
+
+  g_peripherals.Initialise();
+
+  // Load curl so curl_global_init gets called before any service threads
+  // are started. Unloading will have no effect as curl is never fully unloaded.
+  // To quote man curl_global_init:
+  //  "This function is not thread safe. You must not call it when any other
+  //  thread in the program (i.e. a thread sharing the same memory) is running.
+  //  This doesn't just mean no other thread that is using libcurl. Because
+  //  curl_global_init() calls functions of other libraries that are similarly
+  //  thread unsafe, it could conflict with any other thread that
+  //  uses these other libraries."
+  g_curlInterface.Load();
+  g_curlInterface.Unload();
+
+  // initialize (and update as needed) our databases
+  CDatabaseManager::Get().Initialize();
+
+  StartServices();
+
+  // Init DPMS, before creating the corresponding setting control.
+  m_dpms = new DPMSSupport();
+  bool uiInitializationFinished = true;
+  if (g_windowManager.Initialized())
+  {
+    CSettings::Get().GetSetting("powermanagement.displaysoff")->SetRequirementsMet(m_dpms->IsSupported());
+
+    g_windowManager.CreateWindows();
+    /* window id's 3000 - 3100 are reserved for python */
+
+    // initialize splash window after splash screen disappears
+    // because we need a real window in the background which gets
+    // rendered while we load the main window or enter the master lock key
+    if (g_advancedSettings.m_splashImage)
+      g_windowManager.ActivateWindow(WINDOW_SPLASH);
+
+    // Make sure we have at least the default skin
+    string defaultSkin = ((const CSettingString*)CSettings::Get().GetSetting("lookandfeel.skin"))->GetDefault();
+    if (!LoadSkin(CSettings::Get().GetString("lookandfeel.skin")) && !LoadSkin(defaultSkin))
+    {
+      CLog::Log(LOGERROR, "Default skin '%s' not found! Terminating..", defaultSkin.c_str());
+      return false;
+    }
+
+    if (CSettings::Get().GetBool("masterlock.startuplock") &&
+        CProfilesManager::Get().GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+       !CProfilesManager::Get().GetMasterProfile().getLockCode().empty())
+    {
+       g_passwordManager.CheckStartUpLock();
+    }
+
+    // check if we should use the login screen
+    if (CProfilesManager::Get().UsingLoginScreen())
+    {
+      // the login screen still needs to perform additional initialization
+      uiInitializationFinished = false;
+
+      g_windowManager.ActivateWindow(WINDOW_LOGIN_SCREEN);
+    }
+    else
+    {
+#ifdef HAS_JSONRPC
+      CJSONRPC::Initialize();
+#endif
+      ADDON::CAddonMgr::Get().StartServices(false);
+
+      // start the PVR manager
+      StartPVRManager();
+
+      // activate the configured start window
+      int firstWindow = g_SkinInfo->GetFirstWindow();
+      g_windowManager.ActivateWindow(firstWindow);
+
+      // the startup window is considered part of the initialization as it most likely switches to the final window
+      uiInitializationFinished = firstWindow != WINDOW_STARTUP_ANIM;
+
+      CStereoscopicsManager::Get().Initialize();
+    }
+
+  }
+  else //No GUI Created
+  {
+#ifdef HAS_JSONRPC
+    CJSONRPC::Initialize();
+#endif
+    ADDON::CAddonMgr::Get().StartServices(false);
+  }
+
+  g_sysinfo.Refresh();
+
+  CLog::Log(LOGINFO, "removing tempfiles");
+  CUtil::RemoveTempFiles();
+
+  if (!CProfilesManager::Get().UsingLoginScreen())
+  {
+    UpdateLibraries();
+    SetLoggingIn(true);
+  }
+
+  m_slowTimer.StartZero();
+
+  CAddonMgr::Get().StartServices(true);
+
+  // configure seek handler
+  CSeekHandler::Get().Configure();
+
+  // register action listeners
+  RegisterActionListener(&CSeekHandler::Get());
+
+  CLog::Log(LOGNOTICE, "initialize done");
+
+  m_bInitializing = false;
+
+  // reset our screensaver (starts timers etc.)
+  ResetScreenSaver();
+
+#ifdef HAS_SDL_JOYSTICK
+  CInputManager::Get().SetEnabledJoystick(CSettings::Get().GetBool("input.enablejoystick") &&
+                    CPeripheralImon::GetCountOfImonsConflictWithDInput() == 0 );
+#endif
+
+  // if the user interfaces has been fully initialized let everyone know
+  if (uiInitializationFinished)
+  {
+    CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UI_READY);
+    g_windowManager.SendThreadMessage(msg);
+  }
+
+  return true;
+}
+
+bool CApplication::StartServer(enum ESERVERS eServer, bool bStart, bool bWait/* = false*/)
+{
+  bool ret = false;
+  switch(eServer)
+  {
+    case ES_WEBSERVER:
+      // the callback will take care of starting/stopping webserver
+      ret = CSettings::Get().SetBool("services.webserver", bStart);
+      break;
+
+    case ES_AIRPLAYSERVER:
+      // the callback will take care of starting/stopping airplay
+      ret = CSettings::Get().SetBool("services.airplay", bStart);
+      break;
+
+    case ES_JSONRPCSERVER:
+      // the callback will take care of starting/stopping jsonrpc server
+      ret = CSettings::Get().SetBool("services.esenabled", bStart);
+      break;
+
+    case ES_UPNPSERVER:
+      // the callback will take care of starting/stopping upnp server
+      ret = CSettings::Get().SetBool("services.upnpserver", bStart);
+      break;
+
+    case ES_UPNPRENDERER:
+      // the callback will take care of starting/stopping upnp renderer
+      ret = CSettings::Get().SetBool("services.upnprenderer", bStart);
+      break;
+
+    case ES_EVENTSERVER:
+      // the callback will take care of starting/stopping event server
+      ret = CSettings::Get().SetBool("services.esenabled", bStart);
+      break;
+
+    case ES_ZEROCONF:
+      // the callback will take care of starting/stopping zeroconf
+      ret = CSettings::Get().SetBool("services.zeroconf", bStart);
+      break;
+
+    default:
+      ret = false;
+      break;
+  }
+  CSettings::Get().Save();
+
+  return ret;
+}
+
+void CApplication::StartPVRManager()
+{
+  if (!CSettings::Get().GetBool("pvrmanager.enabled"))
+    return;
+
+  g_PVRManager.Start(true);
+}
+
+void CApplication::StopPVRManager()
+{
+  CLog::Log(LOGINFO, "stopping PVRManager");
+  if (g_PVRManager.IsPlaying())
+    StopPlaying();
+  g_PVRManager.Stop();
+  g_EpgContainer.Stop();
+}
+
+void CApplication::StartServices()
+{
+#if !defined(TARGET_WINDOWS) && defined(HAS_DVD_DRIVE)
+  // Start Thread for DVD Mediatype detection
+  CLog::Log(LOGNOTICE, "start dvd mediatype detection");
+  m_DetectDVDType.Create(false, THREAD_MINSTACKSIZE);
+#endif
+}
+
+void CApplication::StopServices()
+{
+  m_network->NetworkMessage(CNetwork::SERVICES_DOWN, 0);
+
+#if !defined(TARGET_WINDOWS) && defined(HAS_DVD_DRIVE)
+  CLog::Log(LOGNOTICE, "stop dvd detect media");
+  m_DetectDVDType.StopThread();
+#endif
+
+  g_peripherals.Clear();
+}
+
+void CApplication::OnSettingChanged(const CSetting *setting)
+{
+  if (setting == NULL)
+    return;
+
+  const std::string &settingId = setting->GetId();
+  if (settingId == "lookandfeel.skin" ||
+      settingId == "lookandfeel.font" ||
+      settingId == "lookandfeel.skincolors")
+  {
+    // if the skin changes and the current theme is not the default one, reset
+    // the theme to the default value (which will also change lookandfeel.skincolors
+    // which in turn will reload the skin.  Similarly, if the current skin font is not
+    // the default, reset it as well.
+    if (settingId == "lookandfeel.skin" && CSettings::Get().GetString("lookandfeel.skintheme") != "SKINDEFAULT")
+    {
+      CSettings::Get().SetString("lookandfeel.skintheme", "SKINDEFAULT");
+      return;
+    }
+    if (settingId == "lookandfeel.skin" && CSettings::Get().GetString("lookandfeel.font") != "Default")
+    {
+      CSettings::Get().SetString("lookandfeel.font", "Default");
+      return;
+    }
+
+    // Reset sounds setting if new skin doen't provide sounds
+    if (settingId == "lookandfeel.skin" && CSettings::Get().GetString("lookandfeel.soundskin") == "SKINDEFAULT")
+    {
+      ADDON::AddonPtr addon;
+      if (CAddonMgr::Get().GetAddon(((CSettingString*)setting)->GetValue(), addon, ADDON_SKIN))
+      {
+        if (!CDirectory::Exists(URIUtils::AddFileToFolder(addon->Path(), "sounds")))
+          CSettings::Get().GetSetting("lookandfeel.soundskin")->Reset();
+      }
+    }
+
+    std::string builtin("ReloadSkin");
+    if (settingId == "lookandfeel.skin" && !m_skinReverting)
+      builtin += "(confirm)";
+    CApplicationMessenger::Get().ExecBuiltIn(builtin);
+  }
+  else if (settingId == "lookandfeel.skintheme")
+  {
+    // also set the default color theme
+    std::string colorTheme = ((CSettingString*)setting)->GetValue();
+    URIUtils::RemoveExtension(colorTheme);
+    if (StringUtils::EqualsNoCase(colorTheme, "Textures"))
+      colorTheme = "defaults";
+
+    // check if we have to change the skin color
+    // if yes, it will trigger a call to ReloadSkin() in
+    // it's OnSettingChanged() callback
+    // if no we have to call ReloadSkin() ourselves
+    if (!StringUtils::EqualsNoCase(colorTheme, CSettings::Get().GetString("lookandfeel.skincolors")))
+      CSettings::Get().SetString("lookandfeel.skincolors", colorTheme);
+    else
+      CApplicationMessenger::Get().ExecBuiltIn("ReloadSkin");
+  }
+  else if (settingId == "lookandfeel.skinzoom")
+  {
+    CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_WINDOW_RESIZE);
+    g_windowManager.SendThreadMessage(msg);
+  }
+  else if (StringUtils::StartsWithNoCase(settingId, "audiooutput."))
+  {
+    // AE is master of audio settings and needs to be informed first
+    CAEFactory::OnSettingsChange(settingId);
+
+    if (settingId == "audiooutput.guisoundmode")
+    {
+      CAEFactory::SetSoundMode(((CSettingInt*)setting)->GetValue());
+    }
+    // this tells player whether to open an audio stream passthrough or PCM
+    // if this is changed, audio stream has to be reopened
+    else if (settingId == "audiooutput.passthrough")
+    {
+      CApplicationMessenger::Get().MediaRestart(false);
+    }
+  }
+  else if (StringUtils::EqualsNoCase(settingId, "musicplayer.replaygaintype"))
+    m_replayGainSettings.iType = ((CSettingInt*)setting)->GetValue();
+  else if (StringUtils::EqualsNoCase(settingId, "musicplayer.replaygainpreamp"))
+    m_replayGainSettings.iPreAmp = ((CSettingInt*)setting)->GetValue();
+  else if (StringUtils::EqualsNoCase(settingId, "musicplayer.replaygainnogainpreamp"))
+    m_replayGainSettings.iNoGainPreAmp = ((CSettingInt*)setting)->GetValue();
+  else if (StringUtils::EqualsNoCase(settingId, "musicplayer.replaygainavoidclipping"))
+    m_replayGainSettings.bAvoidClipping = ((CSettingBool*)setting)->GetValue();
+}
+
+void CApplication::OnSettingAction(const CSetting *setting)
+{
+  if (setting == NULL)
+    return;
+
+  const std::string &settingId = setting->GetId();
+  if (settingId == "lookandfeel.skinsettings")
+    g_windowManager.ActivateWindow(WINDOW_SKIN_SETTINGS);
+  else if (settingId == "screensaver.preview")
+    ActivateScreenSaver(true);
+  else if (settingId == "screensaver.settings")
+  {
+    AddonPtr addon;
+    if (CAddonMgr::Get().GetAddon(CSettings::Get().GetString("screensaver.mode"), addon, ADDON_SCREENSAVER))
+      CGUIDialogAddonSettings::ShowAndGetInput(addon);
+  }
+  else if (settingId == "audiocds.settings")
+  {
+    AddonPtr addon;
+    if (CAddonMgr::Get().GetAddon(CSettings::Get().GetString("audiocds.encoder"), addon, ADDON_AUDIOENCODER))
+      CGUIDialogAddonSettings::ShowAndGetInput(addon);
+  }
+  else if (settingId == "videoscreen.guicalibration")
+    g_windowManager.ActivateWindow(WINDOW_SCREEN_CALIBRATION);
+  else if (settingId == "videoscreen.testpattern")
+    g_windowManager.ActivateWindow(WINDOW_TEST_PATTERN);
+}
+
+bool CApplication::OnSettingUpdate(CSetting* &setting, const char *oldSettingId, const TiXmlNode *oldSettingNode)
+{
+  if (setting == NULL)
+    return false;
+
+  const std::string &settingId = setting->GetId();
+#if defined(HAS_LIBAMCODEC)
+  if (settingId == "videoplayer.useamcodec")
+  {
+    // Do not permit amcodec to be used on non-aml platforms.
+    // The setting will be hidden but the default value is true,
+    // so change it to false.
+    if (!aml_present())
+    {
+      CSettingBool *useamcodec = (CSettingBool*)setting;
+      return useamcodec->SetValue(false);
+    }
+  }
+#endif
+#if defined(TARGET_ANDROID)
+  if (settingId == "videoplayer.usestagefright")
+  {
+    CSettingBool *usestagefright = (CSettingBool*)setting;
+    return usestagefright->SetValue(false);
+  }
+#endif
+#if defined(TARGET_DARWIN_OSX)
+  if (settingId == "audiooutput.audiodevice")
+  {
+    CSettingString *audioDevice = (CSettingString*)setting;
+    // Gotham and older didn't enumerate audio devices per stream on osx
+    // add stream0 per default which should be ok for all old settings.
+    if (!StringUtils::EqualsNoCase(audioDevice->GetValue(), "DARWINOSX:default") && 
+        StringUtils::FindWords(audioDevice->GetValue().c_str(), ":stream") == std::string::npos)
+    {
+      std::string newSetting = audioDevice->GetValue();
+      newSetting += ":stream0";
+      return audioDevice->SetValue(newSetting);
+    }
+  }
+#endif
+
+  return false;
+}
+
+bool CApplication::OnSettingsSaving() const
+{
+  // don't save settings when we're busy stopping the application
+  // a lot of screens try to save settings on deinit and deinit is
+  // called for every screen when the application is stopping
+  if (m_bStop)
+    return false;
+
+  return true;
+}
+
+void CApplication::ReloadSkin(bool confirm/*=false*/)
+{
+  std::string oldSkin = g_SkinInfo ? g_SkinInfo->ID() : "";
+
+  CGUIMessage msg(GUI_MSG_LOAD_SKIN, -1, g_windowManager.GetActiveWindow());
+  g_windowManager.SendMessage(msg);
+
+  string newSkin = CSettings::Get().GetString("lookandfeel.skin");
+  if (LoadSkin(newSkin))
+  {
+    /* The Reset() or SetString() below will cause recursion, so the m_skinReverting boolean is set so as to not prompt the
+       user as to whether they want to keep the current skin. */
+    if (confirm && !m_skinReverting)
+    {
+      bool cancelled;
+      if (!CGUIDialogYesNo::ShowAndGetInput(13123, 13111, cancelled, "", "", 10000))
+      {
+        m_skinReverting = true;
+        if (oldSkin.empty())
+          CSettings::Get().GetSetting("lookandfeel.skin")->Reset();
+        else
+          CSettings::Get().SetString("lookandfeel.skin", oldSkin);
+      }
+    }
+  }
+  else
+  {
+    // skin failed to load - we revert to the default only if we didn't fail loading the default
+    string defaultSkin = ((CSettingString*)CSettings::Get().GetSetting("lookandfeel.skin"))->GetDefault();
+    if (newSkin != defaultSkin)
+    {
+      m_skinReverting = true;
+      CSettings::Get().GetSetting("lookandfeel.skin")->Reset();
+      CGUIDialogKaiToast::QueueNotification(CGUIDialogKaiToast::Error, g_localizeStrings.Get(24102), g_localizeStrings.Get(24103));
+    }
+  }
+  m_skinReverting = false;
+}
+
+bool CApplication::Load(const TiXmlNode *settings)
+{
+  if (settings == NULL)
+    return false;
+
+  const TiXmlElement *audioElement = settings->FirstChildElement("audio");
+  if (audioElement != NULL)
+  {
+#ifndef TARGET_ANDROID
+    XMLUtils::GetBoolean(audioElement, "mute", m_muted);
+    if (!XMLUtils::GetFloat(audioElement, "fvolumelevel", m_volumeLevel, VOLUME_MINIMUM, VOLUME_MAXIMUM))
+      m_volumeLevel = VOLUME_MAXIMUM;
+#else
+    // Use system volume settings
+    m_volumeLevel = CXBMCApp::GetSystemVolume();
+    m_muted = (m_volumeLevel == 0);
+#endif
+  }
+
+  return true;
+}
+
+bool CApplication::Save(TiXmlNode *settings) const
+{
+  if (settings == NULL)
+    return false;
+
+  TiXmlElement volumeNode("audio");
+  TiXmlNode *audioNode = settings->InsertEndChild(volumeNode);
+  if (audioNode == NULL)
+    return false;
+
+  XMLUtils::SetBoolean(audioNode, "mute", m_muted);
+  XMLUtils::SetFloat(audioNode, "fvolumelevel", m_volumeLevel);
+
+  return true;
+}
+
+bool CApplication::LoadSkin(const std::string& skinID)
+{
+  AddonPtr addon;
+  if (CAddonMgr::Get().GetAddon(skinID, addon, ADDON_SKIN))
+  {
+    if (LoadSkin(std::dynamic_pointer_cast<ADDON::CSkinInfo>(addon)))
+      return true;
+  }
+  CLog::Log(LOGERROR, "failed to load requested skin '%s'", skinID.c_str());
+  return false;
+}
+
+bool CApplication::LoadSkin(const SkinPtr& skin)
+{
+  if (!skin)
+    return false;
+
+  skin->Start();
+  if (!skin->HasSkinFile("Home.xml"))
+    return false;
+
+  bool bPreviousPlayingState=false;
+  bool bPreviousRenderingState=false;
+  if (g_application.m_pPlayer->IsPlayingVideo())
+  {
+    bPreviousPlayingState = !g_application.m_pPlayer->IsPausedPlayback();
+    if (bPreviousPlayingState)
+      g_application.m_pPlayer->Pause();
+#ifdef HAS_VIDEO_PLAYBACK
+    if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+    {
+      g_windowManager.ActivateWindow(WINDOW_HOME);
+      bPreviousRenderingState = true;
+    }
+#endif
+  }
+  // close the music and video overlays (they're re-opened automatically later)
+  CSingleLock lock(g_graphicsContext);
+
+  // save the current window details and focused control
+  int currentWindow = g_windowManager.GetActiveWindow();
+  int iCtrlID = -1;
+  CGUIWindow* pWindow = g_windowManager.GetWindow(currentWindow);
+  if (pWindow)
+    iCtrlID = pWindow->GetFocusedControlID();
+  vector<int> currentModelessWindows;
+  g_windowManager.GetActiveModelessWindows(currentModelessWindows);
+
+  UnloadSkin();
+
+  CLog::Log(LOGINFO, "  load skin from: %s (version: %s)", skin->Path().c_str(), skin->Version().asString().c_str());
+  g_SkinInfo = skin;
+  g_SkinInfo->Start();
+
+  CLog::Log(LOGINFO, "  load fonts for skin...");
+  g_graphicsContext.SetMediaDir(skin->Path());
+  g_directoryCache.ClearSubPaths(skin->Path());
+
+  g_colorManager.Load(CSettings::Get().GetString("lookandfeel.skincolors"));
+
+  g_fontManager.LoadFonts(CSettings::Get().GetString("lookandfeel.font"));
+
+  // load in the skin strings
+  std::string langPath = URIUtils::AddFileToFolder(skin->Path(), "language");
+  URIUtils::AddSlashAtEnd(langPath);
+
+  g_localizeStrings.LoadSkinStrings(langPath, CSettings::Get().GetString("locale.language"));
+
+  g_SkinInfo->LoadIncludes();
+
+  int64_t start;
+  start = CurrentHostCounter();
+
+  CLog::Log(LOGINFO, "  load new skin...");
+
+  // Load the user windows
+  LoadUserWindows();
+
+  int64_t end, freq;
+  end = CurrentHostCounter();
+  freq = CurrentHostFrequency();
+  CLog::Log(LOGDEBUG,"Load Skin XML: %.2fms", 1000.f * (end - start) / freq);
+
+  CLog::Log(LOGINFO, "  initialize new skin...");
+  g_windowManager.AddMsgTarget(this);
+  g_windowManager.AddMsgTarget(&g_playlistPlayer);
+  g_windowManager.AddMsgTarget(&g_infoManager);
+  g_windowManager.AddMsgTarget(&g_fontManager);
+  g_windowManager.AddMsgTarget(&CStereoscopicsManager::Get());
+  g_windowManager.SetCallback(*this);
+  g_windowManager.Initialize();
+  CTextureCache::Get().Initialize();
+  g_audioManager.Enable(true);
+  g_audioManager.Load();
+
+  if (g_SkinInfo->HasSkinFile("DialogFullScreenInfo.xml"))
+    g_windowManager.Add(new CGUIDialogFullScreenInfo);
+
+  { // we can't register visible condition in dialog's ctor because infomanager is cleared when unloading skin
+    CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OVERLAY);
+    if (overlay) overlay->SetVisibleCondition("skin.hasvideooverlay");
+    overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_OVERLAY);
+    if (overlay) overlay->SetVisibleCondition("skin.hasmusicoverlay");
+  }
+
+  CLog::Log(LOGINFO, "  skin loaded...");
+
+  // leave the graphics lock
+  lock.Leave();
+
+  // restore windows
+  if (currentWindow != WINDOW_INVALID)
+  {
+    g_windowManager.ActivateWindow(currentWindow);
+    for (unsigned int i = 0; i < currentModelessWindows.size(); i++)
+    {
+      CGUIDialog *dialog = (CGUIDialog *)g_windowManager.GetWindow(currentModelessWindows[i]);
+      if (dialog) dialog->Show();
+    }
+    if (iCtrlID != -1)
+    {
+      pWindow = g_windowManager.GetWindow(currentWindow);
+      if (pWindow && pWindow->HasSaveLastControl())
+      {
+        CGUIMessage msg(GUI_MSG_SETFOCUS, currentWindow, iCtrlID, 0);
+        pWindow->OnMessage(msg);
+      }
+    }
+  }
+
+  if (g_application.m_pPlayer->IsPlayingVideo())
+  {
+    if (bPreviousPlayingState)
+      g_application.m_pPlayer->Pause();
+    if (bPreviousRenderingState)
+      g_windowManager.ActivateWindow(WINDOW_FULLSCREEN_VIDEO);
+  }
+  return true;
+}
+
+void CApplication::UnloadSkin(bool forReload /* = false */)
+{
+  CLog::Log(LOGINFO, "Unloading old skin %s...", forReload ? "for reload " : "");
+
+  g_audioManager.Enable(false);
+
+  g_windowManager.DeInitialize();
+  CTextureCache::Get().Deinitialize();
+
+  // remove the skin-dependent window
+  g_windowManager.Delete(WINDOW_DIALOG_FULLSCREEN_INFO);
+
+  g_TextureManager.Cleanup();
+  g_largeTextureManager.CleanupUnusedImages(true);
+
+  g_fontManager.Clear();
+
+  g_colorManager.Clear();
+
+  g_infoManager.Clear();
+
+//  The g_SkinInfo shared_ptr ought to be reset here
+// but there are too many places it's used without checking for NULL
+// and as a result a race condition on exit can cause a crash.
+}
+
+bool CApplication::LoadUserWindows()
+{
+  // Start from wherever home.xml is
+  std::vector<std::string> vecSkinPath;
+  g_SkinInfo->GetSkinPaths(vecSkinPath);
+  for (unsigned int i = 0;i < vecSkinPath.size();++i)
+  {
+    CLog::Log(LOGINFO, "Loading user windows, path %s", vecSkinPath[i].c_str());
+    CFileItemList items;
+    if (CDirectory::GetDirectory(vecSkinPath[i], items, ".xml", DIR_FLAG_NO_FILE_DIRS))
+    {
+      for (int i = 0; i < items.Size(); ++i)
+      {
+        if (items[i]->m_bIsFolder)
+          continue;
+        std::string skinFile = URIUtils::GetFileName(items[i]->GetPath());
+        if (StringUtils::StartsWithNoCase(skinFile, "custom"))
+        {
+          CXBMCTinyXML xmlDoc;
+          if (!xmlDoc.LoadFile(items[i]->GetPath()))
+          {
+            CLog::Log(LOGERROR, "unable to load: %s, Line %d\n%s", items[i]->GetPath().c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+            continue;
+          }
+
+          // Root element should be <window>
+          TiXmlElement* pRootElement = xmlDoc.RootElement();
+          std::string strValue = pRootElement->Value();
+          if (!StringUtils::EqualsNoCase(strValue, "window"))
+          {
+            CLog::Log(LOGERROR, "file: %s doesnt contain <window>", skinFile.c_str());
+            continue;
+          }
+
+          // Read the <type> element to get the window type to create
+          // If no type is specified, create a CGUIWindow as default
+          CGUIWindow* pWindow = NULL;
+          std::string strType;
+          if (pRootElement->Attribute("type"))
+            strType = pRootElement->Attribute("type");
+          else
+          {
+            const TiXmlNode *pType = pRootElement->FirstChild("type");
+            if (pType && pType->FirstChild())
+              strType = pType->FirstChild()->Value();
+          }
+          int id = WINDOW_INVALID;
+          if (!pRootElement->Attribute("id", &id))
+          {
+            const TiXmlNode *pType = pRootElement->FirstChild("id");
+            if (pType && pType->FirstChild())
+              id = atol(pType->FirstChild()->Value());
+          }
+          std::string visibleCondition;
+          CGUIControlFactory::GetConditionalVisibility(pRootElement, visibleCondition);
+
+          if (StringUtils::EqualsNoCase(strType, "dialog"))
+            pWindow = new CGUIDialog(id + WINDOW_HOME, skinFile);
+          else if (StringUtils::EqualsNoCase(strType, "submenu"))
+            pWindow = new CGUIDialogSubMenu(id + WINDOW_HOME, skinFile);
+          else if (StringUtils::EqualsNoCase(strType, "buttonmenu"))
+            pWindow = new CGUIDialogButtonMenu(id + WINDOW_HOME, skinFile);
+          else
+            pWindow = new CGUIWindow(id + WINDOW_HOME, skinFile);
+
+          // Check to make sure the pointer isn't still null
+          if (pWindow == NULL)
+          {
+            CLog::Log(LOGERROR, "Out of memory / Failed to create new object in LoadUserWindows");
+            return false;
+          }
+          if (id == WINDOW_INVALID || g_windowManager.GetWindow(WINDOW_HOME + id))
+          {
+            delete pWindow;
+            continue;
+          }
+          pWindow->SetVisibleCondition(visibleCondition);
+          pWindow->SetLoadType(CGUIWindow::KEEP_IN_MEMORY);
+          g_windowManager.AddCustomWindow(pWindow);
+        }
+      }
+    }
+  }
+  return true;
+}
+
+bool CApplication::RenderNoPresent()
+{
+  MEASURE_FUNCTION;
+
+// DXMERGE: This may have been important?
+//  g_graphicsContext.AcquireCurrentContext();
+
+  g_graphicsContext.Lock();
+
+  // dont show GUI when playing full screen video
+  if (g_graphicsContext.IsFullScreenVideo())
+  {
+    // close window overlays
+    CGUIDialog *overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_OVERLAY);
+    if (overlay) overlay->Close(true);
+    overlay = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_MUSIC_OVERLAY);
+    if (overlay) overlay->Close(true);
+
+  }
+
+  bool hasRendered = g_windowManager.Render();
+
+  g_graphicsContext.Unlock();
+
+  return hasRendered;
+}
+
+float CApplication::GetDimScreenSaverLevel() const
+{
+  if (!m_bScreenSave || !m_screenSaver ||
+      (m_screenSaver->ID() != "screensaver.xbmc.builtin.dim" &&
+       m_screenSaver->ID() != "screensaver.xbmc.builtin.black" &&
+       !m_screenSaver->ID().empty()))
+    return 0;
+
+  if (!m_screenSaver->GetSetting("level").empty())
+    return 100.0f - (float)atof(m_screenSaver->GetSetting("level").c_str());
+  return 100.0f;
+}
+
+void CApplication::Render()
+{
+  // do not render if we are stopped or in background
+  if (m_bStop)
+    return;
+
+  MEASURE_FUNCTION;
+
+  int vsync_mode = CSettings::Get().GetInt("videoscreen.vsync");
+
+  bool hasRendered = false;
+  bool limitFrames = false;
+  unsigned int singleFrameTime = 10; // default limit 100 fps
+  bool vsync = true;
+
+  // Whether externalplayer is playing and we're unfocused
+  bool extPlayerActive = m_pPlayer->GetCurrentPlayer() == EPC_EXTPLAYER && m_pPlayer->IsPlaying() && !m_AppFocused;
+
+  {
+    // Less fps in DPMS
+    bool lowfps = g_Windowing.EnableFrameLimiter();
+
+    m_bPresentFrame = false;
+    if (!extPlayerActive && g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback())
+    {
+      m_bPresentFrame = g_renderManager.HasFrame();
+      if (vsync_mode == VSYNC_DISABLED)
+        vsync = false;
+    }
+    else
+    {
+      // engage the frame limiter as needed
+      limitFrames = lowfps || extPlayerActive;
+      // DXMERGE - we checked for g_videoConfig.GetVSyncMode() before this
+      //           perhaps allowing it to be set differently than the UI option??
+      if (vsync_mode == VSYNC_DISABLED || vsync_mode == VSYNC_VIDEO)
+      {
+        limitFrames = true; // not using vsync.
+        vsync = false;
+      }
+      else if ((g_infoManager.GetFPS() > g_graphicsContext.GetFPS() + 10) && g_infoManager.GetFPS() > 1000 / singleFrameTime)
+      {
+        limitFrames = true; // using vsync, but it isn't working.
+        vsync = false;
+      }
+
+      if (limitFrames)
+      {
+        if (extPlayerActive)
+        {
+          ResetScreenSaver();  // Prevent screensaver dimming the screen
+          singleFrameTime = 1000;  // 1 fps, high wakeup latency but v.low CPU usage
+        }
+        else if (lowfps)
+          singleFrameTime = 200;  // 5 fps, <=200 ms latency to wake up
+      }
+
+    }
+  }
+
+  CSingleLock lock(g_graphicsContext);
+
+  if (g_graphicsContext.IsFullScreenVideo() && m_pPlayer->IsPlaying() && vsync_mode == VSYNC_VIDEO)
+    g_Windowing.SetVSync(true);
+  else if (vsync_mode == VSYNC_ALWAYS)
+    g_Windowing.SetVSync(true);
+  else if (vsync_mode != VSYNC_DRIVER)
+    g_Windowing.SetVSync(false);
+
+  if (m_bPresentFrame && m_pPlayer->IsPlaying() && !m_pPlayer->IsPaused())
+    ResetScreenSaver();
+
+  if(!g_Windowing.BeginRender())
+    return;
+
+  CDirtyRegionList dirtyRegions;
+
+  // render gui layer
+  if (!m_skipGuiRender)
+  {
+    dirtyRegions = g_windowManager.GetDirty();
+    if (g_graphicsContext.GetStereoMode())
+    {
+      g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
+      if (RenderNoPresent())
+        hasRendered = true;
+
+      if (g_graphicsContext.GetStereoMode() != RENDER_STEREO_MODE_MONO)
+      {
+        g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_RIGHT);
+        if (RenderNoPresent())
+          hasRendered = true;
+      }
+      g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
+    }
+    else
+    {
+      if (RenderNoPresent())
+        hasRendered = true;
+    }
+    // execute post rendering actions (finalize window closing)
+    g_windowManager.AfterRender();
+  }
+
+  // render video layer
+  g_windowManager.RenderEx();
+
+  g_Windowing.EndRender();
+
+  // reset our info cache - we do this at the end of Render so that it is
+  // fresh for the next process(), or after a windowclose animation (where process()
+  // isn't called)
+  g_infoManager.ResetCache();
+
+
+  unsigned int now = XbmcThreads::SystemClockMillis();
+  if (hasRendered)
+  {
+    g_infoManager.UpdateFPS();
+    m_lastRenderTime = now;
+  }
+
+  lock.Leave();
+
+  //when nothing has been rendered for m_guiDirtyRegionNoFlipTimeout milliseconds,
+  //we don't call g_graphicsContext.Flip() anymore, this saves gpu and cpu usage
+  bool flip;
+  if (g_advancedSettings.m_guiDirtyRegionNoFlipTimeout >= 0)
+    flip = hasRendered || (now - m_lastRenderTime) < (unsigned int)g_advancedSettings.m_guiDirtyRegionNoFlipTimeout;
+  else
+    flip = true;
+
+  //fps limiter, make sure each frame lasts at least singleFrameTime milliseconds
+  if (limitFrames || !(flip || m_bPresentFrame))
+  {
+    if (!limitFrames)
+      singleFrameTime = 40; //if not flipping, loop at 25 fps
+
+    unsigned int frameTime = now - m_lastFrameTime;
+    if (frameTime < singleFrameTime)
+      Sleep(singleFrameTime - frameTime);
+  }
+
+  if (flip)
+    g_graphicsContext.Flip(dirtyRegions);
+
+  if (!extPlayerActive && g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback())
+  {
+    g_renderManager.FrameWait(100);
+  }
+
+  m_lastFrameTime = XbmcThreads::SystemClockMillis();
+  CTimeUtils::UpdateFrameTime(flip, vsync);
+
+  g_renderManager.UpdateResolution();
+  g_renderManager.ManageCaptures();
+}
+
+void CApplication::SetStandAlone(bool value)
+{
+  g_advancedSettings.m_handleMounting = m_bStandalone = value;
+}
+
+
+// OnAppCommand is called in response to a XBMC_APPCOMMAND event.
+// This needs to return true if it processed the appcommand or false if it didn't
+bool CApplication::OnAppCommand(const CAction &action)
+{
+  // Reset the screen saver
+  ResetScreenSaver();
+
+  // If we were currently in the screen saver wake up and don't process the appcommand
+  if (WakeUpScreenSaverAndDPMS())
+    return true;
+
+  // The action ID is the APPCOMMAND code. We need to retrieve the action
+  // associated with this appcommand from the mapping table.
+  uint32_t appcmd = action.GetID();
+  CKey key(appcmd | KEY_APPCOMMAND, (unsigned int) 0);
+  int iWin = g_windowManager.GetActiveWindow() & WINDOW_ID_MASK;
+  CAction appcmdaction = CButtonTranslator::GetInstance().GetAction(iWin, key);
+
+  // If we couldn't find an action return false to indicate we have not
+  // handled this appcommand
+  if (!appcmdaction.GetID())
+  {
+    CLog::LogF(LOGDEBUG, "unknown appcommand %d", appcmd);
+    return false;
+  }
+
+  // Process the appcommand
+  CLog::LogF(LOGDEBUG, "appcommand %d, trying action %s", appcmd, appcmdaction.GetName().c_str());
+  OnAction(appcmdaction);
+
+  // Always return true regardless of whether the action succeeded or not.
+  // This stops Windows handling the appcommand itself.
+  return true;
+}
+
+bool CApplication::OnAction(const CAction &action)
+{
+  // special case for switching between GUI & fullscreen mode.
+  if (action.GetID() == ACTION_SHOW_GUI)
+  { // Switch to fullscreen mode if we can
+    if (SwitchToFullScreen())
+    {
+      m_navigationTimer.StartZero();
+      return true;
+    }
+  }
+
+  if (action.GetID() == ACTION_TOGGLE_FULLSCREEN)
+  {
+    g_graphicsContext.ToggleFullScreenRoot();
+    return true;
+  }
+
+  if (action.IsMouse())
+    CInputManager::Get().SetMouseActive(true);
+
+  
+  if (action.GetID() == ACTION_CREATE_EPISODE_BOOKMARK)   
+  {
+    CGUIDialogVideoBookmarks::OnAddEpisodeBookmark();
+  }
+  if (action.GetID() == ACTION_CREATE_BOOKMARK)
+  {
+    CGUIDialogVideoBookmarks::OnAddBookmark();
+  }
+  
+  // The action PLAYPAUSE behaves as ACTION_PAUSE if we are currently
+  // playing or ACTION_PLAYER_PLAY if we are seeking (FF/RW) or not playing.
+  if (action.GetID() == ACTION_PLAYER_PLAYPAUSE)
+  {
+    if (m_pPlayer->IsPlaying() && m_pPlayer->GetPlaySpeed() == 1)
+      return OnAction(CAction(ACTION_PAUSE));
+    else
+      return OnAction(CAction(ACTION_PLAYER_PLAY));
+  }
+
+  //if the action would start or stop inertial scrolling
+  //by gesture - bypass the normal OnAction handler of current window
+  if( !m_pInertialScrollingHandler->CheckForInertialScrolling(&action) )
+  {
+    // in normal case
+    // just pass the action to the current window and let it handle it
+    if (g_windowManager.OnAction(action))
+    {
+      m_navigationTimer.StartZero();
+      return true;
+    }
+  }
+
+  // handle extra global presses
+
+  // notify action listeners
+  if (NotifyActionListeners(action))
+    return true;
+  
+  // screenshot : take a screenshot :)
+  if (action.GetID() == ACTION_TAKE_SCREENSHOT)
+  {
+    CScreenShot::TakeScreenshot();
+    return true;
+  }
+  // built in functions : execute the built-in
+  if (action.GetID() == ACTION_BUILT_IN_FUNCTION)
+  {
+    if (!CBuiltins::IsSystemPowerdownCommand(action.GetName()) ||
+        g_PVRManager.CanSystemPowerdown())
+    {
+      CBuiltins::Execute(action.GetName());
+      m_navigationTimer.StartZero();
+    }
+    return true;
+  }
+
+  // reload keymaps
+  if (action.GetID() == ACTION_RELOAD_KEYMAPS)
+  {
+    CButtonTranslator::GetInstance().Clear();
+    CButtonTranslator::GetInstance().Load();
+  }
+
+  // show info : Shows the current video or song information
+  if (action.GetID() == ACTION_SHOW_INFO)
+  {
+    g_infoManager.ToggleShowInfo();
+    return true;
+  }
+
+  // codec info : Shows the current song, video or picture codec information
+  if (action.GetID() == ACTION_SHOW_CODEC)
+  {
+    g_infoManager.ToggleShowCodec();
+    return true;
+  }
+
+  if ((action.GetID() == ACTION_INCREASE_RATING || action.GetID() == ACTION_DECREASE_RATING) && m_pPlayer->IsPlayingAudio())
+  {
+    const CMusicInfoTag *tag = g_infoManager.GetCurrentSongTag();
+    if (tag)
+    {
+      *m_itemCurrentFile->GetMusicInfoTag() = *tag;
+      char rating = tag->GetRating();
+      bool needsUpdate(false);
+      if (rating > '0' && action.GetID() == ACTION_DECREASE_RATING)
+      {
+        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating - 1);
+        needsUpdate = true;
+      }
+      else if (rating < '5' && action.GetID() == ACTION_INCREASE_RATING)
+      {
+        m_itemCurrentFile->GetMusicInfoTag()->SetRating(rating + 1);
+        needsUpdate = true;
+      }
+      if (needsUpdate)
+      {
+        CMusicDatabase db;
+        if (db.Open())      // OpenForWrite() ?
+        {
+          db.SetSongRating(m_itemCurrentFile->GetPath(), m_itemCurrentFile->GetMusicInfoTag()->GetRating());
+          db.Close();
+        }
+        // send a message to all windows to tell them to update the fileitem (eg playlistplayer, media windows)
+        CGUIMessage msg(GUI_MSG_NOTIFY_ALL, 0, 0, GUI_MSG_UPDATE_ITEM, 0, m_itemCurrentFile);
+        g_windowManager.SendMessage(msg);
+      }
+    }
+    return true;
+  }
+
+  // Now check with the playlist player if action can be handled.
+  // In case of the action PREV_ITEM, we only allow the playlist player to take it if we're less than 3 seconds into playback.
+  if (!(action.GetID() == ACTION_PREV_ITEM && m_pPlayer->CanSeek() && GetTime() > 3) )
+  {
+    if (g_playlistPlayer.OnAction(action))
+      return true;
+  }
+
+  // Now check with the player if action can be handled.
+  bool bIsPlayingPVRChannel = (g_PVRManager.IsStarted() && g_application.CurrentFileItem().IsPVRChannel());
+  if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO ||
+      (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION && bIsPlayingPVRChannel) ||
+      ((g_windowManager.GetActiveWindow() == WINDOW_DIALOG_VIDEO_OSD || (g_windowManager.GetActiveWindow() == WINDOW_DIALOG_MUSIC_OSD && bIsPlayingPVRChannel)) &&
+        (action.GetID() == ACTION_NEXT_ITEM || action.GetID() == ACTION_PREV_ITEM || action.GetID() == ACTION_CHANNEL_UP || action.GetID() == ACTION_CHANNEL_DOWN)) ||
+      action.GetID() == ACTION_STOP)
+  {
+    if (m_pPlayer->OnAction(action))
+      return true;
+    // Player ignored action; popup the OSD
+    if ((action.GetID() == ACTION_MOUSE_MOVE && (action.GetAmount(2) || action.GetAmount(3)))  // filter "false" mouse move from touch
+        || action.GetID() == ACTION_MOUSE_LEFT_CLICK)
+      CApplicationMessenger::Get().SendAction(CAction(ACTION_TRIGGER_OSD), WINDOW_INVALID, false);
+  }
+
+  // stop : stops playing current audio song
+  if (action.GetID() == ACTION_STOP)
+  {
+    StopPlaying();
+    return true;
+  }
+
+  // In case the playlist player nor the player didn't handle PREV_ITEM, because we are past the 3 secs limit.
+  // If so, we just jump to the start of the track.
+  if (action.GetID() == ACTION_PREV_ITEM && m_pPlayer->CanSeek())
+  {
+    SeekTime(0);
+    m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+    return true;
+  }
+
+  // forward action to graphic context and see if it can handle it
+  if (CStereoscopicsManager::Get().OnAction(action))
+    return true;
+
+  if (m_pPlayer->IsPlaying())
+  {
+    // forward channel switches to the player - he knows what to do
+    if (action.GetID() == ACTION_CHANNEL_UP || action.GetID() == ACTION_CHANNEL_DOWN)
+    {
+      m_pPlayer->OnAction(action);
+      return true;
+    }
+
+    // pause : toggle pause action
+    if (action.GetID() == ACTION_PAUSE)
+    {
+      m_pPlayer->Pause();
+      // go back to normal play speed on unpause
+      if (!m_pPlayer->IsPaused() && m_pPlayer->GetPlaySpeed() != 1)
+        m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+
+      #ifdef HAS_KARAOKE
+      m_pKaraokeMgr->SetPaused( m_pPlayer->IsPaused() );
+#endif
+      g_audioManager.Enable(m_pPlayer->IsPaused());
+      return true;
+    }
+    // play: unpause or set playspeed back to normal
+    if (action.GetID() == ACTION_PLAYER_PLAY)
+    {
+      // if currently paused - unpause
+      if (m_pPlayer->IsPaused())
+        return OnAction(CAction(ACTION_PAUSE));
+      // if we do a FF/RW then go back to normal speed
+      if (m_pPlayer->GetPlaySpeed() != 1)
+        m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+      return true;
+    }
+    if (!m_pPlayer->IsPaused())
+    {
+      if (action.GetID() == ACTION_PLAYER_FORWARD || action.GetID() == ACTION_PLAYER_REWIND)
+      {
+        int iPlaySpeed = m_pPlayer->GetPlaySpeed();
+        if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed == 1) // Enables Rewinding
+          iPlaySpeed *= -2;
+        else if (action.GetID() == ACTION_PLAYER_REWIND && iPlaySpeed > 1) //goes down a notch if you're FFing
+          iPlaySpeed /= 2;
+        else if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed < 1) //goes up a notch if you're RWing
+          iPlaySpeed /= 2;
+        else
+          iPlaySpeed *= 2;
+
+        if (action.GetID() == ACTION_PLAYER_FORWARD && iPlaySpeed == -1) //sets iSpeed back to 1 if -1 (didn't plan for a -1)
+          iPlaySpeed = 1;
+        if (iPlaySpeed > 32 || iPlaySpeed < -32)
+          iPlaySpeed = 1;
+
+        m_pPlayer->SetPlaySpeed(iPlaySpeed, g_application.m_muted);
+        return true;
+      }
+      else if ((action.GetAmount() || m_pPlayer->GetPlaySpeed() != 1) && (action.GetID() == ACTION_ANALOG_REWIND || action.GetID() == ACTION_ANALOG_FORWARD))
+      {
+        // calculate the speed based on the amount the button is held down
+        int iPower = (int)(action.GetAmount() * MAX_FFWD_SPEED + 0.5f);
+        // returns 0 -> MAX_FFWD_SPEED
+        int iSpeed = 1 << iPower;
+        if (iSpeed != 1 && action.GetID() == ACTION_ANALOG_REWIND)
+          iSpeed = -iSpeed;
+        g_application.m_pPlayer->SetPlaySpeed(iSpeed, g_application.m_muted);
+        if (iSpeed == 1)
+          CLog::Log(LOGDEBUG,"Resetting playspeed");
+        return true;
+      }
+    }
+    // allow play to unpause
+    else
+    {
+      if (action.GetID() == ACTION_PLAYER_PLAY)
+      {
+        // unpause, and set the playspeed back to normal
+        m_pPlayer->Pause();
+        g_audioManager.Enable(m_pPlayer->IsPaused());
+
+        g_application.m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+        return true;
+      }
+    }
+
+    // record current file
+    if (action.GetID() == ACTION_RECORD)
+    {
+      if (m_pPlayer->CanRecord())
+        m_pPlayer->Record(!m_pPlayer->IsRecording());
+    }
+
+    if (m_playerController->OnAction(action))
+      return true;
+  }
+
+
+  if (action.GetID() == ACTION_SWITCH_PLAYER)
+  {
+    if(m_pPlayer->IsPlaying())
+    {
+      VECPLAYERCORES cores;
+      CFileItem item(*m_itemCurrentFile.get());
+      CPlayerCoreFactory::Get().GetPlayers(item, cores);
+      PLAYERCOREID core = CPlayerCoreFactory::Get().SelectPlayerDialog(cores);
+      if(core != EPC_NONE)
+      {
+        g_application.m_eForcedNextPlayer = core;
+        item.m_lStartOffset = (int)(GetTime() * 75);
+        PlayFile(item, true);
+      }
+    }
+    else
+    {
+      VECPLAYERCORES cores;
+      CPlayerCoreFactory::Get().GetRemotePlayers(cores);
+      PLAYERCOREID core = CPlayerCoreFactory::Get().SelectPlayerDialog(cores);
+      if(core != EPC_NONE)
+      {
+        CFileItem item;
+        g_application.m_eForcedNextPlayer = core;
+        PlayFile(item, false);
+      }
+    }
+  }
+
+  if (g_peripherals.OnAction(action))
+    return true;
+
+  if (action.GetID() == ACTION_MUTE)
+  {
+    ToggleMute();
+    return true;
+  }
+
+  if (action.GetID() == ACTION_TOGGLE_DIGITAL_ANALOG)
+  {
+    bool passthrough = CSettings::Get().GetBool("audiooutput.passthrough");
+    CSettings::Get().SetBool("audiooutput.passthrough", !passthrough);
+
+    if (g_windowManager.GetActiveWindow() == WINDOW_SETTINGS_SYSTEM)
+    {
+      CGUIMessage msg(GUI_MSG_WINDOW_INIT, 0,0,WINDOW_INVALID,g_windowManager.GetActiveWindow());
+      g_windowManager.SendMessage(msg);
+    }
+    return true;
+  }
+
+  // Check for global volume control
+  if ((action.GetAmount() && (action.GetID() == ACTION_VOLUME_UP || action.GetID() == ACTION_VOLUME_DOWN) || action.GetID() == ACTION_VOLUME_SET))
+  {
+    if (!m_pPlayer->IsPassthrough())
+    {
+      if (m_muted)
+        UnMute();
+      float volume = m_volumeLevel;
+// Android has steps based on the max available volume level
+#if defined(TARGET_ANDROID)
+      float step = (VOLUME_MAXIMUM - VOLUME_MINIMUM) / CXBMCApp::GetMaxSystemVolume();
+#else
+      float step   = (VOLUME_MAXIMUM - VOLUME_MINIMUM) / VOLUME_CONTROL_STEPS;
+
+      if (action.GetRepeat())
+        step *= action.GetRepeat() * 50; // 50 fps
+#endif
+      if (action.GetID() == ACTION_VOLUME_UP)
+        volume += (float)(action.GetAmount() * action.GetAmount() * step);
+      else if (action.GetID() == ACTION_VOLUME_DOWN)
+        volume -= (float)(action.GetAmount() * action.GetAmount() * step);
+      else
+        volume = action.GetAmount() * step;
+      if (volume != m_volumeLevel)
+        SetVolume(volume, false);
+    }
+    // show visual feedback of volume or passthrough indicator
+    ShowVolumeBar(&action);
+    return true;
+  }
+  if (action.GetID() == ACTION_GUIPROFILE_BEGIN)
+  {
+    CGUIControlProfiler::Instance().SetOutputFile(CSpecialProtocol::TranslatePath("special://home/guiprofiler.xml"));
+    CGUIControlProfiler::Instance().Start();
+    return true;
+  }
+  if (action.GetID() == ACTION_SHOW_PLAYLIST)
+  {
+    int iPlaylist = g_playlistPlayer.GetCurrentPlaylist();
+    if (iPlaylist == PLAYLIST_VIDEO && g_windowManager.GetActiveWindow() != WINDOW_VIDEO_PLAYLIST)
+      g_windowManager.ActivateWindow(WINDOW_VIDEO_PLAYLIST);
+    else if (iPlaylist == PLAYLIST_MUSIC && g_windowManager.GetActiveWindow() != WINDOW_MUSIC_PLAYLIST)
+      g_windowManager.ActivateWindow(WINDOW_MUSIC_PLAYLIST);
+    return true;
+  }
+  return false;
+}
+
+void CApplication::FrameMove(bool processEvents, bool processGUI)
+{
+  MEASURE_FUNCTION;
+
+  if (processEvents)
+  {
+    // currently we calculate the repeat time (ie time from last similar keypress) just global as fps
+    float frameTime = m_frameTime.GetElapsedSeconds();
+    m_frameTime.StartZero();
+    // never set a frametime less than 2 fps to avoid problems when debuggin and on breaks
+    if( frameTime > 0.5 ) frameTime = 0.5;
+
+    if (processGUI && m_renderGUI)
+    {
+      g_graphicsContext.Lock();
+      // check if there are notifications to display
+      CGUIDialogKaiToast *toast = (CGUIDialogKaiToast *)g_windowManager.GetWindow(WINDOW_DIALOG_KAI_TOAST);
+      if (toast && toast->DoWork())
+      {
+        if (!toast->IsDialogRunning())
+        {
+          toast->Show();
+        }
+      }
+      g_graphicsContext.Unlock();
+    }
+    CWinEvents::MessagePump();
+
+    CInputManager::Get().Process(g_windowManager.GetActiveWindowID(), frameTime);
+
+    if (processGUI && m_renderGUI)
+    {
+      m_pInertialScrollingHandler->ProcessInertialScroll(frameTime);
+      CSeekHandler::Get().Process();
+    }
+  }
+  if (processGUI && m_renderGUI)
+  {
+    m_skipGuiRender = false;
+    int fps = 0;
+
+#if defined(TARGET_RASPBERRY_PI) || defined(HAS_IMXVPU)
+    // This code reduces rendering fps of the GUI layer when playing videos in fullscreen mode
+    // it makes only sense on architectures with multiple layers
+    if (g_graphicsContext.IsFullScreenVideo() && !m_pPlayer->IsPausedPlayback() && g_renderManager.IsVideoLayer())
+      fps = CSettings::Get().GetInt("videoplayer.limitguiupdate");
+#endif
+
+    unsigned int now = XbmcThreads::SystemClockMillis();
+    unsigned int frameTime = now - m_lastRenderTime;
+    if (fps > 0 && frameTime * fps < 1000)
+      m_skipGuiRender = true;
+
+    if (!m_bStop)
+    {
+      if (!m_skipGuiRender)
+        g_windowManager.Process(CTimeUtils::GetFrameTime());
+    }
+    g_windowManager.FrameMove();
+  }
+}
+
+
+
+bool CApplication::Cleanup()
+{
+  try
+  {
+    g_windowManager.DestroyWindows();
+
+    CAddonMgr::Get().DeInit();
+
+    CLog::Log(LOGNOTICE, "closing down remote control service");
+    CInputManager::Get().DisableRemoteControl();
+
+    CLog::Log(LOGNOTICE, "unload sections");
+
+#ifdef HAS_PERFORMANCE_SAMPLE
+    CLog::Log(LOGNOTICE, "performance statistics");
+    m_perfStats.DumpStats();
+#endif
+
+    //  Shutdown as much as possible of the
+    //  application, to reduce the leaks dumped
+    //  to the vc output window before calling
+    //  _CrtDumpMemoryLeaks(). Most of the leaks
+    //  shown are no real leaks, as parts of the app
+    //  are still allocated.
+
+    g_localizeStrings.Clear();
+    g_LangCodeExpander.Clear();
+    g_charsetConverter.clear();
+    g_directoryCache.Clear();
+    CButtonTranslator::GetInstance().Clear();
+#ifdef HAS_EVENT_SERVER
+    CEventServer::RemoveInstance();
+#endif
+    DllLoaderContainer::Clear();
+    g_playlistPlayer.Clear();
+    CSettings::Get().Uninitialize();
+    g_advancedSettings.Clear();
+
+#ifdef TARGET_POSIX
+    CXHandle::DumpObjectTracker();
+
+#ifdef HAS_DVD_DRIVE
+    CLibcdio::ReleaseInstance();
+#endif
+#endif 
+#if defined(TARGET_ANDROID)
+    // enable for all platforms once it's safe
+    g_sectionLoader.UnloadAll();
+#endif
+#ifdef _CRTDBG_MAP_ALLOC
+    _CrtDumpMemoryLeaks();
+    while(1); // execution ends
+#endif
+
+    delete m_network;
+    m_network = NULL;
+
+    return true;
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "Exception in CApplication::Cleanup()");
+    return false;
+  }
+}
+
+void CApplication::Stop(int exitCode)
+{
+  try
+  {
+    CVariant vExitCode(CVariant::VariantTypeObject);
+    vExitCode["exitcode"] = exitCode;
+    CAnnouncementManager::Get().Announce(System, "xbmc", "OnQuit", vExitCode);
+
+    // Abort any active screensaver
+    WakeUpScreenSaverAndDPMS();
+
+    SaveFileState(true);
+
+    g_alarmClock.StopThread();
+
+    if( m_bSystemScreenSaverEnable )
+      g_Windowing.EnableSystemScreenSaver(true);
+
+    CLog::Log(LOGNOTICE, "Storing total System Uptime");
+    g_sysinfo.SetTotalUptime(g_sysinfo.GetTotalUptime() + (int)(CTimeUtils::GetFrameTime() / 60000));
+
+    // Update the settings information (volume, uptime etc. need saving)
+    if (CFile::Exists(CProfilesManager::Get().GetSettingsFile()))
+    {
+      CLog::Log(LOGNOTICE, "Saving settings");
+      CSettings::Get().Save();
+    }
+    else
+      CLog::Log(LOGNOTICE, "Not saving settings (settings.xml is not present)");
+
+    m_bStop = true;
+    m_AppFocused = false;
+    m_ExitCode = exitCode;
+    CLog::Log(LOGNOTICE, "stop all");
+
+    // cancel any jobs from the jobmanager
+    CJobManager::GetInstance().CancelJobs();
+
+    // stop scanning before we kill the network and so on
+    if (m_musicInfoScanner->IsScanning())
+      m_musicInfoScanner->Stop();
+
+    if (CVideoLibraryQueue::Get().IsRunning())
+      CVideoLibraryQueue::Get().CancelAllJobs();
+
+    CApplicationMessenger::Get().Cleanup();
+
+    CLog::Log(LOGNOTICE, "stop player");
+    m_pPlayer->ClosePlayer();
+
+    CAnnouncementManager::Get().Deinitialize();
+
+    StopPVRManager();
+    StopServices();
+    //Sleep(5000);
+
+#ifdef HAS_FILESYSTEM_SAP
+    CLog::Log(LOGNOTICE, "stop sap announcement listener");
+    g_sapsessions.StopThread();
+#endif
+#ifdef HAS_ZEROCONF
+    if(CZeroconfBrowser::IsInstantiated())
+    {
+      CLog::Log(LOGNOTICE, "stop zeroconf browser");
+      CZeroconfBrowser::GetInstance()->Stop();
+      CZeroconfBrowser::ReleaseInstance();
+    }
+#endif
+
+    CLog::Log(LOGNOTICE, "clean cached files!");
+#ifdef HAS_FILESYSTEM_RAR
+    g_RarManager.ClearCache(true);
+#endif
+
+#ifdef HAS_FILESYSTEM_SFTP
+    CSFTPSessionManager::DisconnectAllSessions();
+#endif
+
+#if defined(TARGET_POSIX) && defined(HAS_FILESYSTEM_SMB)
+    smb.Deinit();
+#endif
+
+    CLog::Log(LOGNOTICE, "unload skin");
+    UnloadSkin();
+
+#if defined(TARGET_DARWIN_OSX)
+    if (XBMCHelper::GetInstance().IsAlwaysOn() == false)
+      XBMCHelper::GetInstance().Stop();
+#endif
+
+    g_mediaManager.Stop();
+
+    // Stop services before unloading Python
+    CAddonMgr::Get().StopServices(false);
+
+    // unregister action listeners
+    UnregisterActionListener(&CSeekHandler::Get());
+
+    // stop all remaining scripts; must be done after skin has been unloaded,
+    // not before some windows still need it when deinitializing during skin
+    // unloading
+    CScriptInvocationManager::Get().Uninitialize();
+
+    g_Windowing.DestroyRenderSystem();
+    g_Windowing.DestroyWindow();
+    g_Windowing.DestroyWindowSystem();
+
+    g_audioManager.DeInitialize();
+    // shutdown the AudioEngine
+    CAEFactory::Shutdown();
+    CAEFactory::UnLoadEngine();
+
+    // unregister ffmpeg lock manager call back
+    av_lockmgr_register(NULL);
+
+    CLog::Log(LOGNOTICE, "stopped");
+  }
+  catch (...)
+  {
+    CLog::Log(LOGERROR, "Exception in CApplication::Stop()");
+  }
+
+  // we may not get to finish the run cycle but exit immediately after a call to g_application.Stop()
+  // so we may never get to Destroy() in CXBApplicationEx::Run(), we call it here.
+  Destroy();
+  cleanup_emu_environ();
+
+  Sleep(200);
+}
+
+bool CApplication::PlayMedia(const CFileItem& item, int iPlaylist)
+{
+  //If item is a plugin, expand out now and run ourselves again
+  if (item.IsPlugin())
+  {
+    CFileItem item_new(item);
+    if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
+      return PlayMedia(item_new, iPlaylist);
+    return false;
+  }
+  if (item.IsSmartPlayList())
+  {
+    CFileItemList items;
+    CUtil::GetRecursiveListing(item.GetPath(), items, "", DIR_FLAG_NO_FILE_DIRS);
+    if (items.Size())
+    {
+      CSmartPlaylist smartpl;
+      //get name and type of smartplaylist, this will always succeed as GetDirectory also did this.
+      smartpl.OpenAndReadName(item.GetURL());
+      CPlayList playlist;
+      playlist.Add(items);
+      return ProcessAndStartPlaylist(smartpl.GetName(), playlist, (smartpl.GetType() == "songs" || smartpl.GetType() == "albums") ? PLAYLIST_MUSIC:PLAYLIST_VIDEO);
+    }
+  }
+  else if (item.IsPlayList() || item.IsInternetStream())
+  {
+    CGUIDialogCache* dlgCache = new CGUIDialogCache(5000, g_localizeStrings.Get(10214), item.GetLabel());
+
+    //is or could be a playlist
+    unique_ptr<CPlayList> pPlayList (CPlayListFactory::Create(item));
+    bool gotPlayList = (pPlayList.get() && pPlayList->Load(item.GetPath()));
+
+    if (dlgCache)
+    {
+       dlgCache->Close();
+       if (dlgCache->IsCanceled())
+          return true;
+    }
+
+    if (gotPlayList)
+    {
+
+      if (iPlaylist != PLAYLIST_NONE)
+      {
+        int track=0;
+        if (item.HasProperty("playlist_starting_track"))
+          track = (int)item.GetProperty("playlist_starting_track").asInteger();
+        return ProcessAndStartPlaylist(item.GetPath(), *pPlayList, iPlaylist, track);
+      }
+      else
+      {
+        CLog::Log(LOGWARNING, "CApplication::PlayMedia called to play a playlist %s but no idea which playlist to use, playing first item", item.GetPath().c_str());
+        if(pPlayList->size())
+          return PlayFile(*(*pPlayList)[0], false) == PLAYBACK_OK;
+      }
+    }
+  }
+  else if (item.IsPVR())
+  {
+    return g_PVRManager.PlayMedia(item);
+  }
+
+  //nothing special just play
+  return PlayFile(item, false) == PLAYBACK_OK;
+}
+
+// PlayStack()
+// For playing a multi-file video.  Particularly inefficient
+// on startup, as we are required to calculate the length
+// of each video, so we open + close each one in turn.
+// A faster calculation of video time would improve this
+// substantially.
+// return value: same with PlayFile()
+PlayBackRet CApplication::PlayStack(const CFileItem& item, bool bRestart)
+{
+  if (!item.IsStack())
+    return PLAYBACK_FAIL;
+
+  CVideoDatabase dbs;
+
+  // case 1: stacked ISOs
+  if (CFileItem(CStackDirectory::GetFirstStackedFile(item.GetPath()),false).IsDiscImage())
+  {
+    CStackDirectory dir;
+    CFileItemList movieList;
+    if (!dir.GetDirectory(item.GetURL(), movieList) || movieList.IsEmpty())
+      return PLAYBACK_FAIL;
+
+    // first assume values passed to the stack
+    int selectedFile = item.m_lStartPartNumber;
+    int startoffset = item.m_lStartOffset;
+
+    // check if we instructed the stack to resume from default
+    if (startoffset == STARTOFFSET_RESUME) // selected file is not specified, pick the 'last' resume point
+    {
+      if (dbs.Open())
+      {
+        CBookmark bookmark;
+        std::string path = item.GetPath();
+        if (item.HasProperty("original_listitem_url") && URIUtils::IsPlugin(item.GetProperty("original_listitem_url").asString()))
+          path = item.GetProperty("original_listitem_url").asString();
+        if( dbs.GetResumeBookMark(path, bookmark) )
+        {
+          startoffset = (int)(bookmark.timeInSeconds*75);
+          selectedFile = bookmark.partNumber;
+        }
+        dbs.Close();
+      }
+      else
+        CLog::LogF(LOGERROR, "Cannot open VideoDatabase");
+    }
+
+    // make sure that the selected part is within the boundaries
+    if (selectedFile <= 0)
+    {
+      CLog::LogF(LOGWARNING, "Selected part %d out of range, playing part 1", selectedFile);
+      selectedFile = 1;
+    }
+    else if (selectedFile > movieList.Size())
+    {
+      CLog::LogF(LOGWARNING, "Selected part %d out of range, playing part %d", selectedFile, movieList.Size());
+      selectedFile = movieList.Size();
+    }
+
+    // set startoffset in movieitem, track stack item for updating purposes, and finally play disc part
+    movieList[selectedFile - 1]->m_lStartOffset = startoffset > 0 ? STARTOFFSET_RESUME : 0;
+    movieList[selectedFile - 1]->SetProperty("stackFileItemToUpdate", true);
+    *m_stackFileItemToUpdate = item;
+    return PlayFile(*(movieList[selectedFile - 1]));
+  }
+  // case 2: all other stacks
+  else
+  {
+    LoadVideoSettings(item);
+    
+    // see if we have the info in the database
+    // TODO: If user changes the time speed (FPS via framerate conversion stuff)
+    //       then these times will be wrong.
+    //       Also, this is really just a hack for the slow load up times we have
+    //       A much better solution is a fast reader of FPS and fileLength
+    //       that we can use on a file to get it's time.
+    vector<int> times;
+    bool haveTimes(false);
+    CVideoDatabase dbs;
+    if (dbs.Open())
+    {
+      haveTimes = dbs.GetStackTimes(item.GetPath(), times);
+      dbs.Close();
+    }
+
+
+    // calculate the total time of the stack
+    CStackDirectory dir;
+    if (!dir.GetDirectory(item.GetURL(), *m_currentStack) || m_currentStack->IsEmpty())
+      return PLAYBACK_FAIL;
+    long totalTime = 0;
+    for (int i = 0; i < m_currentStack->Size(); i++)
+    {
+      if (haveTimes)
+        (*m_currentStack)[i]->m_lEndOffset = times[i];
+      else
+      {
+        int duration;
+        if (!CDVDFileInfo::GetFileDuration((*m_currentStack)[i]->GetPath(), duration))
+        {
+          m_currentStack->Clear();
+          return PLAYBACK_FAIL;
+        }
+        totalTime += duration / 1000;
+        (*m_currentStack)[i]->m_lEndOffset = totalTime;
+        times.push_back(totalTime);
+      }
+    }
+
+    double seconds = item.m_lStartOffset / 75.0;
+
+    if (!haveTimes || item.m_lStartOffset == STARTOFFSET_RESUME )
+    {  // have our times now, so update the dB
+      if (dbs.Open())
+      {
+        if (!haveTimes && !times.empty())
+          dbs.SetStackTimes(item.GetPath(), times);
+
+        if (item.m_lStartOffset == STARTOFFSET_RESUME)
+        {
+          // can only resume seek here, not dvdstate
+          CBookmark bookmark;
+          std::string path = item.GetPath();
+          if (item.HasProperty("original_listitem_url") && URIUtils::IsPlugin(item.GetProperty("original_listitem_url").asString()))
+            path = item.GetProperty("original_listitem_url").asString();
+          if (dbs.GetResumeBookMark(path, bookmark))
+            seconds = bookmark.timeInSeconds;
+          else
+            seconds = 0.0f;
+        }
+        dbs.Close();
+      }
+    }
+
+    *m_itemCurrentFile = item;
+    m_currentStackPosition = 0;
+    m_pPlayer->ResetPlayer(); // must be reset on initial play otherwise last player will be used
+
+    if (seconds > 0)
+    {
+      // work out where to seek to
+      for (int i = 0; i < m_currentStack->Size(); i++)
+      {
+        if (seconds < (*m_currentStack)[i]->m_lEndOffset)
+        {
+          CFileItem item(*(*m_currentStack)[i]);
+          long start = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+          item.m_lStartOffset = (long)(seconds - start) * 75;
+          m_currentStackPosition = i;
+          return PlayFile(item, true);
+        }
+      }
+    }
+
+    return PlayFile(*(*m_currentStack)[0], true);
+  }
+  return PLAYBACK_FAIL;
+}
+
+PlayBackRet CApplication::PlayFile(const CFileItem& item, bool bRestart)
+{
+  // Ensure the MIME type has been retrieved for http:// and shout:// streams
+  if (item.GetMimeType().empty())
+    const_cast<CFileItem&>(item).FillInMimeType();
+
+  if (!bRestart)
+  {
+    SaveFileState(true);
+
+    // Switch to default options
+    CMediaSettings::Get().GetCurrentVideoSettings() = CMediaSettings::Get().GetDefaultVideoSettings();
+    // see if we have saved options in the database
+
+    m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+    m_pPlayer->m_iPlaySpeed = 1;     // Reset both CApp's & Player's speed else we'll get confused
+
+    *m_itemCurrentFile = item;
+    m_nextPlaylistItem = -1;
+    m_currentStackPosition = 0;
+    m_currentStack->Clear();
+
+    if (item.IsVideo())
+      CUtil::ClearSubtitles();
+  }
+
+  if (item.IsDiscStub())
+  {
+#ifdef HAS_DVD_DRIVE
+    // Display the Play Eject dialog if there is any optical disc drive
+    if (g_mediaManager.HasOpticalDrive())
+    {
+      if (CGUIDialogPlayEject::ShowAndGetInput(item))
+        // PlayDiscAskResume takes path to disc. No parameter means default DVD drive.
+        // Can't do better as CGUIDialogPlayEject calls CMediaManager::IsDiscInDrive, which assumes default DVD drive anyway
+        return MEDIA_DETECT::CAutorun::PlayDiscAskResume() ? PLAYBACK_OK : PLAYBACK_FAIL;
+    }
+    else
+#endif
+      CGUIDialogOK::ShowAndGetInput(435, 436);
+
+    return PLAYBACK_OK;
+  }
+
+  if (item.IsPlayList())
+    return PLAYBACK_FAIL;
+
+  if (item.IsPlugin())
+  { // we modify the item so that it becomes a real URL
+    CFileItem item_new(item);
+    if (XFILE::CPluginDirectory::GetPluginResult(item.GetPath(), item_new))
+      return PlayFile(item_new, false);
+    return PLAYBACK_FAIL;
+  }
+
+  // a disc image might be Blu-Ray disc
+  if (item.IsBDFile() || item.IsDiscImage())
+  {
+    //check if we must show the simplified bd menu
+    if (!CGUIDialogSimpleMenu::ShowPlaySelection(const_cast<CFileItem&>(item)))
+      return PLAYBACK_CANCELED;
+  }
+
+#ifdef HAS_UPNP
+  if (URIUtils::IsUPnP(item.GetPath()))
+  {
+    CFileItem item_new(item);
+    if (XFILE::CUPnPDirectory::GetResource(item.GetURL(), item_new))
+      return PlayFile(item_new, false);
+    return PLAYBACK_FAIL;
+  }
+#endif
+
+  // if we have a stacked set of files, we need to setup our stack routines for
+  // "seamless" seeking and total time of the movie etc.
+  // will recall with restart set to true
+  if (item.IsStack())
+    return PlayStack(item, bRestart);
+
+  CPlayerOptions options;
+
+  if( item.HasProperty("StartPercent") )
+  {
+    double fallback = 0.0f;
+    if(item.GetProperty("StartPercent").isString())
+      fallback = (double)atof(item.GetProperty("StartPercent").asString().c_str());
+    options.startpercent = item.GetProperty("StartPercent").asDouble(fallback);
+  }
+
+  PLAYERCOREID eNewCore = EPC_NONE;
+  if( bRestart )
+  {
+    // have to be set here due to playstack using this for starting the file
+    options.starttime = item.m_lStartOffset / 75.0;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_itemCurrentFile->m_lStartOffset != 0)
+      m_itemCurrentFile->m_lStartOffset = STARTOFFSET_RESUME; // to force fullscreen switching
+
+    if( m_eForcedNextPlayer != EPC_NONE )
+      eNewCore = m_eForcedNextPlayer;
+    else if( m_pPlayer->GetCurrentPlayer() == EPC_NONE )
+      eNewCore = CPlayerCoreFactory::Get().GetDefaultPlayer(item);
+    else
+      eNewCore = m_pPlayer->GetCurrentPlayer();
+  }
+  else
+  {
+    options.starttime = item.m_lStartOffset / 75.0;
+    LoadVideoSettings(item);
+
+    if (item.IsVideo())
+    {
+      // open the d/b and retrieve the bookmarks for the current movie
+      CVideoDatabase dbs;
+      dbs.Open();
+
+      if( item.m_lStartOffset == STARTOFFSET_RESUME )
+      {
+        options.starttime = 0.0f;
+        CBookmark bookmark;
+        std::string path = item.GetPath();
+        if (item.HasVideoInfoTag() && StringUtils::StartsWith(item.GetVideoInfoTag()->m_strFileNameAndPath, "removable://"))
+          path = item.GetVideoInfoTag()->m_strFileNameAndPath;
+        else if (item.HasProperty("original_listitem_url") && URIUtils::IsPlugin(item.GetProperty("original_listitem_url").asString()))
+          path = item.GetProperty("original_listitem_url").asString();
+        if(dbs.GetResumeBookMark(path, bookmark))
+        {
+          options.starttime = bookmark.timeInSeconds;
+          options.state = bookmark.playerState;
+        }
+        /*
+         override with information from the actual item if available.  We do this as the VFS (eg plugins)
+         may set the resume point to override whatever XBMC has stored, yet we ignore it until now so that,
+         should the playerState be required, it is fetched from the database.
+         See the note in CGUIWindowVideoBase::ShowResumeMenu.
+         */
+        if (item.IsResumePointSet())
+          options.starttime = item.GetCurrentResumeTime();
+        else if (item.HasVideoInfoTag())
+        {
+          // No resume point is set, but check if this item is part of a multi-episode file
+          const CVideoInfoTag *tag = item.GetVideoInfoTag();
+
+          if (tag->m_iBookmarkId > 0)
+          {
+            CBookmark bookmark;
+            dbs.GetBookMarkForEpisode(*tag, bookmark);
+            options.starttime = bookmark.timeInSeconds;
+            options.state = bookmark.playerState;
+          }
+        }
+      }
+      else if (item.HasVideoInfoTag())
+      {
+        const CVideoInfoTag *tag = item.GetVideoInfoTag();
+
+        if (tag->m_iBookmarkId > 0)
+        {
+          CBookmark bookmark;
+          dbs.GetBookMarkForEpisode(*tag, bookmark);
+          options.starttime = bookmark.timeInSeconds;
+          options.state = bookmark.playerState;
+        }
+      }
+
+      dbs.Close();
+    }
+
+    if (m_eForcedNextPlayer != EPC_NONE)
+      eNewCore = m_eForcedNextPlayer;
+    else
+      eNewCore = CPlayerCoreFactory::Get().GetDefaultPlayer(item);
+  }
+
+  // this really aught to be inside !bRestart, but since PlayStack
+  // uses that to init playback, we have to keep it outside
+  int playlist = g_playlistPlayer.GetCurrentPlaylist();
+  if (item.IsVideo() && playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1)
+  { // playing from a playlist by the looks
+    // don't switch to fullscreen if we are not playing the first item...
+    options.fullscreen = !g_playlistPlayer.HasPlayedFirstFile() && g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::Get().DoesVideoStartWindowed();
+  }
+  else if(m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+  {
+    // TODO - this will fail if user seeks back to first file in stack
+    if(m_currentStackPosition == 0 || m_itemCurrentFile->m_lStartOffset == STARTOFFSET_RESUME)
+      options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::Get().DoesVideoStartWindowed();
+    else
+      options.fullscreen = false;
+    // reset this so we don't think we are resuming on seek
+    m_itemCurrentFile->m_lStartOffset = 0;
+  }
+  else
+    options.fullscreen = g_advancedSettings.m_fullScreenOnMovieStart && !CMediaSettings::Get().DoesVideoStartWindowed();
+
+  // reset VideoStartWindowed as it's a temp setting
+  CMediaSettings::Get().SetVideoStartWindowed(false);
+
+#ifdef HAS_KARAOKE
+  //We have to stop parsing a cdg before mplayer is deallocated
+  // WHY do we have to do this????
+  if (m_pKaraokeMgr)
+    m_pKaraokeMgr->Stop();
+#endif
+
+  {
+    CSingleLock lock(m_playStateMutex);
+    // tell system we are starting a file
+    m_bPlaybackStarting = true;
+    
+    // for playing a new item, previous playing item's callback may already
+    // pushed some delay message into the threadmessage list, they are not
+    // expected be processed after or during the new item playback starting.
+    // so we clean up previous playing item's playback callback delay messages here.
+    int previousMsgsIgnoredByNewPlaying[] = {
+      GUI_MSG_PLAYBACK_STARTED,
+      GUI_MSG_PLAYBACK_ENDED,
+      GUI_MSG_PLAYBACK_STOPPED,
+      GUI_MSG_PLAYLIST_CHANGED,
+      GUI_MSG_PLAYLISTPLAYER_STOPPED,
+      GUI_MSG_PLAYLISTPLAYER_STARTED,
+      GUI_MSG_PLAYLISTPLAYER_CHANGED,
+      GUI_MSG_QUEUE_NEXT_ITEM,
+      0
+    };
+    int dMsgCount = g_windowManager.RemoveThreadMessageByMessageIds(&previousMsgsIgnoredByNewPlaying[0]);
+    if (dMsgCount > 0)
+      CLog::LogF(LOGDEBUG,"Ignored %d playback thread messages", dMsgCount);
+  }
+
+  // We should restart the player, unless the previous and next tracks are using
+  // one of the players that allows gapless playback (paplayer, dvdplayer)
+  m_pPlayer->ClosePlayerGapless(eNewCore);
+
+  // now reset play state to starting, since we already stopped the previous playing item if there is.
+  // and from now there should be no playback callback from previous playing item be called.
+  m_ePlayState = PLAY_STATE_STARTING;
+
+  m_pPlayer->CreatePlayer(eNewCore, *this);
+
+  PlayBackRet iResult;
+  if (m_pPlayer->HasPlayer())
+  {
+    /* When playing video pause any low priority jobs, they will be unpaused  when playback stops.
+     * This should speed up player startup for files on internet filesystems (eg. webdav) and
+     * increase performance on low powered systems (Atom/ARM).
+     */
+    if (item.IsVideo())
+    {
+      CJobManager::GetInstance().PauseJobs();
+    }
+
+    // don't hold graphicscontext here since player
+    // may wait on another thread, that requires gfx
+    CSingleExit ex(g_graphicsContext);
+
+    iResult = m_pPlayer->OpenFile(item, options);
+  }
+  else
+  {
+    CLog::Log(LOGERROR, "Error creating player for item %s (File doesn't exist?)", item.GetPath().c_str());
+    iResult = PLAYBACK_FAIL;
+  }
+
+  if(iResult == PLAYBACK_OK)
+  {
+    if (m_pPlayer->GetPlaySpeed() != 1)
+    {
+      int iSpeed = m_pPlayer->GetPlaySpeed();
+      m_pPlayer->m_iPlaySpeed = 1;
+      m_pPlayer->SetPlaySpeed(iSpeed, g_application.m_muted);
+    }
+
+    // if player has volume control, set it.
+    if (m_pPlayer->ControlsVolume())
+    {
+      m_pPlayer->SetVolume(m_volumeLevel);
+      m_pPlayer->SetMute(m_muted);
+    }
+
+    if(m_pPlayer->IsPlayingAudio())
+    {
+      if (g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+        g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+    }
+
+#ifdef HAS_VIDEO_PLAYBACK
+    else if(m_pPlayer->IsPlayingVideo())
+    {
+      // if player didn't manange to switch to fullscreen by itself do it here
+      if (options.fullscreen && g_renderManager.IsStarted() &&
+          g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO )
+       SwitchToFullScreen(true);
+    }
+#endif
+    else
+    {
+      if (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION ||
+          g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+        g_windowManager.PreviousWindow();
+    }
+
+#if !defined(TARGET_POSIX)
+    g_audioManager.Enable(false);
+#endif
+
+    if (item.HasPVRChannelInfoTag())
+      g_playlistPlayer.SetCurrentPlaylist(PLAYLIST_NONE);
+  }
+
+  CSingleLock lock(m_playStateMutex);
+  m_bPlaybackStarting = false;
+
+  if (iResult == PLAYBACK_OK)
+  {
+    // play state: none, starting; playing; stopped; ended.
+    // last 3 states are set by playback callback, they are all ignored during starting,
+    // but we recorded the state, here we can make up the callback for the state.
+    CLog::LogF(LOGDEBUG,"OpenFile succeed, play state %d", m_ePlayState);
+    switch (m_ePlayState)
+    {
+      case PLAY_STATE_PLAYING:
+        OnPlayBackStarted();
+        break;
+      // FIXME: it seems no meaning to callback started here if there was an started callback
+      //        before this stopped/ended callback we recorded. if we callback started here
+      //        first, it will delay send OnPlay announce, but then we callback stopped/ended
+      //        which will send OnStop announce at once, so currently, just call stopped/ended.
+      case PLAY_STATE_ENDED:
+        OnPlayBackEnded();
+        break;
+      case PLAY_STATE_STOPPED:
+        OnPlayBackStopped();
+        break;
+      case PLAY_STATE_STARTING:
+        // neither started nor stopped/ended callback be called, that means the item still
+        // not started, we need not make up any callback, just leave this and
+        // let the player callback do its work.
+        break;
+      default:
+        break;
+    }
+  }
+  else if (iResult == PLAYBACK_FAIL)
+  {
+    // we send this if it isn't playlistplayer that is doing this
+    int next = g_playlistPlayer.GetNextSong();
+    int size = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist()).size();
+    if(next < 0
+    || next >= size)
+      OnPlayBackStopped();
+    m_ePlayState = PLAY_STATE_NONE;
+  }
+
+  return iResult;
+}
+
+void CApplication::OnPlayBackEnded()
+{
+  CSingleLock lock(m_playStateMutex);
+  CLog::LogF(LOGDEBUG,"play state was %d, starting %d", m_ePlayState, m_bPlaybackStarting);
+  m_ePlayState = PLAY_STATE_ENDED;
+  if(m_bPlaybackStarting)
+    return;
+
+  // informs python script currently running playback has ended
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackEnded();
+#endif
+#ifdef TARGET_ANDROID
+  CXBMCApp::OnPlayBackEnded();
+#endif
+
+  CVariant data(CVariant::VariantTypeObject);
+  data["end"] = true;
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnStop", m_itemCurrentFile, data);
+
+  CGUIMessage msg(GUI_MSG_PLAYBACK_ENDED, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackStarted()
+{
+  CSingleLock lock(m_playStateMutex);
+  CLog::LogF(LOGDEBUG,"play state was %d, starting %d", m_ePlayState, m_bPlaybackStarting);
+  m_ePlayState = PLAY_STATE_PLAYING;
+  if(m_bPlaybackStarting)
+    return;
+
+#ifdef HAS_PYTHON
+  // informs python script currently running playback has started
+  // (does nothing if python is not loaded)
+  g_pythonParser.OnPlayBackStarted();
+#endif
+#ifdef TARGET_ANDROID
+  CXBMCApp::OnPlayBackStarted();
+#endif
+
+  CGUIMessage msg(GUI_MSG_PLAYBACK_STARTED, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnQueueNextItem()
+{
+  CSingleLock lock(m_playStateMutex);
+  CLog::LogF(LOGDEBUG,"play state was %d, starting %d", m_ePlayState, m_bPlaybackStarting);
+  if(m_bPlaybackStarting)
+    return;
+  // informs python script currently running that we are requesting the next track
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnQueueNextItem(); // currently unimplemented
+#endif
+
+  CGUIMessage msg(GUI_MSG_QUEUE_NEXT_ITEM, 0, 0);
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackStopped()
+{
+  CSingleLock lock(m_playStateMutex);
+  CLog::LogF(LOGDEBUG, "play state was %d, starting %d", m_ePlayState, m_bPlaybackStarting);
+  m_ePlayState = PLAY_STATE_STOPPED;
+  if(m_bPlaybackStarting)
+    return;
+
+  // informs python script currently running playback has ended
+  // (does nothing if python is not loaded)
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackStopped();
+#endif
+#ifdef TARGET_ANDROID
+  CXBMCApp::OnPlayBackStopped();
+#endif
+
+  CVariant data(CVariant::VariantTypeObject);
+  data["end"] = false;
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnStop", m_itemCurrentFile, data);
+
+  CGUIMessage msg( GUI_MSG_PLAYBACK_STOPPED, 0, 0 );
+  g_windowManager.SendThreadMessage(msg);
+}
+
+void CApplication::OnPlayBackPaused()
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackPaused();
+#endif
+#ifdef TARGET_ANDROID
+  CXBMCApp::OnPlayBackPaused();
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = 0;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnPause", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackResumed()
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackResumed();
+#endif
+#ifdef TARGET_ANDROID
+  CXBMCApp::OnPlayBackResumed();
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = 1;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnPlay", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackSpeedChanged(int iSpeed)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSpeedChanged(iSpeed);
+#endif
+
+  CVariant param;
+  param["player"]["speed"] = iSpeed;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnSpeedChanged", m_itemCurrentFile, param);
+}
+
+void CApplication::OnPlayBackSeek(int iTime, int seekOffset)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSeek(iTime, seekOffset);
+#endif
+
+  CVariant param;
+  CJSONUtils::MillisecondsToTimeObject(iTime, param["player"]["time"]);
+  CJSONUtils::MillisecondsToTimeObject(seekOffset, param["player"]["seekoffset"]);;
+  param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+  param["player"]["speed"] = m_pPlayer->GetPlaySpeed();
+  CAnnouncementManager::Get().Announce(Player, "xbmc", "OnSeek", m_itemCurrentFile, param);
+  g_infoManager.SetDisplayAfterSeek(2500, seekOffset);
+}
+
+void CApplication::OnPlayBackSeekChapter(int iChapter)
+{
+#ifdef HAS_PYTHON
+  g_pythonParser.OnPlayBackSeekChapter(iChapter);
+#endif
+}
+
+bool CApplication::IsPlayingFullScreenVideo() const
+{
+  return m_pPlayer->IsPlayingVideo() && g_graphicsContext.IsFullScreenVideo();
+}
+
+bool CApplication::IsFullScreen()
+{
+  return IsPlayingFullScreenVideo() ||
+        (g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION) ||
+         g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW;
+}
+
+void CApplication::SaveFileState(bool bForeground /* = false */)
+{
+  if (!CProfilesManager::Get().GetCurrentProfile().canWriteDatabases())
+    return;
+
+  CJob* job = new CSaveFileStateJob(*m_progressTrackingItem,
+      *m_stackFileItemToUpdate,
+      m_progressTrackingVideoResumeBookmark,
+      m_progressTrackingPlayCountUpdate,
+      CMediaSettings::Get().GetCurrentVideoSettings());
+  
+  if (bForeground)
+  {
+    // Run job in the foreground to make sure it finishes
+    job->DoWork();
+    delete job;
+  }
+  else
+    CJobManager::GetInstance().AddJob(job, NULL, CJob::PRIORITY_NORMAL);
+}
+
+void CApplication::UpdateFileState()
+{
+  // Did the file change?
+  if (m_progressTrackingItem->GetPath() != "" && m_progressTrackingItem->GetPath() != CurrentFile())
+  {
+    // Ignore for PVR channels, PerformChannelSwitch takes care of this.
+    // Also ignore video playlists containing multiple items: video settings have already been saved in PlayFile()
+    // and we'd overwrite them with settings for the *previous* item.
+    // TODO: these "exceptions" should be removed and the whole logic of saving settings be revisited and
+    // possibly moved out of CApplication.  See PRs 5842, 5958, http://trac.kodi.tv/ticket/15704#comment:3
+    int playlist = g_playlistPlayer.GetCurrentPlaylist();
+    if (!m_progressTrackingItem->IsPVRChannel() && !(playlist == PLAYLIST_VIDEO && g_playlistPlayer.GetPlaylist(playlist).size() > 1))
+      SaveFileState();
+
+    // Reset tracking item
+    m_progressTrackingItem->Reset();
+  }
+  else
+  {
+    if (m_pPlayer->IsPlaying())
+    {
+      if (m_progressTrackingItem->GetPath() == "")
+      {
+        // Init some stuff
+        *m_progressTrackingItem = CurrentFileItem();
+        m_progressTrackingPlayCountUpdate = false;
+      }
+
+      if ((m_progressTrackingItem->IsAudio() && g_advancedSettings.m_audioPlayCountMinimumPercent > 0 &&
+          GetPercentage() >= g_advancedSettings.m_audioPlayCountMinimumPercent) ||
+          (m_progressTrackingItem->IsVideo() && g_advancedSettings.m_videoPlayCountMinimumPercent > 0 &&
+          GetPercentage() >= g_advancedSettings.m_videoPlayCountMinimumPercent))
+      {
+        m_progressTrackingPlayCountUpdate = true;
+      }
+
+      // Check whether we're *really* playing video else we may race when getting eg. stream details
+      if (m_pPlayer->IsPlayingVideo())
+      {
+        /* Always update streamdetails, except for DVDs where we only update
+           streamdetails if total duration > 15m (Should yield more correct info) */
+        if (!(m_progressTrackingItem->IsDiscImage() || m_progressTrackingItem->IsDVDFile()) || m_pPlayer->GetTotalTime() > 15*60*1000)
+        {
+          CStreamDetails details;
+          // Update with stream details from player, if any
+          if (m_pPlayer->GetStreamDetails(details))
+            m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails = details;
+
+          if (m_progressTrackingItem->IsStack())
+            m_progressTrackingItem->GetVideoInfoTag()->m_streamDetails.SetVideoDuration(0, (int)GetTotalTime()); // Overwrite with CApp's totaltime as it takes into account total stack time
+        }
+
+        // Update bookmark for save
+        m_progressTrackingVideoResumeBookmark.player = CPlayerCoreFactory::Get().GetPlayerName(m_pPlayer->GetCurrentPlayer());
+        m_progressTrackingVideoResumeBookmark.playerState = m_pPlayer->GetPlayerState();
+        m_progressTrackingVideoResumeBookmark.thumbNailImage.clear();
+
+        if (g_advancedSettings.m_videoIgnorePercentAtEnd > 0 &&
+            GetTotalTime() - GetTime() < 0.01f * g_advancedSettings.m_videoIgnorePercentAtEnd * GetTotalTime())
+        {
+          // Delete the bookmark
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+        }
+        else
+        if (GetTime() > g_advancedSettings.m_videoIgnoreSecondsAtStart)
+        {
+          // Update the bookmark
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = GetTime();
+          m_progressTrackingVideoResumeBookmark.totalTimeInSeconds = GetTotalTime();
+        }
+        else
+        {
+          // Do nothing
+          m_progressTrackingVideoResumeBookmark.timeInSeconds = 0.0f;
+        }
+      }
+    }
+  }
+}
+
+void CApplication::LoadVideoSettings(const CFileItem& item)
+{
+  CVideoDatabase dbs;
+  if (dbs.Open())
+  {
+    CLog::Log(LOGDEBUG, "Loading settings for %s", item.GetPath().c_str());
+    
+    // Load stored settings if they exist, otherwise use default
+    if (!dbs.GetVideoSettings(item, CMediaSettings::Get().GetCurrentVideoSettings()))
+      CMediaSettings::Get().GetCurrentVideoSettings() = CMediaSettings::Get().GetDefaultVideoSettings();
+    
+    dbs.Close();
+  }
+}
+
+void CApplication::StopPlaying()
+{
+  int iWin = g_windowManager.GetActiveWindow();
+  if ( m_pPlayer->IsPlaying() )
+  {
+#ifdef HAS_KARAOKE
+    if( m_pKaraokeMgr )
+      m_pKaraokeMgr->Stop();
+#endif
+
+    m_pPlayer->CloseFile();
+
+    // turn off visualisation window when stopping
+    if ((iWin == WINDOW_VISUALISATION
+    ||  iWin == WINDOW_FULLSCREEN_VIDEO)
+    && !m_bStop)
+      g_windowManager.PreviousWindow();
+
+    g_partyModeManager.Disable();
+  }
+}
+
+void CApplication::ResetSystemIdleTimer()
+{
+  // reset system idle timer
+  m_idleTimer.StartZero();
+}
+
+void CApplication::ResetScreenSaver()
+{
+  // reset our timers
+  m_shutdownTimer.StartZero();
+
+  // screen saver timer is reset only if we're not already in screensaver or
+  // DPMS mode
+  if ((!m_bScreenSave && m_iScreenSaveLock == 0) && !m_dpmsIsActive)
+    ResetScreenSaverTimer();
+}
+
+void CApplication::ResetScreenSaverTimer()
+{
+  m_screenSaverTimer.StartZero();
+}
+
+void CApplication::StopScreenSaverTimer()
+{
+  m_screenSaverTimer.Stop();
+}
+
+bool CApplication::ToggleDPMS(bool manual)
+{
+  if (manual || (m_dpmsIsManual == manual))
+  {
+    if (m_dpmsIsActive)
+    {
+      m_dpmsIsActive = false;
+      m_dpmsIsManual = false;
+      SetRenderGUI(true);
+      CAnnouncementManager::Get().Announce(GUI, "xbmc", "OnDPMSDeactivated");
+      return m_dpms->DisablePowerSaving();
+    }
+    else
+    {
+      if (m_dpms->EnablePowerSaving(m_dpms->GetSupportedModes()[0]))
+      {
+        m_dpmsIsActive = true;
+        m_dpmsIsManual = manual;
+        SetRenderGUI(false);
+        CAnnouncementManager::Get().Announce(GUI, "xbmc", "OnDPMSActivated");
+        return true;
+      }
+    }
+  }
+  return false;
+}
+
+bool CApplication::WakeUpScreenSaverAndDPMS(bool bPowerOffKeyPressed /* = false */)
+{
+  bool result;
+
+  // First reset DPMS, if active
+  if (m_dpmsIsActive)
+  {
+    if (m_dpmsIsManual)
+      return false;
+    // TODO: if screensaver lock is specified but screensaver is not active
+    // (DPMS came first), activate screensaver now.
+    ToggleDPMS(false);
+    ResetScreenSaverTimer();
+    result = !m_bScreenSave || WakeUpScreenSaver(bPowerOffKeyPressed);
+  }
+  else
+    result = WakeUpScreenSaver(bPowerOffKeyPressed);
+
+  if(result)
+  {
+    // allow listeners to ignore the deactivation if it preceeds a powerdown/suspend etc
+    CVariant data(CVariant::VariantTypeObject);
+    data["shuttingdown"] = bPowerOffKeyPressed;
+    CAnnouncementManager::Get().Announce(GUI, "xbmc", "OnScreensaverDeactivated", data);
+#ifdef TARGET_ANDROID
+    // Screensaver deactivated -> acquire wake lock
+    CXBMCApp::EnableWakeLock(true);
+#endif
+  }
+
+  return result;
+}
+
+bool CApplication::WakeUpScreenSaver(bool bPowerOffKeyPressed /* = false */)
+{
+  if (m_iScreenSaveLock == 2)
+    return false;
+
+  // if Screen saver is active
+  if (m_bScreenSave && m_screenSaver)
+  {
+    if (m_iScreenSaveLock == 0)
+      if (CProfilesManager::Get().GetMasterProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+          (CProfilesManager::Get().UsingLoginScreen() || CSettings::Get().GetBool("masterlock.startuplock")) &&
+          CProfilesManager::Get().GetCurrentProfile().getLockMode() != LOCK_MODE_EVERYONE &&
+          m_screenSaver->ID() != "screensaver.xbmc.builtin.dim" && m_screenSaver->ID() != "screensaver.xbmc.builtin.black" && !m_screenSaver->ID().empty() && m_screenSaver->ID() != "visualization")
+      {
+        m_iScreenSaveLock = 2;
+        CGUIMessage msg(GUI_MSG_CHECK_LOCK,0,0);
+
+        CGUIWindow* pWindow = g_windowManager.GetWindow(WINDOW_SCREENSAVER);
+        if (pWindow)
+          pWindow->OnMessage(msg);
+      }
+    if (m_iScreenSaveLock == -1)
+    {
+      m_iScreenSaveLock = 0;
+      return true;
+    }
+
+    // disable screensaver
+    m_bScreenSave = false;
+    m_iScreenSaveLock = 0;
+    ResetScreenSaverTimer();
+
+    if (m_screenSaver->ID() == "visualization")
+    {
+      // we can just continue as usual from vis mode
+      return false;
+    }
+    else if (m_screenSaver->ID() == "screensaver.xbmc.builtin.dim" || m_screenSaver->ID() == "screensaver.xbmc.builtin.black" || m_screenSaver->ID().empty())
+      return true;
+    else if (!m_screenSaver->ID().empty())
+    { // we're in screensaver window
+      if (g_windowManager.GetActiveWindow() == WINDOW_SCREENSAVER)
+        g_windowManager.PreviousWindow();  // show the previous window
+      if (g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
+        CApplicationMessenger::Get().SendAction(CAction(ACTION_STOP), WINDOW_SLIDESHOW);
+    }
+    return true;
+  }
+  else
+    return false;
+}
+
+void CApplication::CheckScreenSaverAndDPMS()
+{
+  if (!m_dpmsIsActive)
+    g_Windowing.ResetOSScreensaver();
+
+  bool maybeScreensaver =
+      !m_dpmsIsActive && !m_bScreenSave
+      && !CSettings::Get().GetString("screensaver.mode").empty();
+  bool maybeDPMS =
+      !m_dpmsIsActive && m_dpms->IsSupported()
+      && CSettings::Get().GetInt("powermanagement.displaysoff") > 0;
+
+  // Has the screen saver window become active?
+  if (maybeScreensaver && g_windowManager.IsWindowActive(WINDOW_SCREENSAVER))
+  {
+    m_bScreenSave = true;
+    maybeScreensaver = false;
+  }
+
+  if (m_bScreenSave && m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPaused())
+  {
+    WakeUpScreenSaverAndDPMS();
+    return;
+  }
+
+  if (!maybeScreensaver && !maybeDPMS) return;  // Nothing to do.
+
+  // See if we need to reset timer.
+  // * Are we playing a video and it is not paused?
+  if ((m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPaused())
+      // * Are we playing some music in fullscreen vis?
+      || (m_pPlayer->IsPlayingAudio() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION
+          && !CSettings::Get().GetString("musicplayer.visualisation").empty()))
+  {
+    ResetScreenSaverTimer();
+    return;
+  }
+
+  float elapsed = m_screenSaverTimer.IsRunning() ? m_screenSaverTimer.GetElapsedSeconds() : 0.f;
+
+  // DPMS has priority (it makes the screensaver not needed)
+  if (maybeDPMS
+      && elapsed > CSettings::Get().GetInt("powermanagement.displaysoff") * 60)
+  {
+    ToggleDPMS(false);
+    WakeUpScreenSaver();
+  }
+  else if (maybeScreensaver
+           && elapsed > CSettings::Get().GetInt("screensaver.time") * 60)
+  {
+    ActivateScreenSaver();
+  }
+}
+
+// activate the screensaver.
+// if forceType is true, we ignore the various conditions that can alter
+// the type of screensaver displayed
+void CApplication::ActivateScreenSaver(bool forceType /*= false */)
+{
+  if (m_pPlayer->IsPlayingAudio() && CSettings::Get().GetBool("screensaver.usemusicvisinstead") && !CSettings::Get().GetString("musicplayer.visualisation").empty())
+  { // just activate the visualisation if user toggled the usemusicvisinstead option
+    g_windowManager.ActivateWindow(WINDOW_VISUALISATION);
+    return;
+  }
+
+  m_bScreenSave = true;
+
+  // Get Screensaver Mode
+  m_screenSaver.reset();
+  if (!CAddonMgr::Get().GetAddon(CSettings::Get().GetString("screensaver.mode"), m_screenSaver))
+    m_screenSaver.reset(new CScreenSaver(""));
+
+  CAnnouncementManager::Get().Announce(GUI, "xbmc", "OnScreensaverActivated");
+
+  // disable screensaver lock from the login screen
+  m_iScreenSaveLock = g_windowManager.GetActiveWindow() == WINDOW_LOGIN_SCREEN ? 1 : 0;
+  if (!forceType)
+  {
+    // set to Dim in the case of a dialog on screen or playing video
+    if (g_windowManager.HasModalDialog() || (m_pPlayer->IsPlayingVideo() && CSettings::Get().GetBool("screensaver.usedimonpause")) || g_PVRManager.IsRunningChannelScan())
+    {
+      if (!CAddonMgr::Get().GetAddon("screensaver.xbmc.builtin.dim", m_screenSaver))
+        m_screenSaver.reset(new CScreenSaver(""));
+    }
+  }
+  if (m_screenSaver->ID() == "screensaver.xbmc.builtin.dim"
+      || m_screenSaver->ID() == "screensaver.xbmc.builtin.black")
+  {
+#ifdef TARGET_ANDROID
+    // Default screensaver activated -> release wake lock
+    CXBMCApp::EnableWakeLock(false);
+#endif
+    return;
+  }
+  else if (m_screenSaver->ID().empty())
+    return;
+  else
+    g_windowManager.ActivateWindow(WINDOW_SCREENSAVER);
+}
+
+void CApplication::CheckShutdown()
+{
+  // first check if we should reset the timer
+  if (m_bInhibitIdleShutdown
+      || m_pPlayer->IsPlaying() || m_pPlayer->IsPausedPlayback() // is something playing?
+      || m_musicInfoScanner->IsScanning()
+      || CVideoLibraryQueue::Get().IsRunning()
+      || g_windowManager.IsWindowActive(WINDOW_DIALOG_PROGRESS) // progress dialog is onscreen
+      || !g_PVRManager.CanSystemPowerdown(false))
+  {
+    m_shutdownTimer.StartZero();
+    return;
+  }
+
+  float elapsed = m_shutdownTimer.IsRunning() ? m_shutdownTimer.GetElapsedSeconds() : 0.f;
+  if ( elapsed > CSettings::Get().GetInt("powermanagement.shutdowntime") * 60 )
+  {
+    // Since it is a sleep instead of a shutdown, let's set everything to reset when we wake up.
+    m_shutdownTimer.Stop();
+
+    // Sleep the box
+    CApplicationMessenger::Get().Shutdown();
+  }
+}
+
+void CApplication::InhibitIdleShutdown(bool inhibit)
+{
+  m_bInhibitIdleShutdown = inhibit;
+}
+
+bool CApplication::IsIdleShutdownInhibited() const
+{
+  return m_bInhibitIdleShutdown;
+}
+
+bool CApplication::OnMessage(CGUIMessage& message)
+{
+  switch ( message.GetMessage() )
+  {
+  case GUI_MSG_NOTIFY_ALL:
+    {
+      if (message.GetParam1()==GUI_MSG_REMOVED_MEDIA)
+      {
+        // Update general playlist: Remove DVD playlist items
+        int nRemoved = g_playlistPlayer.RemoveDVDItems();
+        if ( nRemoved > 0 )
+        {
+          CGUIMessage msg( GUI_MSG_PLAYLIST_CHANGED, 0, 0 );
+          g_windowManager.SendMessage( msg );
+        }
+        // stop the file if it's on dvd (will set the resume point etc)
+        if (m_itemCurrentFile->IsOnDVD())
+          StopPlaying();
+      }
+      else if (message.GetParam1() == GUI_MSG_UI_READY)
+      {
+        // remove splash window
+        g_windowManager.Delete(WINDOW_SPLASH);
+
+        if (m_fallbackLanguageLoaded)
+          CGUIDialogOK::ShowAndGetInput(24133, 24134);
+
+        // show info dialog about moved configuration files if needed
+        ShowAppMigrationMessage();
+      }
+    }
+    break;
+
+  case GUI_MSG_PLAYBACK_STARTED:
+    {
+#ifdef TARGET_DARWIN
+      CDarwinUtils::SetScheduling(message.GetMessage());
+#endif
+      CPlayList playList = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
+
+      // Update our infoManager with the new details etc.
+      if (m_nextPlaylistItem >= 0)
+      { 
+        // playing an item which is not in the list - player might be stopped already
+        // so do nothing
+        if (playList.size() <= m_nextPlaylistItem)
+          return true;
+
+        // we've started a previously queued item
+        CFileItemPtr item = playList[m_nextPlaylistItem];
+        // update the playlist manager
+        int currentSong = g_playlistPlayer.GetCurrentSong();
+        int param = ((currentSong & 0xffff) << 16) | (m_nextPlaylistItem & 0xffff);
+        CGUIMessage msg(GUI_MSG_PLAYLISTPLAYER_CHANGED, 0, 0, g_playlistPlayer.GetCurrentPlaylist(), param, item);
+        g_windowManager.SendThreadMessage(msg);
+        g_playlistPlayer.SetCurrentSong(m_nextPlaylistItem);
+        *m_itemCurrentFile = *item;
+      }
+      g_infoManager.SetCurrentItem(*m_itemCurrentFile);
+      g_partyModeManager.OnSongChange(true);
+
+      CVariant param;
+      param["player"]["speed"] = 1;
+      param["player"]["playerid"] = g_playlistPlayer.GetCurrentPlaylist();
+      CAnnouncementManager::Get().Announce(Player, "xbmc", "OnPlay", m_itemCurrentFile, param);
+
+      if (m_pPlayer->IsPlayingAudio())
+      {
+        // Start our cdg parser as appropriate
+#ifdef HAS_KARAOKE
+        if (m_pKaraokeMgr && CSettings::Get().GetBool("karaoke.enabled") && !m_itemCurrentFile->IsInternetStream())
+        {
+          m_pKaraokeMgr->Stop();
+          if (m_itemCurrentFile->IsMusicDb())
+          {
+            if (!m_itemCurrentFile->HasMusicInfoTag() || !m_itemCurrentFile->GetMusicInfoTag()->Loaded())
+            {
+              IMusicInfoTagLoader* tagloader = CMusicInfoTagLoaderFactory::CreateLoader(*m_itemCurrentFile);
+              tagloader->Load(m_itemCurrentFile->GetPath(),*m_itemCurrentFile->GetMusicInfoTag());
+              delete tagloader;
+            }
+            m_pKaraokeMgr->Start(m_itemCurrentFile->GetMusicInfoTag()->GetURL());
+          }
+          else
+            m_pKaraokeMgr->Start(m_itemCurrentFile->GetPath());
+        }
+#endif
+      }
+
+      return true;
+    }
+    break;
+
+  case GUI_MSG_QUEUE_NEXT_ITEM:
+    {
+      // Check to see if our playlist player has a new item for us,
+      // and if so, we check whether our current player wants the file
+      int iNext = g_playlistPlayer.GetNextSong();
+      CPlayList& playlist = g_playlistPlayer.GetPlaylist(g_playlistPlayer.GetCurrentPlaylist());
+      if (iNext < 0 || iNext >= playlist.size())
+      {
+        m_pPlayer->OnNothingToQueueNotify();
+        return true; // nothing to do
+      }
+
+      // ok, grab the next song
+      CFileItem file(*playlist[iNext]);
+      // handle plugin://
+      CURL url(file.GetPath());
+      if (url.IsProtocol("plugin"))
+        XFILE::CPluginDirectory::GetPluginResult(url.Get(), file);
+
+      // Don't queue if next media type is different from current one
+      if ((!file.IsVideo() && m_pPlayer->IsPlayingVideo())
+          || ((!file.IsAudio() || file.IsVideo()) && m_pPlayer->IsPlayingAudio()))
+      {
+        m_pPlayer->OnNothingToQueueNotify();
+        return true;
+      }
+
+#ifdef HAS_UPNP
+      if (URIUtils::IsUPnP(file.GetPath()))
+      {
+        if (!XFILE::CUPnPDirectory::GetResource(file.GetURL(), file))
+          return true;
+      }
+#endif
+
+      // ok - send the file to the player, if it accepts it
+      if (m_pPlayer->QueueNextFile(file))
+      {
+        // player accepted the next file
+        m_nextPlaylistItem = iNext;
+      }
+      else
+      {
+        /* Player didn't accept next file: *ALWAYS* advance playlist in this case so the player can
+            queue the next (if it wants to) and it doesn't keep looping on this song */
+        g_playlistPlayer.SetCurrentSong(iNext);
+      }
+
+      return true;
+    }
+    break;
+
+  case GUI_MSG_PLAYBACK_STOPPED:
+  case GUI_MSG_PLAYBACK_ENDED:
+  case GUI_MSG_PLAYLISTPLAYER_STOPPED:
+    {
+#ifdef HAS_KARAOKE
+      if (m_pKaraokeMgr )
+        m_pKaraokeMgr->Stop();
+#endif
+#ifdef TARGET_DARWIN
+      CDarwinUtils::SetScheduling(message.GetMessage());
+#endif
+      // first check if we still have items in the stack to play
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+      {
+        if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0 && m_currentStackPosition < m_currentStack->Size() - 1)
+        { // just play the next item in the stack
+          PlayFile(*(*m_currentStack)[++m_currentStackPosition], true);
+          return true;
+        }
+      }
+
+      // In case playback ended due to user eg. skipping over the end, clear
+      // our resume bookmark here
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED && m_progressTrackingPlayCountUpdate && g_advancedSettings.m_videoIgnorePercentAtEnd > 0)
+      {
+        // Delete the bookmark
+        m_progressTrackingVideoResumeBookmark.timeInSeconds = -1.0f;
+      }
+
+      // reset the current playing file
+      m_itemCurrentFile->Reset();
+      g_infoManager.ResetCurrentItem();
+      m_currentStack->Clear();
+
+      if (message.GetMessage() == GUI_MSG_PLAYBACK_ENDED)
+      {
+        g_playlistPlayer.PlayNext(1, true);
+      }
+      else
+      {
+        // reset any forced player
+        m_eForcedNextPlayer = EPC_NONE;
+
+        m_pPlayer->ClosePlayer();
+
+        // Reset playspeed
+        m_pPlayer->m_iPlaySpeed = 1;
+      }
+
+      if (!m_pPlayer->IsPlaying())
+      {
+        g_audioManager.Enable(true);
+      }
+
+      if (!m_pPlayer->IsPlayingVideo())
+      {
+        if(g_windowManager.GetActiveWindow() == WINDOW_FULLSCREEN_VIDEO)
+        {
+          g_windowManager.PreviousWindow();
+        }
+        else
+        {
+          CSingleLock lock(g_graphicsContext);
+          //  resets to res_desktop or look&feel resolution (including refreshrate)
+          g_graphicsContext.SetFullScreenVideo(false);
+        }
+      }
+
+      if (!m_pPlayer->IsPlayingAudio() && g_playlistPlayer.GetCurrentPlaylist() == PLAYLIST_NONE && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+      {
+        CSettings::Get().Save();  // save vis settings
+        WakeUpScreenSaverAndDPMS();
+        g_windowManager.PreviousWindow();
+      }
+
+      // DVD ejected while playing in vis ?
+      if (!m_pPlayer->IsPlayingAudio() && (m_itemCurrentFile->IsCDDA() || m_itemCurrentFile->IsOnDVD()) && !g_mediaManager.IsDiscInDrive() && g_windowManager.GetActiveWindow() == WINDOW_VISUALISATION)
+      {
+        // yes, disable vis
+        CSettings::Get().Save();    // save vis settings
+        WakeUpScreenSaverAndDPMS();
+        g_windowManager.PreviousWindow();
+      }
+
+      if (IsEnableTestMode())
+        CApplicationMessenger::Get().Quit();
+      return true;
+    }
+    break;
+
+  case GUI_MSG_PLAYLISTPLAYER_STARTED:
+  case GUI_MSG_PLAYLISTPLAYER_CHANGED:
+    {
+      return true;
+    }
+    break;
+  case GUI_MSG_FULLSCREEN:
+    { // Switch to fullscreen, if we can
+      SwitchToFullScreen();
+      return true;
+    }
+    break;
+  case GUI_MSG_EXECUTE:
+    if (message.GetNumStringParams())
+      return ExecuteXBMCAction(message.GetStringParam());
+    break;
+  }
+  return false;
+}
+
+bool CApplication::ExecuteXBMCAction(std::string actionStr)
+{
+  // see if it is a user set string
+
+  //We don't know if there is unsecure information in this yet, so we
+  //postpone any logging
+  const std::string in_actionStr(actionStr);
+  actionStr = CGUIInfoLabel::GetLabel(actionStr);
+
+  // user has asked for something to be executed
+  if (CBuiltins::HasCommand(actionStr))
+  {
+    if (!CBuiltins::IsSystemPowerdownCommand(actionStr) ||
+        g_PVRManager.CanSystemPowerdown())
+      CBuiltins::Execute(actionStr);
+  }
+  else
+  {
+    // try translating the action from our ButtonTranslator
+    int actionID;
+    if (CButtonTranslator::TranslateActionString(actionStr.c_str(), actionID))
+    {
+      OnAction(CAction(actionID));
+      return true;
+    }
+    CFileItem item(actionStr, false);
+#ifdef HAS_PYTHON
+    if (item.IsPythonScript())
+    { // a python script
+      CScriptInvocationManager::Get().ExecuteAsync(item.GetPath());
+    }
+    else
+#endif
+    if (item.IsAudio() || item.IsVideo())
+    { // an audio or video file
+      PlayFile(item);
+    }
+    else
+    {
+      //At this point we have given up to translate, so even though
+      //there may be insecure information, we log it.
+      CLog::LogF(LOGDEBUG,"Tried translating, but failed to understand %s", in_actionStr.c_str());
+      return false;
+    }
+  }
+  return true;
+}
+
+// inform the user that the configuration data has moved from old XBMC location
+// to new Kodi location - if applicable
+void CApplication::ShowAppMigrationMessage()
+{
+  // .kodi_migration_complete will be created from the installer/packaging
+  // once an old XBMC configuration was moved to the new Kodi location
+  // if this is the case show the migration info to the user once which
+  // tells him to have a look into the wiki where the move of configuration
+  // is further explained.
+  if (CFile::Exists("special://home/.kodi_data_was_migrated") &&
+      !CFile::Exists("special://home/.kodi_migration_info_shown"))
+  {
+    CGUIDialogOK::ShowAndGetInput(24128, 24129);
+    CFile tmpFile;
+    // create the file which will prevent this dialog from appearing in the future
+    tmpFile.OpenForWrite("special://home/.kodi_migration_info_shown");
+    tmpFile.Close();
+  }
+}
+
+void CApplication::Process()
+{
+  MEASURE_FUNCTION;
+
+  // dispatch the messages generated by python or other threads to the current window
+  g_windowManager.DispatchThreadMessages();
+
+  // process messages which have to be send to the gui
+  // (this can only be done after g_windowManager.Render())
+  CApplicationMessenger::Get().ProcessWindowMessages();
+
+  if (m_loggingIn)
+  {
+    m_loggingIn = false;
+
+    // autoexec.py - profile
+    std::string strAutoExecPy = CSpecialProtocol::TranslatePath("special://profile/autoexec.py");
+
+    if (XFILE::CFile::Exists(strAutoExecPy))
+      CScriptInvocationManager::Get().ExecuteAsync(strAutoExecPy);
+    else
+      CLog::Log(LOGDEBUG, "no profile autoexec.py (%s) found, skipping", strAutoExecPy.c_str());
+  }
+
+  // handle any active scripts
+  CScriptInvocationManager::Get().Process();
+
+  // process messages, even if a movie is playing
+  CApplicationMessenger::Get().ProcessMessages();
+  if (g_application.m_bStop) return; //we're done, everything has been unloaded
+
+  // check how far we are through playing the current item
+  // and do anything that needs doing (playcount updates etc)
+  CheckPlayingProgress();
+
+  // update sound
+  m_pPlayer->DoAudioWork();
+
+  // do any processing that isn't needed on each run
+  if( m_slowTimer.GetElapsedMilliseconds() > 500 )
+  {
+    m_slowTimer.Reset();
+    ProcessSlow();
+  }
+
+  g_cpuInfo.getUsedPercentage(); // must call it to recalculate pct values
+}
+
+// We get called every 500ms
+void CApplication::ProcessSlow()
+{
+  g_powerManager.ProcessEvents();
+
+#if defined(TARGET_DARWIN_OSX)
+  // There is an issue on OS X that several system services ask the cursor to become visible
+  // during their startup routines.  Given that we can't control this, we hack it in by
+  // forcing the
+  if (g_Windowing.IsFullScreen())
+  { // SDL thinks it's hidden
+    Cocoa_HideMouse();
+  }
+#endif
+
+  // Temporarely pause pausable jobs when viewing video/picture
+  int currentWindow = g_windowManager.GetActiveWindow();
+  if (CurrentFileItem().IsVideo() || CurrentFileItem().IsPicture() || currentWindow == WINDOW_FULLSCREEN_VIDEO || currentWindow == WINDOW_SLIDESHOW)
+  {
+    CJobManager::GetInstance().PauseJobs();
+  }
+  else
+  {
+    CJobManager::GetInstance().UnPauseJobs();
+  }
+
+  // Store our file state for use on close()
+  UpdateFileState();
+
+  // Check if we need to activate the screensaver / DPMS.
+  CheckScreenSaverAndDPMS();
+
+  // Check if we need to shutdown (if enabled).
+#if defined(TARGET_DARWIN)
+  if (CSettings::Get().GetInt("powermanagement.shutdowntime") && g_advancedSettings.m_fullScreen)
+#else
+  if (CSettings::Get().GetInt("powermanagement.shutdowntime"))
+#endif
+  {
+    CheckShutdown();
+  }
+
+  // check if we should restart the player
+  CheckDelayedPlayerRestart();
+
+  //  check if we can unload any unreferenced dlls or sections
+  if (!m_pPlayer->IsPlayingVideo())
+    CSectionLoader::UnloadDelayed();
+
+  // check for any idle curl connections
+  g_curlInterface.CheckIdle();
+
+#ifdef HAS_KARAOKE
+  if ( m_pKaraokeMgr )
+    m_pKaraokeMgr->ProcessSlow();
+#endif
+
+  if (!m_pPlayer->IsPlayingVideo())
+    g_largeTextureManager.CleanupUnusedImages();
+
+  g_TextureManager.FreeUnusedTextures(5000);
+
+#ifdef HAS_DVD_DRIVE
+  // checks whats in the DVD drive and tries to autostart the content (xbox games, dvd, cdda, avi files...)
+  if (!m_pPlayer->IsPlayingVideo())
+    m_Autorun->HandleAutorun();
+#endif
+
+  // update upnp server/renderer states
+#ifdef HAS_UPNP
+  if(UPNP::CUPnP::IsInstantiated())
+    UPNP::CUPnP::GetInstance()->UpdateState();
+#endif
+
+#if defined(TARGET_POSIX) && defined(HAS_FILESYSTEM_SMB)
+  smb.CheckIfIdle();
+#endif
+
+#ifdef HAS_FILESYSTEM_NFS
+  gNfsConnection.CheckIfIdle();
+#endif
+
+#ifdef HAS_FILESYSTEM_SFTP
+  CSFTPSessionManager::ClearOutIdleSessions();
+#endif
+
+  g_mediaManager.ProcessEvents();
+
+  if (!m_pPlayer->IsPlayingVideo() &&
+      CSettings::Get().GetInt("general.addonupdates") != AUTO_UPDATES_NEVER)
+    CAddonInstaller::Get().UpdateRepos();
+
+  CAEFactory::GarbageCollect();
+
+  // if we don't render the gui there's no reason to start the screensaver.
+  // that way the screensaver won't kick in if we maximize the XBMC window
+  // after the screensaver start time.
+  if(!m_renderGUI)
+    ResetScreenSaverTimer();
+}
+
+// Global Idle Time in Seconds
+// idle time will be resetet if on any OnKey()
+// int return: system Idle time in seconds! 0 is no idle!
+int CApplication::GlobalIdleTime()
+{
+  if(!m_idleTimer.IsRunning())
+    m_idleTimer.StartZero();
+  return (int)m_idleTimer.GetElapsedSeconds();
+}
+
+float CApplication::NavigationIdleTime()
+{
+  if (!m_navigationTimer.IsRunning())
+    m_navigationTimer.StartZero();
+  return m_navigationTimer.GetElapsedSeconds();
+}
+
+void CApplication::DelayedPlayerRestart()
+{
+  m_restartPlayerTimer.StartZero();
+}
+
+void CApplication::CheckDelayedPlayerRestart()
+{
+  if (m_restartPlayerTimer.GetElapsedSeconds() > 3)
+  {
+    m_restartPlayerTimer.Stop();
+    m_restartPlayerTimer.Reset();
+    Restart(true);
+  }
+}
+
+void CApplication::Restart(bool bSamePosition)
+{
+  // this function gets called when the user changes a setting (like noninterleaved)
+  // and which means we gotta close & reopen the current playing file
+
+  // first check if we're playing a file
+  if ( !m_pPlayer->IsPlayingVideo() && !m_pPlayer->IsPlayingAudio())
+    return ;
+
+  if( !m_pPlayer->HasPlayer() )
+    return ;
+
+  SaveFileState();
+
+  // do we want to return to the current position in the file
+  if (false == bSamePosition)
+  {
+    // no, then just reopen the file and start at the beginning
+    PlayFile(*m_itemCurrentFile, true);
+    return ;
+  }
+
+  // else get current position
+  double time = GetTime();
+
+  // get player state, needed for dvd's
+  std::string state = m_pPlayer->GetPlayerState();
+
+  // set the requested starttime
+  m_itemCurrentFile->m_lStartOffset = (long)(time * 75.0);
+
+  // reopen the file
+  if ( PlayFile(*m_itemCurrentFile, true) == PLAYBACK_OK )
+    m_pPlayer->SetPlayerState(state);
+}
+
+const std::string& CApplication::CurrentFile()
+{
+  return m_itemCurrentFile->GetPath();
+}
+
+CFileItem& CApplication::CurrentFileItem()
+{
+  return *m_itemCurrentFile;
+}
+
+CFileItem& CApplication::CurrentUnstackedItem()
+{
+  if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    return *(*m_currentStack)[m_currentStackPosition];
+  else
+    return *m_itemCurrentFile;
+}
+
+void CApplication::ShowVolumeBar(const CAction *action)
+{
+  CGUIDialog *volumeBar = (CGUIDialog *)g_windowManager.GetWindow(WINDOW_DIALOG_VOLUME_BAR);
+  if (volumeBar)
+  {
+    volumeBar->Show();
+    if (action)
+      volumeBar->OnAction(*action);
+  }
+}
+
+bool CApplication::IsMuted() const
+{
+  if (g_peripherals.IsMuted())
+    return true;
+  return CAEFactory::IsMuted();
+}
+
+void CApplication::ToggleMute(void)
+{
+  if (m_muted)
+    UnMute();
+  else
+    Mute();
+}
+
+void CApplication::SetMute(bool mute)
+{
+  if (m_muted != mute)
+  {
+    ToggleMute();
+    m_muted = mute;
+  }
+}
+
+void CApplication::Mute()
+{
+  if (g_peripherals.Mute())
+    return;
+
+  CAEFactory::SetMute(true);
+  m_muted = true;
+  VolumeChanged();
+}
+
+void CApplication::UnMute()
+{
+  if (g_peripherals.UnMute())
+    return;
+
+  CAEFactory::SetMute(false);
+  m_muted = false;
+  VolumeChanged();
+}
+
+void CApplication::SetVolume(float iValue, bool isPercentage/*=true*/)
+{
+  float hardwareVolume = iValue;
+
+  if(isPercentage)
+    hardwareVolume /= 100.0f;
+
+  SetHardwareVolume(hardwareVolume);
+  VolumeChanged();
+}
+
+void CApplication::SetHardwareVolume(float hardwareVolume)
+{
+  hardwareVolume = std::max(VOLUME_MINIMUM, std::min(VOLUME_MAXIMUM, hardwareVolume));
+  m_volumeLevel = hardwareVolume;
+
+  CAEFactory::SetVolume(hardwareVolume);
+}
+
+float CApplication::GetVolume(bool percentage /* = true */) const
+{
+  if (percentage)
+  {
+    // converts the hardware volume to a percentage
+    return m_volumeLevel * 100.0f;
+  }
+  
+  return m_volumeLevel;
+}
+
+void CApplication::VolumeChanged() const
+{
+  CVariant data(CVariant::VariantTypeObject);
+  data["volume"] = GetVolume();
+  data["muted"] = m_muted;
+  CAnnouncementManager::Get().Announce(Application, "xbmc", "OnVolumeChanged", data);
+
+  // if player has volume control, set it.
+  if (m_pPlayer->ControlsVolume())
+  {
+     m_pPlayer->SetVolume(m_volumeLevel);
+     m_pPlayer->SetMute(m_muted);
+  }
+}
+
+int CApplication::GetSubtitleDelay() const
+{
+  // converts subtitle delay to a percentage
+  return int(((float)(CMediaSettings::Get().GetCurrentVideoSettings().m_SubtitleDelay + g_advancedSettings.m_videoSubsDelayRange)) / (2 * g_advancedSettings.m_videoSubsDelayRange)*100.0f + 0.5f);
+}
+
+int CApplication::GetAudioDelay() const
+{
+  // converts audio delay to a percentage
+  return int(((float)(CMediaSettings::Get().GetCurrentVideoSettings().m_AudioDelay + g_advancedSettings.m_videoAudioDelayRange)) / (2 * g_advancedSettings.m_videoAudioDelayRange)*100.0f + 0.5f);
+}
+
+// Returns the total time in seconds of the current media.  Fractional
+// portions of a second are possible - but not necessarily supported by the
+// player class.  This returns a double to be consistent with GetTime() and
+// SeekTime().
+double CApplication::GetTotalTime() const
+{
+  double rc = 0.0;
+
+  if (m_pPlayer->IsPlaying())
+  {
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+      rc = (*m_currentStack)[m_currentStack->Size() - 1]->m_lEndOffset;
+    else
+      rc = static_cast<double>(m_pPlayer->GetTotalTime() * 0.001f);
+  }
+
+  return rc;
+}
+
+void CApplication::StopShutdownTimer()
+{
+  m_shutdownTimer.Stop();
+}
+
+void CApplication::ResetShutdownTimers()
+{
+  // reset system shutdown timer
+  m_shutdownTimer.StartZero();
+
+  // delete custom shutdown timer
+  if (g_alarmClock.HasAlarm("shutdowntimer"))
+    g_alarmClock.Stop("shutdowntimer", true);
+}
+
+// Returns the current time in seconds of the currently playing media.
+// Fractional portions of a second are possible.  This returns a double to
+// be consistent with GetTotalTime() and SeekTime().
+double CApplication::GetTime() const
+{
+  double rc = 0.0;
+
+  if (m_pPlayer->IsPlaying())
+  {
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      long startOfCurrentFile = (m_currentStackPosition > 0) ? (*m_currentStack)[m_currentStackPosition-1]->m_lEndOffset : 0;
+      rc = (double)startOfCurrentFile + m_pPlayer->GetDisplayTime() * 0.001;
+    }
+    else
+      rc = static_cast<double>(m_pPlayer->GetDisplayTime() * 0.001f);
+  }
+
+  return rc;
+}
+
+// Sets the current position of the currently playing media to the specified
+// time in seconds.  Fractional portions of a second are valid.  The passed
+// time is the time offset from the beginning of the file as opposed to a
+// delta from the current position.  This method accepts a double to be
+// consistent with GetTime() and GetTotalTime().
+void CApplication::SeekTime( double dTime )
+{
+  if (m_pPlayer->IsPlaying() && (dTime >= 0.0))
+  {
+    if (!m_pPlayer->CanSeek()) return;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      // find the item in the stack we are seeking to, and load the new
+      // file if necessary, and calculate the correct seek within the new
+      // file.  Otherwise, just fall through to the usual routine if the
+      // time is higher than our total time.
+      for (int i = 0; i < m_currentStack->Size(); i++)
+      {
+        if ((*m_currentStack)[i]->m_lEndOffset > dTime)
+        {
+          long startOfNewFile = (i > 0) ? (*m_currentStack)[i-1]->m_lEndOffset : 0;
+          if (m_currentStackPosition == i)
+            m_pPlayer->SeekTime((int64_t)((dTime - startOfNewFile) * 1000.0));
+          else
+          { // seeking to a new file
+            m_currentStackPosition = i;
+            CFileItem item(*(*m_currentStack)[i]);
+            item.m_lStartOffset = (long)((dTime - startOfNewFile) * 75.0);
+            // don't just call "PlayFile" here, as we are quite likely called from the
+            // player thread, so we won't be able to delete ourselves.
+            CApplicationMessenger::Get().PlayFile(item, true);
+          }
+          return;
+        }
+      }
+    }
+    // convert to milliseconds and perform seek
+    m_pPlayer->SeekTime( static_cast<int64_t>( dTime * 1000.0 ) );
+  }
+}
+
+float CApplication::GetPercentage() const
+{
+  if (m_pPlayer->IsPlaying())
+  {
+    if (m_pPlayer->GetTotalTime() == 0 && m_pPlayer->IsPlayingAudio() && m_itemCurrentFile->HasMusicInfoTag())
+    {
+      const CMusicInfoTag& tag = *m_itemCurrentFile->GetMusicInfoTag();
+      if (tag.GetDuration() > 0)
+        return (float)(GetTime() / tag.GetDuration() * 100);
+    }
+
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      double totalTime = GetTotalTime();
+      if (totalTime > 0.0f)
+        return (float)(GetTime() / totalTime * 100);
+    }
+    else
+      return m_pPlayer->GetPercentage();
+  }
+  return 0.0f;
+}
+
+float CApplication::GetCachePercentage() const
+{
+  if (m_pPlayer->IsPlaying())
+  {
+    // Note that the player returns a relative cache percentage and we want an absolute percentage
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+    {
+      float stackedTotalTime = (float) GetTotalTime();
+      // We need to take into account the stack's total time vs. currently playing file's total time
+      if (stackedTotalTime > 0.0f)
+        return min( 100.0f, GetPercentage() + (m_pPlayer->GetCachePercentage() * m_pPlayer->GetTotalTime() * 0.001f / stackedTotalTime ) );
+    }
+    else
+      return min( 100.0f, m_pPlayer->GetPercentage() + m_pPlayer->GetCachePercentage() );
+  }
+  return 0.0f;
+}
+
+void CApplication::SeekPercentage(float percent)
+{
+  if (m_pPlayer->IsPlaying() && (percent >= 0.0))
+  {
+    if (!m_pPlayer->CanSeek()) return;
+    if (m_itemCurrentFile->IsStack() && m_currentStack->Size() > 0)
+      SeekTime(percent * 0.01 * GetTotalTime());
+    else
+      m_pPlayer->SeekPercentage(percent);
+  }
+}
+
+// SwitchToFullScreen() returns true if a switch is made, else returns false
+bool CApplication::SwitchToFullScreen(bool force /* = false */)
+{
+  // if playing from the video info window, close it first!
+  if (g_windowManager.HasModalDialog() && g_windowManager.GetTopMostModalDialogID() == WINDOW_DIALOG_VIDEO_INFO)
+  {
+    CGUIDialogVideoInfo* pDialog = (CGUIDialogVideoInfo*)g_windowManager.GetWindow(WINDOW_DIALOG_VIDEO_INFO);
+    if (pDialog) pDialog->Close(true);
+  }
+
+  // don't switch if the slideshow is active
+  if (g_windowManager.GetActiveWindow() == WINDOW_SLIDESHOW)
+    return false;
+
+  int windowID = WINDOW_INVALID;
+  // See if we're playing a video, and are in GUI mode
+  if (m_pPlayer->IsPlayingVideo() && g_windowManager.GetActiveWindow() != WINDOW_FULLSCREEN_VIDEO)
+    windowID = WINDOW_FULLSCREEN_VIDEO;
+
+  // special case for switching between GUI & visualisation mode. (only if we're playing an audio song)
+  if (m_pPlayer->IsPlayingAudio() && g_windowManager.GetActiveWindow() != WINDOW_VISUALISATION)
+    windowID = WINDOW_VISUALISATION;
+
+
+  if (windowID != WINDOW_INVALID)
+  {
+    if (force)
+      g_windowManager.ForceActivateWindow(windowID);
+    else
+      g_windowManager.ActivateWindow(windowID);
+    return true;
+  }
+
+  return false;
+}
+
+void CApplication::Minimize()
+{
+  g_Windowing.Minimize();
+}
+
+PLAYERCOREID CApplication::GetCurrentPlayer()
+{
+  return m_pPlayer->GetCurrentPlayer();
+}
+
+void CApplication::UpdateLibraries()
+{
+  if (CSettings::Get().GetBool("videolibrary.updateonstartup"))
+  {
+    CLog::LogF(LOGNOTICE, "Starting video library startup scan");
+    StartVideoScan("", !CSettings::Get().GetBool("videolibrary.backgroundupdate"));
+  }
+
+  if (CSettings::Get().GetBool("musiclibrary.updateonstartup"))
+  {
+    CLog::LogF(LOGNOTICE, "Starting music library startup scan");
+    StartMusicScan("", !CSettings::Get().GetBool("musiclibrary.backgroundupdate"));
+  }
+}
+
+bool CApplication::IsVideoScanning() const
+{
+  return CVideoLibraryQueue::Get().IsScanningLibrary();
+}
+
+bool CApplication::IsMusicScanning() const
+{
+  return m_musicInfoScanner->IsScanning();
+}
+
+void CApplication::StopVideoScan()
+{
+  CVideoLibraryQueue::Get().StopLibraryScanning();
+}
+
+void CApplication::StopMusicScan()
+{
+  if (m_musicInfoScanner->IsScanning())
+    m_musicInfoScanner->Stop();
+}
+
+void CApplication::StartVideoCleanup(bool userInitiated /* = true */)
+{
+  if (userInitiated && CVideoLibraryQueue::Get().IsRunning())
+    return;
+
+  std::set<int> paths;
+  if (userInitiated)
+    CVideoLibraryQueue::Get().CleanLibraryModal(paths);
+  else
+    CVideoLibraryQueue::Get().CleanLibrary(paths, true);
+}
+
+void CApplication::StartVideoScan(const std::string &strDirectory, bool userInitiated /* = true */, bool scanAll /* = false */)
+{
+  CVideoLibraryQueue::Get().ScanLibrary(strDirectory, scanAll, userInitiated);
+}
+
+void CApplication::StartMusicCleanup(bool userInitiated /* = true */)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  if (userInitiated)
+    m_musicInfoScanner->CleanDatabase(true);
+  else
+  {
+    m_musicInfoScanner->ShowDialog(false);
+    m_musicInfoScanner->StartCleanDatabase();
+  }
+}
+
+void CApplication::StartMusicScan(const std::string &strDirectory, bool userInitiated /* = true */, int flags /* = 0 */)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  if (!flags)
+  { // setup default flags
+    if (CSettings::Get().GetBool("musiclibrary.downloadinfo"))
+      flags |= CMusicInfoScanner::SCAN_ONLINE;
+    if (!userInitiated || CSettings::Get().GetBool("musiclibrary.backgroundupdate"))
+      flags |= CMusicInfoScanner::SCAN_BACKGROUND;
+  }
+
+  if (!(flags & CMusicInfoScanner::SCAN_BACKGROUND))
+    m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->Start(strDirectory, flags);
+}
+
+void CApplication::StartMusicAlbumScan(const std::string& strDirectory,
+                                       bool refresh)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->FetchAlbumInfo(strDirectory,refresh);
+}
+
+void CApplication::StartMusicArtistScan(const std::string& strDirectory,
+                                        bool refresh)
+{
+  if (m_musicInfoScanner->IsScanning())
+    return;
+
+  m_musicInfoScanner->ShowDialog(true);
+
+  m_musicInfoScanner->FetchArtistInfo(strDirectory,refresh);
+}
+
+void CApplication::CheckPlayingProgress()
+{
+  // check if we haven't rewound past the start of the file
+  if (m_pPlayer->IsPlaying())
+  {
+    int iSpeed = g_application.m_pPlayer->GetPlaySpeed();
+    if (iSpeed < 1)
+    {
+      iSpeed *= -1;
+      int iPower = 0;
+      while (iSpeed != 1)
+      {
+        iSpeed >>= 1;
+        iPower++;
+      }
+      if (g_infoManager.GetPlayTime() / 1000 < iPower)
+      {
+        g_application.m_pPlayer->SetPlaySpeed(1, g_application.m_muted);
+        g_application.SeekTime(0);
+      }
+    }
+  }
+}
+
+bool CApplication::ProcessAndStartPlaylist(const std::string& strPlayList, CPlayList& playlist, int iPlaylist, int track)
+{
+  CLog::Log(LOGDEBUG,"CApplication::ProcessAndStartPlaylist(%s, %i)",strPlayList.c_str(), iPlaylist);
+
+  // initial exit conditions
+  // no songs in playlist just return
+  if (playlist.size() == 0)
+    return false;
+
+  // illegal playlist
+  if (iPlaylist < PLAYLIST_MUSIC || iPlaylist > PLAYLIST_VIDEO)
+    return false;
+
+  // setup correct playlist
+  g_playlistPlayer.ClearPlaylist(iPlaylist);
+
+  // if the playlist contains an internet stream, this file will be used
+  // to generate a thumbnail for musicplayer.cover
+  g_application.m_strPlayListFile = strPlayList;
+
+  // add the items to the playlist player
+  g_playlistPlayer.Add(iPlaylist, playlist);
+
+  // if we have a playlist
+  if (g_playlistPlayer.GetPlaylist(iPlaylist).size())
+  {
+    // start playing it
+    g_playlistPlayer.SetCurrentPlaylist(iPlaylist);
+    g_playlistPlayer.Reset();
+    g_playlistPlayer.Play(track);
+    return true;
+  }
+  return false;
+}
+
+bool CApplication::IsCurrentThread() const
+{
+  return CThread::IsCurrentThread(m_threadID);
+}
+
+void CApplication::SetRenderGUI(bool renderGUI)
+{
+  if (renderGUI && ! m_renderGUI)
+    g_windowManager.MarkDirty();
+  m_renderGUI = renderGUI;
+}
+
+CNetwork& CApplication::getNetwork()
+{
+  return *m_network;
+}
+#ifdef HAS_PERFORMANCE_SAMPLE
+CPerformanceStats &CApplication::GetPerformanceStats()
+{
+  return m_perfStats;
+}
+#endif
+
+bool CApplication::SetLanguage(const std::string &strLanguage)
+{
+  // nothing to be done if the language hasn't changed
+  if (strLanguage == CSettings::Get().GetString("locale.language"))
+    return true;
+
+  return CSettings::Get().SetString("locale.language", strLanguage);
+}
+
+bool CApplication::LoadLanguage(bool reload)
+{
+  // load the configured langauge
+  if (!g_langInfo.SetLanguage(m_fallbackLanguageLoaded, "", reload))
+    return false;
+
+  // set the proper audio and subtitle languages
+  g_langInfo.SetAudioLanguage(CSettings::Get().GetString("locale.audiolanguage"));
+  g_langInfo.SetSubtitleLanguage(CSettings::Get().GetString("locale.subtitlelanguage"));
+
+  return true;
+}
+
+void CApplication::CloseNetworkShares()
+{
+  CLog::Log(LOGDEBUG,"CApplication::CloseNetworkShares: Closing all network shares");
+
+#if defined(HAS_FILESYSTEM_SMB) && !defined(TARGET_WINDOWS)
+  smb.Deinit();
+#endif
+  
+#ifdef HAS_FILESYSTEM_NFS
+  gNfsConnection.Deinit();
+#endif
+
+#ifdef HAS_FILESYSTEM_SFTP
+  CSFTPSessionManager::DisconnectAllSessions();
+#endif
+}
+
+void CApplication::RegisterActionListener(IActionListener *listener)
+{
+  CSingleLock lock(m_critSection);
+  std::vector<IActionListener *>::iterator it = std::find(m_actionListeners.begin(), m_actionListeners.end(), listener);
+  if (it == m_actionListeners.end())
+    m_actionListeners.push_back(listener);
+}
+
+void CApplication::UnregisterActionListener(IActionListener *listener)
+{
+  CSingleLock lock(m_critSection);
+  std::vector<IActionListener *>::iterator it = std::find(m_actionListeners.begin(), m_actionListeners.end(), listener);
+  if (it != m_actionListeners.end())
+    m_actionListeners.erase(it);
+}
+
+bool CApplication::NotifyActionListeners(const CAction &action) const
+{
+  CSingleLock lock(m_critSection);
+  for (std::vector<IActionListener *>::const_iterator it = m_actionListeners.begin(); it != m_actionListeners.end(); ++it)
+  {
+    if ((*it)->OnAction(action))
+      return true;
+  }
+  
+  return false;
+}
diff -Naur c/xbmc/Application.h d/xbmc/Application.h
--- c/xbmc/Application.h	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/Application.h	2016-04-06 18:32:36.000000000 +0300
@@ -384,6 +384,8 @@
    */
   void UnregisterActionListener(IActionListener *listener);
 
+  bool ScreenSaverDisablesAutoScrolling();
+
 protected:
   virtual bool OnSettingsSaving() const;
 
diff -Naur c/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp d/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp
--- c/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResampleFFMPEG.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -20,6 +20,7 @@
 
 #include "cores/AudioEngine/Utils/AEUtil.h"
 #include "ActiveAEResampleFFMPEG.h"
+#include "settings/Settings.h"
 #include "utils/log.h"
 
 extern "C" {
@@ -105,6 +106,12 @@
   {
      av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff -Naur c/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp d/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp
--- c/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/AudioEngine/Engines/ActiveAE/ActiveAEResamplePi.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -164,6 +164,12 @@
   {
     av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
   }
+  int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+  if (boost_center)
+  {
+    float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+    av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+  }
 
   if (remapLayout)
   {
diff -Naur c/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp d/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp
--- c/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/AudioEngine/Sinks/AESinkALSA.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -1342,6 +1342,10 @@
     if (snd_card_get_name(cardNr, &cardName) == 0)
       info.m_displayName = cardName;
 
+    // hack: hifiberry digi doesn't correctly report as iec958 device. Needs fixing in kernel driver
+    if (info.m_displayName == "snd_rpi_hifiberry_digi")
+      info.m_deviceType = AE_DEVTYPE_IEC958;
+
     if (info.m_deviceType == AE_DEVTYPE_HDMI && info.m_displayName.size() > 5 &&
         info.m_displayName.substr(info.m_displayName.size()-5) == " HDMI")
     {
diff -Naur c/xbmc/cores/AudioEngine/Utils/AEUtil.h d/xbmc/cores/AudioEngine/Utils/AEUtil.h
--- c/xbmc/cores/AudioEngine/Utils/AEUtil.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/AudioEngine/Utils/AEUtil.h	2016-04-06 18:32:36.000000000 +0300
@@ -57,7 +57,8 @@
 {
   SYNC_DISCON   = 0,
   SYNC_SKIPDUP,
-  SYNC_RESAMPLE
+  SYNC_RESAMPLE,
+  SYNC_PLLADJUST
 };
 
 struct AEDelayStatus
diff -Naur c/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp d/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp
--- c/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDCodecs/DVDFactoryCodec.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -50,6 +50,9 @@
 #include "Video/DVDVideoCodecAndroidMediaCodec.h"
 #include "android/activity/AndroidFeatures.h"
 #endif
+#if defined(HAS_MMAL)
+#include "linux/RBP.h"
+#endif
 #include "Audio/DVDAudioCodecFFmpeg.h"
 #include "Audio/DVDAudioCodecPassthrough.h"
 #include "Overlay/DVDOverlayCodecSSA.h"
@@ -201,6 +204,10 @@
 #endif
   CLog::Log(LOGDEBUG, "CDVDFactoryCodec: compiled in hardware support: %s", hwSupport.c_str());
 
+#if defined(HAS_MMAL)
+  // mmal can handle dvd playback including stills
+  if (!CSettings::Get().GetBool("videoplayer.usemmal") || !g_RBP.GetCodecMpg2())
+#endif
   if (hint.stills && (hint.codec == AV_CODEC_ID_MPEG2VIDEO || hint.codec == AV_CODEC_ID_MPEG1VIDEO))
   {
      // If dvd is an mpeg2 and hint.stills
diff -Naur c/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp d/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp
--- c/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -106,8 +106,8 @@
 
   m_interlace_mode = MMAL_InterlaceProgressive;
   m_interlace_method = VS_INTERLACEMETHOD_NONE;
-  m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
+  m_demuxerPts = DVD_NOPTS_VALUE;
 
   m_dec = NULL;
   m_dec_input = NULL;
@@ -124,6 +124,7 @@
   m_es_format = mmal_format_alloc();
   m_preroll = true;
   m_speed = DVD_PLAYSPEED_NORMAL;
+  m_codecControlFlags = 0;
 }
 
 CMMALVideo::~CMMALVideo()
@@ -252,12 +253,20 @@
   {
     if (buffer->length > 0)
     {
+      if (buffer->pts != MMAL_TIME_UNKNOWN)
+        m_decoderPts = buffer->pts;
+      else if (buffer->dts != MMAL_TIME_UNKNOWN)
+        m_decoderPts = buffer->dts;
+
       assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_DECODEONLY));
+      CMMALVideoBuffer *omvb = NULL;
+      if (!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_CORRUPTED));
+        omvb = new CMMALVideoBuffer(this);
+      if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+        CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x",
+          CLASSNAME, __func__, buffer, omvb, buffer->length, buffer->dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags);
+      if (omvb)
       {
-        CMMALVideoBuffer *omvb = new CMMALVideoBuffer(this);
-        if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-          CLog::Log(LOGDEBUG, "%s::%s - %p (%p) buffer_size(%u) dts:%.3f pts:%.3f flags:%x:%x",
-            CLASSNAME, __func__, buffer, omvb, buffer->length, buffer->dts*1e-6, buffer->pts*1e-6, buffer->flags, buffer->type->video.flags);
         omvb->mmal_buffer = buffer;
         buffer->user_data = (void *)omvb;
         omvb->width = m_decoded_width;
@@ -346,12 +355,11 @@
     CLog::Log(LOGERROR, "%s::%s Failed to create deinterlace component (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
     return false;
   }
-  bool advanced_deinterlace = (interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED || interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF) &&
-      m_decoded_width * m_decoded_height <= 576 * 720;
+  bool advanced_deinterlace = interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED || interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF;
   bool half_framerate = interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF || interlace_method == VS_INTERLACEMETHOD_MMAL_BOB_HALF;
 
   MMAL_PARAMETER_IMAGEFX_PARAMETERS_T imfx_param = {{MMAL_PARAMETER_IMAGE_EFFECT_PARAMETERS, sizeof(imfx_param)},
-        advanced_deinterlace ? MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV : MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST, 3, {3, 0, half_framerate }};
+        advanced_deinterlace ? MMAL_PARAM_IMAGEFX_DEINTERLACE_ADV : MMAL_PARAM_IMAGEFX_DEINTERLACE_FAST, 4, {3, 0, half_framerate, 1 }};
 
   status = mmal_port_parameter_set(m_deint->output[0], &imfx_param.hdr);
   if (status != MMAL_SUCCESS)
@@ -515,6 +523,8 @@
   // we always qualify even if DVDFactoryCodec does this too.
   if (!CSettings::Get().GetBool("videoplayer.usemmal") || hints.software)
     return false;
+  if (hints.workaround_bugs & FF_BUG_GMC_UNSUPPORTED)
+    return false;
 
   m_hints = hints;
   m_vout_input_pool = (MMAL_POOL_T *)options.m_opaque_pointer;
@@ -536,6 +546,11 @@
       // H.264
       m_codingType = MMAL_ENCODING_H264;
       m_pFormatName = "mmal-h264";
+      if (CSettings::Get().GetBool("videoplayer.supportmvc"))
+      {
+        m_codingType = MMAL_ENCODING_MVC;
+        m_pFormatName= "mmal-mvc";
+      }
     break;
     case AV_CODEC_ID_H263:
     case AV_CODEC_ID_MPEG4:
@@ -621,6 +636,11 @@
     m_dec_input->format->es->video.width = ALIGN_UP(m_hints.width, 32);
     m_dec_input->format->es->video.height = ALIGN_UP(m_hints.height, 16);
   }
+  if (hints.fpsrate > 0 && hints.fpsscale > 0)
+  {
+    m_dec_input->format->es->video.frame_rate.num = hints.fpsrate;
+    m_dec_input->format->es->video.frame_rate.den = hints.fpsscale;
+  }
   m_dec_input->format->flags |= MMAL_ES_FORMAT_FLAG_FRAMED;
 
   error_concealment.hdr.id = MMAL_PARAMETER_VIDEO_DECODE_ERROR_CONCEALMENT;
@@ -634,7 +654,7 @@
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to enable extra buffers on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
-  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, 0);
+  status = mmal_port_parameter_set_uint32(m_dec_input, MMAL_PARAMETER_VIDEO_INTERPOLATE_TIMESTAMPS, 1);
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to disable interpolate timestamps mode on %s (status=%x %s)", CLASSNAME, __func__, m_dec_input->name, status, mmal_status_to_string(status));
 
@@ -700,7 +720,6 @@
     return false;
 
   Prime();
-  m_startframe = false;
   m_preroll = !m_hints.stills;
   m_speed = DVD_PLAYSPEED_NORMAL;
 
@@ -787,11 +806,9 @@
 
        mmal_buffer_header_reset(buffer);
        buffer->cmd = 0;
-       if (!m_startframe && pts == DVD_NOPTS_VALUE)
-         pts = 0;
        buffer->pts = pts == DVD_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : pts;
        buffer->dts = dts == DVD_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : dts;
-       if (buffer->dts != MMAL_TIME_UNKNOWN) buffer->pts = MMAL_TIME_UNKNOWN;
+       if (m_hints.ptsinvalid) buffer->pts = MMAL_TIME_UNKNOWN;
        buffer->length = demuxer_bytes > buffer->alloc_size ? buffer->alloc_size : demuxer_bytes;
        // set a flag so we can identify primary frames from generated frames (deinterlace)
        buffer->flags = MMAL_BUFFER_HEADER_FLAG_USER0;
@@ -816,14 +833,19 @@
 
        if (demuxer_bytes == 0)
        {
-         pthread_mutex_lock(&m_output_mutex);
-         m_startframe = true;
-         pthread_mutex_unlock(&m_output_mutex);
          EDEINTERLACEMODE deinterlace_request = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
          EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
-
          bool deinterlace = m_interlace_mode != MMAL_InterlaceProgressive;
 
+         // we don't keep up when running at 60fps in the background so switch to half rate
+         if (!g_graphicsContext.IsFullScreenVideo())
+         {
+           if (interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
+             interlace_method = VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF;
+           if (interlace_method == VS_INTERLACEMETHOD_MMAL_BOB)
+             interlace_method = VS_INTERLACEMETHOD_MMAL_BOB_HALF;
+         }
+
          if (m_hints.stills || deinterlace_request == VS_DEINTERLACEMODE_OFF || interlace_method == VS_INTERLACEMETHOD_NONE)
            deinterlace = false;
          else if (deinterlace_request == VS_DEINTERLACEMODE_FORCE)
@@ -846,33 +868,38 @@
     if (!demuxer_bytes)
       break;
   }
-  int ret = 0;
-  double queued = m_decoderPts != DVD_NOPTS_VALUE && pts != DVD_NOPTS_VALUE ? pts - m_decoderPts : 0.0;
-  if (mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length && queued <= DVD_MSEC_TO_TIME(500))
-  {
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - got space for output: demux_queue(%d) space(%d) queued(%.2f)", CLASSNAME, __func__, m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, queued*1e-6);
-    ret |= VC_BUFFER;
-  }
-  else
-    m_preroll = false;
+  if (pts != DVD_NOPTS_VALUE)
+    m_demuxerPts = pts;
+  else if (dts != DVD_NOPTS_VALUE)
+    m_demuxerPts = dts;
+
+  if (m_demuxerPts != DVD_NOPTS_VALUE && m_decoderPts == DVD_NOPTS_VALUE)
+    m_decoderPts = m_demuxerPts;
+
+  // we've built up quite a lot of data in decoder - try to throttle it
+  double queued = m_decoderPts != DVD_NOPTS_VALUE && m_demuxerPts != DVD_NOPTS_VALUE ? m_demuxerPts - m_decoderPts : 0.0;
+  bool full = queued > DVD_MSEC_TO_TIME(1000);
+  bool want_buffer = mmal_queue_length(m_dec_input_pool->queue) > 0 && !m_demux_queue_length && !full;
+  int ret = VC_BUFFER;
 
-  if (m_preroll && m_output_ready.size() >= GetAllowedReferences())
+  if (m_preroll && (!want_buffer || m_output_ready.size() >= GetAllowedReferences()))
     m_preroll = false;
 
   if (!m_output_ready.empty() && !m_preroll)
   {
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s -  got output picture:%d", CLASSNAME, __func__, m_output_ready.size());
     ret |= VC_PICTURE;
+    // renderer is low - give priority to returning pictures
+    if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN || !want_buffer || full)
+      ret &= ~VC_BUFFER;
   }
-  if (!ret)
+
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "%s::%s - ret(%x) pics(%d) demux_queue(%d) space(%d) queued(%.2f) (%.2f:%.2f) preroll(%d) flags(%x) full(%d)", CLASSNAME, __func__, ret, m_output_ready.size(), m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, queued*1e-6, m_demuxerPts*1e-6, m_decoderPts*1e-6, m_preroll, m_codecControlFlags, full);
+
+  if (full)
   {
-    if (g_advancedSettings.CanLogComponent(LOGVIDEO))
-      CLog::Log(LOGDEBUG, "%s::%s - Nothing to do: ready_queue(%d) demux_queue(%d) space(%d) preroll(%d)",
-        CLASSNAME, __func__, m_output_ready.size(), m_demux_queue_length, mmal_queue_length(m_dec_input_pool->queue) * m_dec_input->buffer_size, m_preroll);
     lock.Leave();
-    Sleep(10); // otherwise we busy spin
+    Sleep(queued * 1e-6 * 10.0);
   }
   return ret;
 }
@@ -940,9 +967,10 @@
     SendCodecConfigData();
     Prime();
   }
-  m_startframe = false;
   m_decoderPts = DVD_NOPTS_VALUE;
+  m_demuxerPts = DVD_NOPTS_VALUE;
   m_preroll = !m_hints.stills && (m_speed == DVD_PLAYSPEED_NORMAL || m_speed == DVD_PLAYSPEED_PAUSE);
+  m_codecControlFlags = 0;
 }
 
 void CMMALVideo::SetSpeed(int iSpeed)
@@ -1031,11 +1059,6 @@
     return false;
   }
 
-  if (pDvdVideoPicture->pts != DVD_NOPTS_VALUE)
-    m_decoderPts = pDvdVideoPicture->pts;
-  else
-    m_decoderPts = pDvdVideoPicture->dts; // xxx is DVD_NOPTS_VALUE better?
-
   return true;
 }
 
@@ -1058,3 +1081,11 @@
   droppedPics= -1;
   return false;
 }
+
+void CMMALVideo::SetCodecControl(int flags)
+{
+  CSingleLock lock(m_sharedSection);
+  m_codecControlFlags = flags;
+  if (g_advancedSettings.CanLogComponent(LOGVIDEO))
+    CLog::Log(LOGDEBUG, "%s::%s flags:%x", CLASSNAME, __func__, flags);
+}
diff -Naur c/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h d/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h
--- c/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDCodecs/Video/MMALCodec.h	2016-04-06 18:32:36.000000000 +0300
@@ -86,6 +86,7 @@
   virtual void SetDropState(bool bDrop);
   virtual const char* GetName(void) { return m_pFormatName ? m_pFormatName:"mmal-xxx"; }
   virtual bool GetCodecStats(double &pts, int &droppedPics);
+  virtual void SetCodecControl(int flags);
   virtual void SetSpeed(int iSpeed);
 
   // MMAL decoder callback routines.
@@ -126,10 +127,11 @@
   // Components
   MMAL_INTERLACETYPE_T m_interlace_mode;
   EINTERLACEMETHOD  m_interlace_method;
-  bool              m_startframe;
+  double            m_demuxerPts;
   double            m_decoderPts;
   int               m_speed;
   bool              m_preroll;
+  int               m_codecControlFlags;
 
   CCriticalSection m_sharedSection;
   MMAL_COMPONENT_T *m_dec;
diff -Naur c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp
--- c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxFFmpeg.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -738,7 +738,7 @@
           {
             if(m_pkt.pkt.stream_index == (int)m_pFormatContext->programs[m_program]->stream_index[i])
             {
-              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+              pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
               break;
             }
           }
@@ -747,7 +747,7 @@
             bReturnEmpty = true;
         }
         else
-          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(m_pkt.pkt.size);
+          pPacket = CDVDDemuxUtils::AllocateDemuxPacket(0);
       }
       else
         bReturnEmpty = true;
@@ -789,9 +789,13 @@
         // copy contents into our own packet
         pPacket->iSize = m_pkt.pkt.size;
 
-        // maybe we can avoid a memcpy here by detecting where pkt.destruct is pointing too?
         if (m_pkt.pkt.data)
-          memcpy(pPacket->pData, m_pkt.pkt.data, pPacket->iSize);
+        {
+          pPacket->pData = m_pkt.pkt.data;
+          // so we can free AVPacket when DemuxPacket is freed
+          pPacket->pkt = new AVPacket(m_pkt.pkt);
+        }
+
 
         pPacket->pts = ConvertTimestamp(m_pkt.pkt.pts, stream->time_base.den, stream->time_base.num);
         pPacket->dts = ConvertTimestamp(m_pkt.pkt.dts, stream->time_base.den, stream->time_base.num);
@@ -826,7 +830,7 @@
         pPacket->iStreamId = m_pkt.pkt.stream_index;
       }
       m_pkt.result = -1;
-      av_free_packet(&m_pkt.pkt);
+      memset(&m_pkt.pkt, 0, sizeof(AVPacket));
     }
   }
   } // end of lock scope
@@ -1184,7 +1188,7 @@
         if (!stereoMode.empty())
           st->stereo_mode = stereoMode;
 
-        
+        st->workaround_bugs = pStream->codec->workaround_bugs;
         if ( m_pInput->IsStreamType(DVDSTREAM_TYPE_DVD) )
         {
           if (pStream->codec->codec_id == AV_CODEC_ID_PROBE)
diff -Naur c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h
--- c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemux.h	2016-04-06 18:32:36.000000000 +0300
@@ -162,6 +162,7 @@
     type = STREAM_VIDEO;
     iOrientation = 0;
     iBitsPerPixel = 0;
+    workaround_bugs = 0;
   }
 
   virtual ~CDemuxStreamVideo() {}
@@ -178,6 +179,7 @@
   int iOrientation; // orientation of the video in degress counter clockwise
   int iBitsPerPixel;
   std::string stereo_mode; // expected stereo mode
+  int workaround_bugs; // info for decoder
 };
 
 class CDemuxStreamAudio : public CDemuxStream
diff -Naur c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h
--- c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxPacket.h	2016-04-06 18:32:36.000000000 +0300
@@ -23,6 +23,8 @@
 #define DMX_SPECIALID_STREAMINFO    -10
 #define DMX_SPECIALID_STREAMCHANGE  -11
 
+struct AVPacket;
+
  typedef struct DemuxPacket
 {
   unsigned char* pData;   // data
@@ -33,4 +35,5 @@
   double pts; // pts in DVD_TIME_BASE
   double dts; // dts in DVD_TIME_BASE
   double duration; // duration in DVD_TIME_BASE if available
+  AVPacket *pkt; // to allow packet to be freed
 } DemuxPacket;
diff -Naur c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp
--- c/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDDemuxers/DVDDemuxUtils.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -34,7 +34,12 @@
   if (pPacket)
   {
     try {
-      if (pPacket->pData) _aligned_free(pPacket->pData);
+      if (pPacket->pkt)
+      {
+        av_free_packet(pPacket->pkt);
+        delete pPacket->pkt;
+      }
+      else if (pPacket->pData) _aligned_free(pPacket->pData);
       delete pPacket;
     }
     catch(...) {
diff -Naur c/xbmc/cores/dvdplayer/DVDMessage.cpp d/xbmc/cores/dvdplayer/DVDMessage.cpp
--- c/xbmc/cores/dvdplayer/DVDMessage.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDMessage.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -91,7 +91,7 @@
 
 void CDVDMsgGeneralSynchronize::Wait(volatile bool *abort, unsigned int source)
 {
-  while(!Wait(100, source))
+  while(!Wait(200, source))
   {
     if(abort && *abort)
       return;
diff -Naur c/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp d/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp
--- c/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDPlayerAudio.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -24,6 +24,7 @@
 #include "DVDCodecs/Audio/DVDAudioCodec.h"
 #include "DVDCodecs/DVDFactoryCodec.h"
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "video/VideoReferenceClock.h"
 #include "utils/log.h"
 #include "utils/MathUtils.h"
@@ -111,6 +112,9 @@
   m_started = false;
   m_silence = false;
   m_resampleratio = 1.0;
+  m_plladjust = 1.0;
+  m_last_plladjust = 1.0;
+  m_last_error = 0.0;
   m_synctype = SYNC_DISCON;
   m_setsynctype = SYNC_DISCON;
   m_prevsynctype = -1;
@@ -184,11 +188,13 @@
   m_synctype = SYNC_DISCON;
   m_setsynctype = SYNC_DISCON;
   if (CSettings::Get().GetBool("videoplayer.usedisplayasclock"))
-    m_setsynctype = SYNC_RESAMPLE;
+    m_setsynctype = CSettings::Get().GetInt("videoplayer.synctype");
   m_prevsynctype = -1;
 
   m_error = 0;
   m_errors.Flush();
+  m_plladjust = 1.0;
+  m_last_plladjust = 1.0;
   m_integral = 0;
   m_prevskipped = false;
   m_syncclock = true;
@@ -231,7 +237,6 @@
 
   // uninit queue
   m_messageQueue.End();
-
   CLog::Log(LOGNOTICE, "Deleting audio codec");
   if (m_pAudioCodec)
   {
@@ -484,7 +489,11 @@
   //print the inverse of the resample ratio, since that makes more sense
   //if the resample ratio is 0.5, then we're playing twice as fast
   if (m_synctype == SYNC_RESAMPLE)
-    s << ", rr:" << fixed << setprecision(5) << 1.0 / m_resampleratio;
+    s << ", rr:" << fixed << setprecision(5) << 1.0 / m_resampleratio << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
+  if (m_synctype == SYNC_SKIPDUP)
+    s << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
+  if (m_synctype == SYNC_PLLADJUST)
+    s << ", pll:" << fixed << setprecision(5) << m_last_plladjust << ", err:" << fixed << setprecision(1) << m_last_error * 1e-3 << "ms";
 
   s << ", att:" << fixed << setprecision(1) << log(GetCurrentAttenuation()) * 20.0f << " dB";
 
@@ -639,8 +648,8 @@
 
   if (m_synctype != m_prevsynctype)
   {
-    const char *synctypes[] = {"clock feedback", "skip/duplicate", "resample", "invalid"};
-    int synctype = (m_synctype >= 0 && m_synctype <= 2) ? m_synctype : 3;
+    const char *synctypes[] = {"clock feedback", "skip/duplicate", "resample", "pll adjust", "invalid"};
+    int synctype = (m_synctype >= 0 && m_synctype <= 3) ? m_synctype : 4;
     CLog::Log(LOGDEBUG, "CDVDPlayerAudio:: synctype set to %i: %s", m_synctype, synctypes[synctype]);
     m_prevsynctype = m_synctype;
   }
@@ -750,7 +759,19 @@
       proportional = m_error / DVD_TIME_BASE / proportionaldiv;
     }
     m_resampleratio = 1.0 / m_pClock->GetClockSpeed() + proportional + m_integral;
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s rr:%.5f error:%.3fms", __FUNCTION__, m_resampleratio, m_error * 1e-3);
+  }
+  else if (m_synctype == SYNC_PLLADJUST)
+  {
+#if defined(TARGET_RASPBERRY_PI)
+    double e = std::max(std::min(m_error / DVD_MSEC_TO_TIME(50), 1.0), -1.0);
+    double adjust = g_advancedSettings.m_maxPllAdjust * 1e-6;
+    m_plladjust = 1.0 + e * adjust;
+    m_last_plladjust = g_RBP.AdjustHDMIClock(m_plladjust);
+    CLog::Log(LOGDEBUG, "CDVDPlayerAudio::%s pll:%.5f (%.5f) error:%.6f e:%.6f a:%f", __FUNCTION__, m_plladjust, m_last_plladjust, m_error, e * adjust, adjust );
+#endif
   }
+  m_last_error = m_error;
 }
 
 bool CDVDPlayerAudio::OutputPacket(DVDAudioFrame &audioframe)
@@ -803,6 +824,7 @@
     {
       m_dvdAudio.AddPackets(audioframe);
     }
+    m_plladjust = 1.0;
   }
   else if (m_synctype == SYNC_DISCON)
   {
@@ -837,6 +859,10 @@
     m_dvdAudio.SetResampleRatio(m_resampleratio);
     m_dvdAudio.AddPackets(audioframe);
   }
+  else if (m_synctype == SYNC_PLLADJUST)
+  {
+    m_dvdAudio.AddPackets(audioframe);
+  }
 
   return true;
 }
diff -Naur c/xbmc/cores/dvdplayer/DVDPlayerAudio.h d/xbmc/cores/dvdplayer/DVDPlayerAudio.h
--- c/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDPlayerAudio.h	2016-04-06 18:32:36.000000000 +0300
@@ -228,6 +228,9 @@
   bool   m_prevskipped;
   double m_maxspeedadjust;
   double m_resampleratio; //resample ratio when using SYNC_RESAMPLE, used for the codec info
+  double m_plladjust;    // for display using SYNC_PLLADJUST
+  double m_last_error;    // for display using SYNC_PLLADJUST
+  double m_last_plladjust;    // for display using SYNC_PLLADJUST
 
   struct SInfo
   {
diff -Naur c/xbmc/cores/dvdplayer/DVDPlayer.cpp d/xbmc/cores/dvdplayer/DVDPlayer.cpp
--- c/xbmc/cores/dvdplayer/DVDPlayer.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDPlayer.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -517,11 +517,13 @@
 
 void CDVDPlayer::CreatePlayers()
 {
+  CSingleLock lock(m_players_lock);
 #ifdef HAS_OMXPLAYER
-  if (m_omxplayer_mode && OMXPlayerUnsuitable(m_HasVideo, m_HasAudio, m_pDemuxer, m_pInputStream, m_SelectionStreams))
+  bool omx_suitable = !OMXPlayerUnsuitable(m_HasVideo, m_HasAudio, m_pDemuxer, m_pInputStream, m_SelectionStreams);
+  if (m_omxplayer_mode != omx_suitable)
   {
     DestroyPlayers();
-    m_omxplayer_mode = false;
+    m_omxplayer_mode = omx_suitable;
   }
 #endif
   if (m_players_created)
@@ -546,6 +548,7 @@
 
 void CDVDPlayer::DestroyPlayers()
 {
+  CSingleLock lock(m_players_lock);
   if (!m_players_created)
     return;
   delete m_dvdPlayerVideo;
@@ -3417,7 +3420,9 @@
       hint.aspect = aspect;
       hint.forced_aspect = true;
     }
+#ifndef TARGET_RASPBERRY_PI
     hint.software = true;
+#endif
   }
   else if (m_pInputStream && m_pInputStream->IsStreamType(DVDSTREAM_TYPE_PVRMANAGER))
   {
@@ -4249,6 +4254,7 @@
 
 void CDVDPlayer::GetVideoStreamInfo(SPlayerVideoStreamInfo &info)
 {
+  CSingleLock lock(m_players_lock);
   info.bitrate = m_dvdPlayerVideo->GetVideoBitrate();
 
   std::string retVal;
diff -Naur c/xbmc/cores/dvdplayer/DVDPlayer.h d/xbmc/cores/dvdplayer/DVDPlayer.h
--- c/xbmc/cores/dvdplayer/DVDPlayer.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDPlayer.h	2016-04-06 18:32:36.000000000 +0300
@@ -557,4 +557,5 @@
   // omxplayer variables
   struct SOmxPlayerState m_OmxPlayerState;
   bool m_omxplayer_mode;            // using omxplayer acceleration
+  CCriticalSection m_players_lock;
 };
diff -Naur c/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp d/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp
--- c/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDPlayerVideo.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -33,6 +33,7 @@
 #include "DVDCodecs/Video/DVDVideoPPFFmpeg.h"
 #include "DVDCodecs/Video/DVDVideoCodecFFmpeg.h"
 #include "DVDDemuxers/DVDDemux.h"
+#include "DVDDemuxers/DVDDemuxUtils.h"
 #include "DVDOverlayRenderer.h"
 #include "guilib/GraphicContext.h"
 #include <sstream>
@@ -314,7 +315,8 @@
 
   while (!m_bStop)
   {
-    int iQueueTimeOut = (int)(m_stalled ? frametime / 4 : frametime * 10) / 1000;
+    bool bPictureWaiting = m_hints.stills && (m_pVideoCodec->Decode(NULL, 0, DVD_NOPTS_VALUE, DVD_NOPTS_VALUE) & VC_PICTURE);
+    int iQueueTimeOut = (int)(bPictureWaiting ? 0 : (m_hints.stills || m_stalled) ? frametime / 4 : frametime * 10) / 1000;
     int iPriority = (m_speed == DVD_PLAYSPEED_PAUSE && m_started) ? 1 : 0;
 
     CDVDMsg* pMsg;
@@ -331,27 +333,36 @@
       if( iPriority )
         continue;
 
-      //Okey, start rendering at stream fps now instead, we are likely in a stillframe
-      if( !m_stalled )
+      // check for picture waiting
+      if (bPictureWaiting)
       {
-        if(m_started)
-          CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe detected, switching to forced %f fps", m_fFrameRate);
-        m_stalled = true;
-        pts+= frametime*4;
+        // create a dummy demuxer packet to prod the decode logic
+        pMsg = new CDVDMsgDemuxerPacket(CDVDDemuxUtils::AllocateDemuxPacket(0), false);
       }
-
-      //Waiting timed out, output last picture
-      if( picture.iFlags & DVP_FLAG_ALLOCATED )
+      else
       {
-        //Remove interlaced flag before outputting
-        //no need to output this as if it was interlaced
-        picture.iFlags &= ~DVP_FLAG_INTERLACED;
-        picture.iFlags |= DVP_FLAG_NOSKIP;
-        OutputPicture(&picture, pts);
-        pts+= frametime;
-      }
+        //Okey, start rendering at stream fps now instead, we are likely in a stillframe
+        if( !m_stalled )
+        {
+          if(m_started)
+            CLog::Log(LOGINFO, "CDVDPlayerVideo - Stillframe detected, switching to forced %f fps", m_fFrameRate);
+          m_stalled = true;
+          pts+= frametime*4;
+        }
+
+        //Waiting timed out, output last picture
+        if( picture.iFlags & DVP_FLAG_ALLOCATED )
+        {
+          //Remove interlaced flag before outputting
+          //no need to output this as if it was interlaced
+          picture.iFlags &= ~DVP_FLAG_INTERLACED;
+          picture.iFlags |= DVP_FLAG_NOSKIP;
+          OutputPicture(&picture, pts);
+          pts+= frametime;
+        }
 
-      continue;
+        continue;
+      }
     }
 
     if (pMsg->IsType(CDVDMsg::GENERAL_SYNCHRONIZE))
diff -Naur c/xbmc/cores/dvdplayer/DVDStreamInfo.cpp d/xbmc/cores/dvdplayer/DVDStreamInfo.cpp
--- c/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDStreamInfo.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -73,6 +73,7 @@
   bitspersample = 0;
 
   orientation = 0;
+  workaround_bugs = 0;
 }
 
 bool CDVDStreamInfo::Equal(const CDVDStreamInfo& right, bool withextradata)
@@ -174,6 +175,7 @@
   vfr = right.vfr;
   software = right.software;
   stereo_mode = right.stereo_mode;
+  workaround_bugs = right.workaround_bugs;
 
   // AUDIO
   channels      = right.channels;
@@ -231,6 +233,7 @@
     bitsperpixel = stream->iBitsPerPixel;
     pid = stream->iPhysicalId;
     stereo_mode = stream->stereo_mode;
+    workaround_bugs = stream->workaround_bugs;
   }
   else if(  right.type == STREAM_SUBTITLE )
   {
diff -Naur c/xbmc/cores/dvdplayer/DVDStreamInfo.h d/xbmc/cores/dvdplayer/DVDStreamInfo.h
--- c/xbmc/cores/dvdplayer/DVDStreamInfo.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/dvdplayer/DVDStreamInfo.h	2016-04-06 18:32:36.000000000 +0300
@@ -73,6 +73,7 @@
   int bitsperpixel;
   int pid;
   std::string stereo_mode; // stereoscopic 3d mode
+  int workaround_bugs; // info for decoder
 
   // AUDIO
   int channels;
diff -Naur c/xbmc/cores/omxplayer/OMXAudio.cpp d/xbmc/cores/omxplayer/OMXAudio.cpp
--- c/xbmc/cores/omxplayer/OMXAudio.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXAudio.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -641,6 +641,12 @@
     {
        av_opt_set_double(m_pContext, "rematrix_maxval", 1.0, 0);
     }
+    int boost_center = CSettings::Get().GetInt("audiooutput.boostcenter");
+    if (boost_center)
+    {
+      float gain = pow(10.0f, ((float)(-3 + boost_center))/20.0f);
+      av_opt_set_double(m_pContext, "center_mix_level", gain, 0);
+    }
 
     // stereo upmix
     if (upmix && m_src_channels == 2 && m_dst_channels > 2)
@@ -725,6 +731,8 @@
 
     m_wave_header.dwChannelMask = m_src_chan_layout;
   }
+  else
+    SetAudioProps(m_Passthrough, 0);
 
   m_SampleRate    = m_format.m_sampleRate;
   m_BitsPerSample = CAEUtil::DataFormatToBits(m_format.m_dataFormat);
diff -Naur c/xbmc/cores/omxplayer/OMXHelper.cpp d/xbmc/cores/omxplayer/OMXHelper.cpp
--- c/xbmc/cores/omxplayer/OMXHelper.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXHelper.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -44,6 +44,9 @@
 
 bool OMXPlayerUnsuitable(bool m_HasVideo, bool m_HasAudio, CDVDDemux* m_pDemuxer, CDVDInputStream* m_pInputStream, CSelectionStreams &m_SelectionStreams)
 {
+  // if no OMXPlayer acceleration then it is not suitable
+  if (!CSettings::Get().GetBool("videoplayer.useomxplayer"))
+    return true;
   // if no MMAL acceleration stick with omxplayer regardless
   if (!CSettings::Get().GetBool("videoplayer.usemmal"))
     return false;
@@ -56,6 +59,12 @@
     CLog::Log(LOGNOTICE, "%s OMXPlayer unsuitable due to audio sink", __func__);
     return true;
   }
+  // omxplayer doesn't handle ac3 transcode
+  if (CSettings::Get().GetBool("audiooutput.ac3transcode"))
+  {
+    CLog::Log(LOGNOTICE, "%s OMXPlayer unsuitable due to ac3transcode", __func__);
+    return true;
+  }
   if (m_pDemuxer)
   {
     // find video stream
@@ -66,12 +75,14 @@
     {
       int iStream = it->id;
       CDemuxStream *stream = m_pDemuxer->GetStream(iStream);
-      if(!stream || stream->disabled)
+      if(!stream || stream->disabled || stream->flags & AV_DISPOSITION_ATTACHED_PIC)
         continue;
       CDVDStreamInfo hint(*stream, true);
 
       bool supported = false;
-      if ((hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO) && g_RBP.GetCodecMpg2())
+      if (hint.workaround_bugs & FF_BUG_GMC_UNSUPPORTED)
+        ;
+      else if ((hint.codec == AV_CODEC_ID_MPEG1VIDEO || hint.codec == AV_CODEC_ID_MPEG2VIDEO) && g_RBP.GetCodecMpg2())
         supported = true;
       else if ((hint.codec == AV_CODEC_ID_VC1 || hint.codec == AV_CODEC_ID_WMV3) && g_RBP.GetCodecWvc1())
         supported = true;
@@ -121,19 +132,19 @@
     bool audio_fifo_low = false, video_fifo_low = false, audio_fifo_high = false, video_fifo_high = false;
 
     if (m_OmxPlayerState.interlace_method == VS_INTERLACEMETHOD_MAX)
-      m_OmxPlayerState.interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
+      m_OmxPlayerState.interlace_method = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
 
     // if deinterlace setting has changed, we should close and open video
     if (m_OmxPlayerState.current_deinterlace != CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode ||
        (m_OmxPlayerState.current_deinterlace != VS_DEINTERLACEMODE_OFF &&
-        m_OmxPlayerState.interlace_method != g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod)))
+        m_OmxPlayerState.interlace_method != CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod))
     {
       CLog::Log(LOGNOTICE, "%s - Reopen stream due to interlace change (%d,%d,%d,%d)", __FUNCTION__,
         m_OmxPlayerState.current_deinterlace, CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode,
-        m_OmxPlayerState.interlace_method, g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod));
+        m_OmxPlayerState.interlace_method, CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
 
       m_OmxPlayerState.current_deinterlace = CMediaSettings::Get().GetCurrentVideoSettings().m_DeinterlaceMode;
-      m_OmxPlayerState.interlace_method    = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
+      m_OmxPlayerState.interlace_method    = CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod;
       reopen_stream = true;
     }
 
diff -Naur c/xbmc/cores/omxplayer/OMXImage.cpp d/xbmc/cores/omxplayer/OMXImage.cpp
--- c/xbmc/cores/omxplayer/OMXImage.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXImage.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -601,7 +601,10 @@
   m_orientation   = 0;
 
   if(!m_image_size)
+  {
+    CLog::Log(LOGERROR, "%s::%s %s m_image_size unexpected (%lu)\n", CLASSNAME, __func__, m_filename, m_image_size);
     return OMX_IMAGE_CodingMax;
+  }
 
   uint8_t *p = m_image_buffer;
   uint8_t *q = m_image_buffer + m_image_size;
@@ -848,17 +851,14 @@
 
     }
   }
+  else
+    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
 
   // apply input orientation
   m_orientation = m_orientation ^ orientation;
   if(m_orientation < 0 || m_orientation >= 8)
     m_orientation = 0;
 
-  if(eCompressionFormat == OMX_IMAGE_CodingMax)
-  {
-    CLog::Log(LOGERROR, "%s::%s error unsupported image format\n", CLASSNAME, __func__);
-  }
-
   if(progressive)
   {
     CLog::Log(LOGWARNING, "%s::%s progressive images not supported by decoder\n", CLASSNAME, __func__);
@@ -881,7 +881,7 @@
   m_filename = inputFile.c_str();
   if(!m_pFile.Open(inputFile, 0))
   {
-    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, inputFile.c_str());
+    CLog::Log(LOGERROR, "%s::%s %s not found\n", CLASSNAME, __func__, m_filename);
     return false;
   }
 
@@ -893,13 +893,13 @@
 
   if(!m_image_size)
   {
-    CLog::Log(LOGERROR, "%s::%s %s m_image_size zero\n", CLASSNAME, __func__, inputFile.c_str());
+    CLog::Log(LOGERROR, "%s::%s %s m_image_size zero\n", CLASSNAME, __func__, m_filename);
     return false;
   }
   m_image_buffer = (uint8_t *)malloc(m_image_size);
   if(!m_image_buffer)
   {
-    CLog::Log(LOGERROR, "%s::%s %s m_image_buffer null (%lu)\n", CLASSNAME, __func__, inputFile.c_str(), m_image_size);
+    CLog::Log(LOGERROR, "%s::%s %s m_image_buffer null (%lu)\n", CLASSNAME, __func__, m_filename, m_image_size);
     return false;
   }
   
@@ -907,15 +907,9 @@
   m_pFile.Close();
 
   OMX_IMAGE_CODINGTYPE eCompressionFormat = GetCodingType(m_width, m_height, orientation);
-  if(eCompressionFormat != OMX_IMAGE_CodingJPEG)
-  {
-    CLog::Log(LOGERROR, "%s::%s %s GetCodingType=0x%x\n", CLASSNAME, __func__, inputFile.c_str(), eCompressionFormat);
-    return false;
-  }
-
-  if(m_width < 1 || m_height < 1)
+  if(eCompressionFormat != OMX_IMAGE_CodingJPEG || m_width < 1 || m_height < 1)
   {
-    CLog::Log(LOGERROR, "%s::%s %s m_width=%d m_height=%d\n", CLASSNAME, __func__, inputFile.c_str(), m_width, m_height);
+    CLog::Log(LOGDEBUG, "%s::%s %s GetCodingType=0x%x (%dx%x)\n", CLASSNAME, __func__, m_filename, eCompressionFormat, m_width, m_height);
     return false;
   }
 
diff -Naur c/xbmc/cores/omxplayer/OMXPlayerAudio.cpp d/xbmc/cores/omxplayer/OMXPlayerAudio.cpp
--- c/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXPlayerAudio.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -495,6 +495,7 @@
 {
   m_flush = true;
   m_messageQueue.Flush();
+  m_messageQueue.Flush(CDVDMsg::GENERAL_EOF);
   m_messageQueue.Put( new CDVDMsg(CDVDMsg::GENERAL_FLUSH), 1);
 }
 
diff -Naur c/xbmc/cores/omxplayer/OMXPlayerVideo.cpp d/xbmc/cores/omxplayer/OMXPlayerVideo.cpp
--- c/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXPlayerVideo.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -490,12 +490,12 @@
         double pts = pPacket->pts;
 
         if (dts != DVD_NOPTS_VALUE)
-          dts += m_iVideoDelay;
+          dts += m_iVideoDelay - DVD_SEC_TO_TIME(g_renderManager.GetDisplayLatency());
 
         if (pts != DVD_NOPTS_VALUE)
-          pts += m_iVideoDelay;
+          pts += m_iVideoDelay - DVD_SEC_TO_TIME(g_renderManager.GetDisplayLatency());
 
-        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, dts, dts == DVD_NOPTS_VALUE ? pts : DVD_NOPTS_VALUE);
+        m_omxVideo.Decode(pPacket->pData, pPacket->iSize, dts, m_hints.ptsinvalid ? DVD_NOPTS_VALUE : pts);
 
         if (pts == DVD_NOPTS_VALUE)
           pts = dts;
@@ -535,6 +535,7 @@
 {
   m_flush = true;
   m_messageQueue.Flush();
+  m_messageQueue.Flush(CDVDMsg::GENERAL_EOF);
   m_messageQueue.Put(new CDVDMsg(CDVDMsg::GENERAL_FLUSH), 1);
 }
 
@@ -649,9 +650,7 @@
 
 void OMXPlayerVideo::SetVideoRect(const CRect &InSrcRect, const CRect &InDestRect)
 {
-  // we get called twice a frame for left/right. Can ignore the rights.
-  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
-    return;
+  assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   CRect SrcRect = InSrcRect, DestRect = InDestRect;
   unsigned flags = GetStereoModeFlags(GetStereoMode());
@@ -660,6 +659,10 @@
   bool stereo_invert                   = (flags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
   RENDER_STEREO_MODE display_stereo_mode = g_graphicsContext.GetStereoMode();
 
+  // ignore video stereo mode when 3D display mode is disabled
+  if (display_stereo_mode == RENDER_STEREO_MODE_OFF)
+    video_stereo_mode = RENDER_STEREO_MODE_OFF;
+
   // fix up transposed video
   if (m_hints.orientation == 90 || m_hints.orientation == 270)
   {
@@ -691,41 +694,17 @@
   CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
   CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
 
-  switch (video_stereo_mode)
+  if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
   {
-  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
-    {
-      SrcRect.x2 *= 2.0f;
-      DestRect.x2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (stereo_invert)
-    {
-      SrcRect.x1 += m_hints.width / 2;
-      SrcRect.x2 += m_hints.width / 2;
-    }
-    break;
-
-  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
-    {
-      SrcRect.y2 *= 2.0f;
-      DestRect.y2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (stereo_invert)
-    {
-      SrcRect.y1 += m_hints.height / 2;
-      SrcRect.y2 += m_hints.height / 2;
-    }
-    break;
-
-  default: break;
+    float width = DestRect.x2 - DestRect.x1;
+    DestRect.x1 *= 2.0f;
+    DestRect.x2 = DestRect.x1 + 2.0f * width;
+  }
+  else if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  {
+    float height = DestRect.y2 - DestRect.y1;
+    DestRect.y1 *= 2.0f;
+    DestRect.y2 = DestRect.y1 + 2.0f * height;
   }
 
   if (gui != display)
@@ -737,7 +716,7 @@
     DestRect.y1 *= yscale;
     DestRect.y2 *= yscale;
   }
-  m_omxVideo.SetVideoRect(SrcRect, DestRect, video_stereo_mode, display_stereo_mode);
+  m_omxVideo.SetVideoRect(SrcRect, DestRect, m_video_stereo_mode, m_display_stereo_mode, m_StereoInvert);
 }
 
 void OMXPlayerVideo::RenderUpdateCallBack(const void *ctx, const CRect &SrcRect, const CRect &DestRect)
@@ -752,40 +731,17 @@
   uint32_t video_width   = CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth;
   uint32_t video_height  = CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight;
 
-  unsigned flags = 0;
   ERenderFormat format = RENDER_FMT_BYPASS;
 
+  /* figure out steremode expected based on user settings and hints */
+  unsigned flags = GetStereoModeFlags(GetStereoMode());
+
   if(m_bAllowFullscreen)
   {
     flags |= CONF_FLAGS_FULLSCREEN;
     m_bAllowFullscreen = false; // only allow on first configure
   }
 
-  flags |= GetStereoModeFlags(GetStereoMode());
-
-  if(flags & CONF_FLAGS_STEREO_MODE_SBS)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DSBS))
-      CLog::Log(LOGNOTICE, "3DSBS movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DSBS movie found but not supported");
-    }
-  }
-  else if(flags & CONF_FLAGS_STEREO_MODE_TAB)
-  {
-    if(g_Windowing.Support3D(video_width, video_height, D3DPRESENTFLAG_MODE3DTB))
-      CLog::Log(LOGNOTICE, "3DTB movie found");
-    else
-    {
-      flags &= ~CONF_FLAGS_STEREO_MODE_MASK(~0);
-      CLog::Log(LOGNOTICE, "3DTB movie found but not supported");
-    }
-  }
-  else
-    CLog::Log(LOGNOTICE, "not a 3D movie");
-
   unsigned int iDisplayWidth  = width;
   unsigned int iDisplayHeight = height;
 
diff -Naur c/xbmc/cores/omxplayer/OMXVideo.cpp d/xbmc/cores/omxplayer/OMXVideo.cpp
--- c/xbmc/cores/omxplayer/OMXVideo.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXVideo.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -141,9 +141,8 @@
   return false;    
 }
 
-bool COMXVideo::PortSettingsChanged()
+bool COMXVideo::PortSettingsChanged(ResolutionUpdateInfo &resinfo)
 {
-  CSingleLock lock (m_critSection);
   OMX_ERRORTYPE omx_err   = OMX_ErrorNone;
 
   if (m_settings_changed)
@@ -186,15 +185,13 @@
       port_image.format.video.xFramerate / (float)(1<<16), interlace.eMode, m_deinterlace);
 
   // let OMXPlayerVideo know about resolution so it can inform RenderManager
-  if (m_res_callback)
-  {
-    float display_aspect = 0.0f;
-    if (pixel_aspect.nX && pixel_aspect.nY)
-      display_aspect = (float)pixel_aspect.nX * port_image.format.video.nFrameWidth /
-        ((float)pixel_aspect.nY * port_image.format.video.nFrameHeight);
-    m_res_callback(m_res_ctx, port_image.format.video.nFrameWidth, port_image.format.video.nFrameHeight,
-        port_image.format.video.xFramerate / (float)(1<<16), display_aspect);
-  }
+  resinfo.width = port_image.format.video.nFrameWidth;
+  resinfo.height = port_image.format.video.nFrameHeight;
+  resinfo.framerate = port_image.format.video.xFramerate / (float)(1<<16);
+  resinfo.display_aspect = 0.0f;
+  resinfo.changed = true;
+  if (pixel_aspect.nX && pixel_aspect.nY)
+    resinfo.display_aspect = (float)pixel_aspect.nX * port_image.format.video.nFrameWidth / ((float)pixel_aspect.nY * port_image.format.video.nFrameHeight);
 
   if (m_settings_changed)
   {
@@ -220,15 +217,6 @@
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
 
-  configDisplay.set = OMX_DISPLAY_SET_TRANSFORM;
-  configDisplay.transform = m_transform;
-  omx_err = m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
-  if(omx_err != OMX_ErrorNone)
-  {
-    CLog::Log(LOGWARNING, "%s::%s - could not set transform : %d", CLASSNAME, __func__, m_transform);
-    return false;
-  }
-
   if(m_hdmi_clock_sync)
   {
     OMX_CONFIG_LATENCYTARGETTYPE latencyTarget;
@@ -253,8 +241,7 @@
   if(m_deinterlace)
   {
     EINTERLACEMETHOD interlace_method = g_renderManager.AutoInterlaceMethod(CMediaSettings::Get().GetCurrentVideoSettings().m_InterlaceMethod);
-    bool advanced_deinterlace = (interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED || interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF) &&
-        port_image.format.video.nFrameWidth * port_image.format.video.nFrameHeight <= 576 * 720;
+    bool advanced_deinterlace = interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED || interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF;
     bool half_framerate = interlace_method == VS_INTERLACEMETHOD_MMAL_ADVANCED_HALF || interlace_method == VS_INTERLACEMETHOD_MMAL_BOB_HALF;
     if (!advanced_deinterlace)
     {
@@ -275,10 +262,11 @@
     OMX_INIT_STRUCTURE(image_filter);
 
     image_filter.nPortIndex = m_omx_image_fx.GetOutputPort();
-    image_filter.nNumParams = 3;
+    image_filter.nNumParams = 4;
     image_filter.nParams[0] = 3;
     image_filter.nParams[1] = 0;
     image_filter.nParams[2] = half_framerate;
+    image_filter.nParams[3] = 1; // qpu
     if (!advanced_deinterlace)
       image_filter.eImageFilter = OMX_ImageFilterDeInterlaceFast;
     else
@@ -430,6 +418,11 @@
           break;
       }
     }
+    if (CSettings::Get().GetBool("videoplayer.supportmvc"))
+    {
+      m_codingType = OMX_VIDEO_CodingMVC;
+      m_video_codec_name = "omx-mvc";
+    }
     break;
     case AV_CODEC_ID_MPEG4:
       // (role name) video_decoder.mpeg4
@@ -758,6 +751,19 @@
 
   if (demuxer_content && demuxer_bytes > 0)
   {
+    OMX_U32 nFlags = 0;
+
+    if(m_setStartTime)
+    {
+      nFlags |= OMX_BUFFERFLAG_STARTTIME;
+      CLog::Log(LOGDEBUG, "OMXVideo::Decode VDec : setStartTime %f\n", (pts == DVD_NOPTS_VALUE ? 0.0 : pts) / DVD_TIME_BASE);
+      m_setStartTime = false;
+    }
+    if (pts == DVD_NOPTS_VALUE && dts == DVD_NOPTS_VALUE)
+      nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
+    else if (pts == DVD_NOPTS_VALUE)
+      nFlags |= OMX_BUFFERFLAG_TIME_IS_DTS;
+
     while(demuxer_bytes)
     {
       // 500ms timeout
@@ -768,21 +774,9 @@
         return false;
       }
 
-      omx_buffer->nFlags = 0;
+      omx_buffer->nFlags = nFlags;
       omx_buffer->nOffset = 0;
       omx_buffer->nTimeStamp = ToOMXTime((uint64_t)(pts != DVD_NOPTS_VALUE ? pts : dts != DVD_NOPTS_VALUE ? dts : 0));
-
-      if(m_setStartTime)
-      {
-        omx_buffer->nFlags |= OMX_BUFFERFLAG_STARTTIME;
-        CLog::Log(LOGDEBUG, "OMXVideo::Decode VDec : setStartTime %f\n", (pts == DVD_NOPTS_VALUE ? 0.0 : pts) / DVD_TIME_BASE);
-        m_setStartTime = false;
-      }
-      else if (pts == DVD_NOPTS_VALUE && dts == DVD_NOPTS_VALUE)
-        omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_UNKNOWN;
-      else if (pts == DVD_NOPTS_VALUE)
-        omx_buffer->nFlags |= OMX_BUFFERFLAG_TIME_IS_DTS;
-
       omx_buffer->nFilledLen = std::min((OMX_U32)demuxer_bytes, omx_buffer->nAllocLen);
       memcpy(omx_buffer->pBuffer, demuxer_content, omx_buffer->nFilledLen);
 
@@ -801,10 +795,11 @@
       }
       //CLog::Log(LOGINFO, "VideD: dts:%.0f pts:%.0f size:%d)\n", dts, pts, iSize);
 
+      ResolutionUpdateInfo resinfo = {};
       omx_err = m_omx_decoder.WaitForEvent(OMX_EventPortSettingsChanged, 0);
       if (omx_err == OMX_ErrorNone)
       {
-        if(!PortSettingsChanged())
+        if(!PortSettingsChanged(resinfo))
         {
           CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
           return false;
@@ -813,11 +808,14 @@
       omx_err = m_omx_decoder.WaitForEvent(OMX_EventParamOrConfigChanged, 0);
       if (omx_err == OMX_ErrorNone)
       {
-        if(!PortSettingsChanged())
+        if(!PortSettingsChanged(resinfo))
         {
           CLog::Log(LOGERROR, "%s::%s - error PortSettingsChanged (EventParamOrConfigChanged) omx_err(0x%08x)\n", CLASSNAME, __func__, omx_err);
         }
       }
+      lock.Leave();
+      if (resinfo.changed && m_res_callback)
+        m_res_callback(m_res_ctx, resinfo.width, resinfo.height, resinfo.framerate, resinfo.display_aspect);
     }
     return true;
 
@@ -840,7 +838,7 @@
 }
 
 ///////////////////////////////////////////////////////////////////////////////////////////
-void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode)
+void COMXVideo::SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode, bool stereo_invert)
 {
   CSingleLock lock (m_critSection);
   if(!m_is_open)
@@ -850,7 +848,7 @@
 
   OMX_INIT_STRUCTURE(configDisplay);
   configDisplay.nPortIndex = m_omx_render.GetInputPort();
-  configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT|OMX_DISPLAY_SET_MODE);
+  configDisplay.set                 = (OMX_DISPLAYSETTYPE)(OMX_DISPLAY_SET_DEST_RECT|OMX_DISPLAY_SET_SRC_RECT|OMX_DISPLAY_SET_FULLSCREEN|OMX_DISPLAY_SET_NOASPECT|OMX_DISPLAY_SET_MODE|OMX_DISPLAY_SET_TRANSFORM);
   configDisplay.dest_rect.x_offset  = lrintf(DestRect.x1);
   configDisplay.dest_rect.y_offset  = lrintf(DestRect.y1);
   configDisplay.dest_rect.width     = lrintf(DestRect.Width());
@@ -863,23 +861,24 @@
 
   configDisplay.fullscreen = OMX_FALSE;
   configDisplay.noaspect = OMX_TRUE;
+  configDisplay.mode = OMX_DISPLAY_MODE_LETTERBOX;
+  configDisplay.transform = m_transform;
 
-  if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_TOP_TO_TOP;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
-  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    configDisplay.mode = OMX_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  if (video_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_TB);
+  else if (video_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_SBS);
   else
-    configDisplay.mode = OMX_DISPLAY_MODE_LETTERBOX;
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_MONO);
+
+  if (stereo_invert)
+    configDisplay.transform = (OMX_DISPLAYTRANSFORMTYPE)(configDisplay.transform | DISPMANX_STEREOSCOPIC_INVERT);
 
   m_omx_render.SetConfig(OMX_IndexConfigDisplayRegion, &configDisplay);
 
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d t:%x", CLASSNAME, __func__,
       configDisplay.src_rect.x_offset, configDisplay.src_rect.y_offset, configDisplay.src_rect.width, configDisplay.src_rect.height,
-      configDisplay.dest_rect.x_offset, configDisplay.dest_rect.y_offset, configDisplay.dest_rect.width, configDisplay.dest_rect.height, configDisplay.mode);
+      configDisplay.dest_rect.x_offset, configDisplay.dest_rect.y_offset, configDisplay.dest_rect.width, configDisplay.dest_rect.height, configDisplay.transform);
 }
 
 int COMXVideo::GetInputBufferSize()
diff -Naur c/xbmc/cores/omxplayer/OMXVideo.h d/xbmc/cores/omxplayer/OMXVideo.h
--- c/xbmc/cores/omxplayer/OMXVideo.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/omxplayer/OMXVideo.h	2016-04-06 18:32:52.000000000 +0300
@@ -41,6 +41,14 @@
 
 typedef void (*ResolutionUpdateCallBackFn)(void *ctx, uint32_t width, uint32_t height, float framerate, float display_aspect);
 
+struct ResolutionUpdateInfo {
+  uint32_t width;
+  uint32_t height;
+  float framerate;
+  float display_aspect;
+  bool changed;
+};
+
 class COMXVideo
 {
 public:
@@ -50,7 +58,7 @@
   // Required overrides
   bool SendDecoderConfig();
   bool Open(CDVDStreamInfo &hints, OMXClock *clock, EDEINTERLACEMODE deinterlace = VS_DEINTERLACEMODE_OFF, bool hdmi_clock_sync = false);
-  bool PortSettingsChanged();
+  bool PortSettingsChanged(ResolutionUpdateInfo &resinfo);
   void RegisterResolutionUpdateCallBack(void *ctx, ResolutionUpdateCallBackFn callback) { m_res_ctx = ctx; m_res_callback = callback; }
   void Close(void);
   unsigned int GetFreeSpace();
@@ -59,7 +67,7 @@
   void Reset(void);
   void SetDropState(bool bDrop);
   std::string GetDecoderName() { return m_video_codec_name; };
-  void SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode);
+  void SetVideoRect(const CRect& SrcRect, const CRect& DestRect, RENDER_STEREO_MODE video_mode, RENDER_STEREO_MODE display_mode, bool stereo_invert);
   int GetInputBufferSize();
   bool GetPlayerInfo(double &match, double &phase, double &pll);
   void SubmitEOS();
diff -Naur c/xbmc/cores/VideoRenderers/MMALRenderer.cpp d/xbmc/cores/VideoRenderers/MMALRenderer.cpp
--- c/xbmc/cores/VideoRenderers/MMALRenderer.cpp	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/VideoRenderers/MMALRenderer.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -19,6 +19,7 @@
  */
 
 #include "Util.h"
+#include "threads/Atomics.h"
 #include "MMALRenderer.h"
 #include "cores/dvdplayer/DVDCodecs/Video/DVDVideoCodec.h"
 #include "filesystem/File.h"
@@ -39,6 +40,44 @@
 #define MMAL_DEBUG_VERBOSE
 #endif
 
+
+CYUVVideoBuffer::CYUVVideoBuffer()
+{
+  m_refs = 0;
+  mmal_buffer = 0;
+}
+
+CYUVVideoBuffer::~CYUVVideoBuffer()
+{
+  m_refs = 0;
+  mmal_buffer = 0;
+}
+
+CYUVVideoBuffer *CYUVVideoBuffer::Acquire()
+{
+  long count = AtomicIncrement(&m_refs);
+#ifdef MMAL_DEBUG_VERBOSE
+  CLog::Log(LOGDEBUG, "%s::%s omvb:%p mmal:%p ref:%ld", CLASSNAME, __func__, this, mmal_buffer, count);
+#endif
+  (void)count;
+  return this;
+}
+
+long CYUVVideoBuffer::Release()
+{
+  long count = AtomicDecrement(&m_refs);
+#ifdef MMAL_DEBUG_VERBOSE
+  CLog::Log(LOGDEBUG, "%s::%s omvb:%p mmal:%p ref:%ld", CLASSNAME, __func__, this, mmal_buffer, count);
+#endif
+  if (count == 0)
+  {
+    mmal_buffer_header_release(mmal_buffer);
+    delete this;
+  }
+  else assert(count > 0);
+  return count;
+}
+
 CRenderInfo CMMALRenderer::GetRenderInfo()
 {
   CSingleLock lock(m_sharedSection);
@@ -67,21 +106,26 @@
 
 void CMMALRenderer::vout_input_port_cb(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)
 {
-  #if defined(MMAL_DEBUG_VERBOSE)
-  CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
-  CLog::Log(LOGDEBUG, "%s::%s port:%p buffer %p (%p), len %d cmd:%x f:%x", CLASSNAME, __func__, port, buffer, omvb, buffer->length, buffer->cmd, buffer->flags);
-  #endif
-
   assert(!(buffer->flags & MMAL_BUFFER_HEADER_FLAG_TRANSMISSION_FAILED));
   buffer->flags &= ~MMAL_BUFFER_HEADER_FLAG_USER2;
   if (m_format == RENDER_FMT_MMAL)
   {
     CMMALVideoBuffer *omvb = (CMMALVideoBuffer *)buffer->user_data;
+    assert(buffer == omvb->mmal_buffer);
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s port:%p omvb:%p mmal:%p len:%d cmd:%x flags:%x flight:%d", CLASSNAME, __func__, port, omvb, omvb->mmal_buffer, buffer->length, buffer->cmd, buffer->flags, m_inflight);
+#endif
     omvb->Release();
   }
   else if (m_format == RENDER_FMT_YUV420P)
   {
-    mmal_buffer_header_release(buffer);
+    CYUVVideoBuffer *omvb = (CYUVVideoBuffer *)buffer->user_data;
+    assert(buffer == omvb->mmal_buffer);
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s port:%p omvb:%p mmal:%p len:%d cmd:%x flags:%x flight:%d", CLASSNAME, __func__, port, omvb, omvb->mmal_buffer, buffer->length, buffer->cmd, buffer->flags, m_inflight);
+#endif
+    m_inflight--;
+    omvb->Release();
   }
   else assert(0);
 }
@@ -207,6 +251,8 @@
   m_bConfigured = false;
   m_bMMALConfigured = false;
   m_iYV12RenderBuffer = 0;
+  m_sharpness = -2.0f;
+  m_inflight = 0;
 }
 
 CMMALRenderer::~CMMALRenderer()
@@ -261,16 +307,19 @@
 
 int CMMALRenderer::GetImage(YV12Image *image, int source, bool readonly)
 {
+  if (!image || source < 0)
+  {
 #if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %p %d %d", CLASSNAME, __func__, image, source, readonly);
+    CLog::Log(LOGDEBUG, "%s::%s - invalid: image:%p source:%d ro:%d flight:%d", CLASSNAME, __func__, image, source, readonly, m_inflight);
 #endif
-  if (!image) return -1;
-
-  if( source < 0)
     return -1;
+  }
 
   if (m_format == RENDER_FMT_MMAL)
   {
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - MMAL: image:%p source:%d ro:%d flight:%d", CLASSNAME, __func__, image, source, readonly, m_inflight);
+#endif
   }
   else if (m_format == RENDER_FMT_YUV420P)
   {
@@ -284,6 +333,7 @@
       return -1;
     }
 
+    m_inflight++;
     mmal_buffer_header_reset(buffer);
 
     buffer->length = 3 * pitch * aligned_height >> 1;
@@ -306,10 +356,16 @@
     image->plane[1] = image->plane[0] + image->planesize[0];
     image->plane[2] = image->plane[1] + image->planesize[1];
 
-    CLog::Log(LOGDEBUG, "%s::%s - %p %d", CLASSNAME, __func__, buffer, source);
     YUVBUFFER &buf = m_buffers[source];
     memset(&buf, 0, sizeof buf);
-    buf.mmal_buffer = buffer;
+    buf.YUVBuffer = new CYUVVideoBuffer;
+    if (!buf.YUVBuffer)
+      return -1;
+    buf.YUVBuffer->mmal_buffer = buffer;
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - YUV: image:%p source:%d ro:%d omvb:%p mmal:%p flight:%d", CLASSNAME, __func__, image, source, readonly, buf.YUVBuffer, buffer, m_inflight);
+#endif
+    buf.YUVBuffer->Acquire();
   }
   else assert(0);
 
@@ -319,21 +375,44 @@
 void CMMALRenderer::ReleaseBuffer(int idx)
 {
   CSingleLock lock(m_sharedSection);
-  if (!m_bMMALConfigured || m_format == RENDER_FMT_BYPASS)
+  if (!m_bMMALConfigured)
+  {
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - not configured: source:%d", CLASSNAME, __func__, idx);
+#endif
+    return;
+  }
+  if (m_format == RENDER_FMT_BYPASS)
+  {
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - bypass: source:%d", CLASSNAME, __func__, idx);
+#endif
     return;
+  }
 
+  YUVBUFFER *buffer = &m_buffers[idx];
+  if (m_format == RENDER_FMT_MMAL)
+  {
+    CMMALVideoBuffer *omvb = buffer->MMALBuffer;
 #if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d (%p)", CLASSNAME, __func__, idx, m_buffers[idx].MMALBuffer);
+    CLog::Log(LOGDEBUG, "%s::%s - MMAL: source:%d omvb:%p mmal:%p", CLASSNAME, __func__, idx, omvb, omvb ? omvb->mmal_buffer:NULL);
 #endif
-  YUVBUFFER &buf = m_buffers[idx];
-  SAFE_RELEASE(buf.MMALBuffer);
+    SAFE_RELEASE(buffer->MMALBuffer);
+  }
+  else if (m_format == RENDER_FMT_YUV420P)
+  {
+    CYUVVideoBuffer *omvb = buffer->YUVBuffer;
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - YUV: source:%d omvb:%p mmal:%p flight:%d", CLASSNAME, __func__, idx, omvb, omvb ? omvb->mmal_buffer:NULL, m_inflight);
+#endif
+    if (omvb && omvb->mmal_buffer)
+      SAFE_RELEASE(buffer->YUVBuffer);
+  }
+  else assert(0);
 }
 
 void CMMALRenderer::ReleaseImage(int source, bool preserve)
 {
-#if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d %d (%p)", CLASSNAME, __func__, source, preserve, m_buffers[source].MMALBuffer);
-#endif
 }
 
 void CMMALRenderer::Reset()
@@ -360,36 +439,48 @@
 {
   CSingleLock lock(m_sharedSection);
   int source = m_iYV12RenderBuffer;
+
+  if (!m_bConfigured)
+  {
 #if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d %x %d %d", CLASSNAME, __func__, clear, flags, alpha, source);
+    CLog::Log(LOGDEBUG, "%s::%s - not configured: clear:%d flags:%x alpha:%d source:%d", CLASSNAME, __func__, clear, flags, alpha, source);
 #endif
+    return;
+  }
 
-  if (!m_bConfigured) return;
-
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_LEFT);
   ManageDisplay();
-  if (g_graphicsContext.GetStereoMode())
-    g_graphicsContext.SetStereoView(RENDER_STEREO_VIEW_OFF);
 
   // if running bypass, then the player might need the src/dst rects
   // for sizing video playback on a layer other than the gles layer.
   if (m_RenderUpdateCallBackFn)
     (*m_RenderUpdateCallBackFn)(m_RenderUpdateCallBackCtx, m_sourceRect, m_destRect);
 
+  // if sharpness setting has changed, we should update it
+  if (m_sharpness != CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness)
+  {
+    m_sharpness = CMediaSettings::Get().GetCurrentVideoSettings().m_Sharpness;
+    char command[80], response[80];
+    sprintf(command, "scaling_sharpness %d", ((int)(50.0f * (m_sharpness + 1.0f) + 0.5f)));
+    vc_gencmd(response, sizeof response, command);
+  }
+
   if (m_format == RENDER_FMT_BYPASS)
+  {
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - bypass: clear:%d flags:%x alpha:%d source:%d", CLASSNAME, __func__, clear, flags, alpha, source);
+#endif
     return;
-
+  }
   SetVideoRect(m_sourceRect, m_destRect);
 
   YUVBUFFER *buffer = &m_buffers[source];
   if (m_format == RENDER_FMT_MMAL)
   {
     CMMALVideoBuffer *omvb = buffer->MMALBuffer;
-    if (omvb)
+    if (omvb && omvb->mmal_buffer)
     {
 #if defined(MMAL_DEBUG_VERBOSE)
-      CLog::Log(LOGDEBUG, "%s::%s %p (%p) f:%x", CLASSNAME, __func__, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
+      CLog::Log(LOGDEBUG, "%s::%s - MMAL: clear:%d flags:%x alpha:%d source:%d omvb:%p mmal:%p mflags:%x", CLASSNAME, __func__, clear, flags, alpha, source, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
 #endif
       // we only want to upload frames once
       if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
@@ -403,18 +494,23 @@
   }
   else if (m_format == RENDER_FMT_YUV420P)
   {
-    if (buffer->mmal_buffer)
+    CYUVVideoBuffer *omvb = buffer->YUVBuffer;
+    if (omvb && omvb->mmal_buffer)
     {
-      CLog::Log(LOGDEBUG, "%s::%s - %p %d f:%x", CLASSNAME, __func__, buffer->mmal_buffer, source, buffer->mmal_buffer->flags);
+#if defined(MMAL_DEBUG_VERBOSE)
+      CLog::Log(LOGDEBUG, "%s::%s - YUV: clear:%d flags:%x alpha:%d source:%d omvb:%p mmal:%p mflags:%x", CLASSNAME, __func__, clear, flags, alpha, source, omvb, omvb->mmal_buffer, omvb->mmal_buffer->flags);
+#endif
       // we only want to upload frames once
-      if (buffer->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
+      if (omvb->mmal_buffer->flags & MMAL_BUFFER_HEADER_FLAG_USER1)
         return;
       // sanity check it is not on display
-      buffer->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
-      mmal_port_send_buffer(m_vout_input, buffer->mmal_buffer);
+      omvb->Acquire();
+      omvb->mmal_buffer->flags |= MMAL_BUFFER_HEADER_FLAG_USER1 | MMAL_BUFFER_HEADER_FLAG_USER2;
+      omvb->mmal_buffer->user_data = omvb;
+      mmal_port_send_buffer(m_vout_input, omvb->mmal_buffer);
     }
     else
-      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update", CLASSNAME, __func__);
+      CLog::Log(LOGDEBUG, "%s::%s - No buffer to update: clear:%d flags:%x alpha:%d source:%d", CLASSNAME, __func__, clear, flags, alpha, source);
   }
   else assert(0);
 }
@@ -423,10 +519,15 @@
 {
   CSingleLock lock(m_sharedSection);
   if (!m_bConfigured || m_format == RENDER_FMT_BYPASS)
+  {
+#if defined(MMAL_DEBUG_VERBOSE)
+    CLog::Log(LOGDEBUG, "%s::%s - not configured: source:%d", CLASSNAME, __func__, source);
+#endif
     return;
+  }
 
 #if defined(MMAL_DEBUG_VERBOSE)
-  CLog::Log(LOGDEBUG, "%s::%s - %d", CLASSNAME, __func__, source);
+  CLog::Log(LOGDEBUG, "%s::%s - source:%d", CLASSNAME, __func__, source);
 #endif
 
   m_iYV12RenderBuffer = source;
@@ -460,6 +561,9 @@
 
 void CMMALRenderer::ReleaseBuffers()
 {
+#if defined(MMAL_DEBUG_VERBOSE)
+  CLog::Log(LOGDEBUG, "%s::%s", CLASSNAME, __func__);
+#endif
   for (int i=0; i<NUM_BUFFERS; i++)
     ReleaseBuffer(i);
 }
@@ -543,6 +647,13 @@
 
 bool CMMALRenderer::Supports(EINTERLACEMETHOD method)
 {
+  if (m_format == RENDER_FMT_YUV420P)
+  {
+    if (method == VS_INTERLACEMETHOD_DEINTERLACE_HALF)
+      return true;
+    else
+      return false;
+  }
   if (method == VS_INTERLACEMETHOD_AUTO)
     return true;
   if (method == VS_INTERLACEMETHOD_MMAL_ADVANCED)
@@ -563,7 +674,8 @@
       feature == RENDERFEATURE_ZOOM            ||
       feature == RENDERFEATURE_ROTATION        ||
       feature == RENDERFEATURE_VERTICAL_SHIFT  ||
-      feature == RENDERFEATURE_PIXEL_RATIO)
+      feature == RENDERFEATURE_PIXEL_RATIO     ||
+      feature == RENDERFEATURE_SHARPNESS)
     return true;
 
   return false;
@@ -576,15 +688,15 @@
 
 EINTERLACEMETHOD CMMALRenderer::AutoInterlaceMethod()
 {
-  return VS_INTERLACEMETHOD_MMAL_ADVANCED;
+  if (m_format == RENDER_FMT_YUV420P)
+    return VS_INTERLACEMETHOD_DEINTERLACE_HALF;
+  return m_sourceWidth * m_sourceHeight <= 576 * 720 ? VS_INTERLACEMETHOD_MMAL_ADVANCED : VS_INTERLACEMETHOD_MMAL_BOB;
 }
 
 void CMMALRenderer::SetVideoRect(const CRect& InSrcRect, const CRect& InDestRect)
 {
-  // we get called twice a frame for left/right. Can ignore the rights.
-  if (g_graphicsContext.GetStereoView() == RENDER_STEREO_VIEW_RIGHT)
-    return;
   CSingleLock lock(m_sharedSection);
+  assert(g_graphicsContext.GetStereoView() != RENDER_STEREO_VIEW_RIGHT);
 
   if (!m_vout_input)
     return;
@@ -595,6 +707,10 @@
   bool stereo_invert                   = (m_iFlags & CONF_FLAGS_STEREO_CADANCE_RIGHT_LEFT) ? true : false;
   RENDER_STEREO_MODE display_stereo_mode = g_graphicsContext.GetStereoMode();
 
+  // ignore video stereo mode when 3D display mode is disabled
+  if (display_stereo_mode == RENDER_STEREO_MODE_OFF)
+    video_stereo_mode = RENDER_STEREO_MODE_OFF;
+
   // fix up transposed video
   if (m_renderOrientation == 90 || m_renderOrientation == 270)
   {
@@ -626,40 +742,17 @@
   CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
   CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
 
-  if (display_stereo_mode != RENDER_STEREO_MODE_OFF && display_stereo_mode != RENDER_STEREO_MODE_MONO)
-  switch (video_stereo_mode)
+  if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
   {
-  case RENDER_STEREO_MODE_SPLIT_VERTICAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.x1 == 0.0f && DestRect.x2 * 2.0f == gui.Width() && !stereo_invert)
-    {
-      SrcRect.x2 *= 2.0f;
-      DestRect.x2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.x2 *= 2.0f;
-    }
-    break;
-
-  case RENDER_STEREO_MODE_SPLIT_HORIZONTAL:
-    // optimisation - use simpler display mode in common case of unscaled 3d with same display mode
-    if (video_stereo_mode == display_stereo_mode && DestRect.y1 == 0.0f && DestRect.y2 * 2.0f == gui.Height() && !stereo_invert)
-    {
-      SrcRect.y2 *= 2.0f;
-      DestRect.y2 *= 2.0f;
-      video_stereo_mode = RENDER_STEREO_MODE_OFF;
-      display_stereo_mode = RENDER_STEREO_MODE_OFF;
-    }
-    else if (display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_RED_CYAN || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_GREEN_MAGENTA || display_stereo_mode == RENDER_STEREO_MODE_ANAGLYPH_YELLOW_BLUE)
-    {
-      SrcRect.y2 *= 2.0f;
-    }
-    break;
-
-  default: break;
+    float width = DestRect.x2 - DestRect.x1;
+    DestRect.x1 *= 2.0f;
+    DestRect.x2 = DestRect.x1 + 2.0f * width;
+  }
+  else if (display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+  {
+    float height = DestRect.y2 - DestRect.y1;
+    DestRect.y1 *= 2.0f;
+    DestRect.y2 = DestRect.y1 + 2.0f * height;
   }
 
   if (gui != display)
@@ -675,7 +768,7 @@
   MMAL_DISPLAYREGION_T region;
   memset(&region, 0, sizeof region);
 
-  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE;
+  region.set                 = MMAL_DISPLAY_SET_DEST_RECT|MMAL_DISPLAY_SET_SRC_RECT|MMAL_DISPLAY_SET_FULLSCREEN|MMAL_DISPLAY_SET_NOASPECT|MMAL_DISPLAY_SET_MODE|MMAL_DISPLAY_SET_TRANSFORM;
   region.dest_rect.x         = lrintf(DestRect.x1);
   region.dest_rect.y         = lrintf(DestRect.y1);
   region.dest_rect.width     = lrintf(DestRect.Width());
@@ -688,35 +781,32 @@
 
   region.fullscreen = MMAL_FALSE;
   region.noaspect = MMAL_TRUE;
+  region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
 
-  if (m_renderOrientation)
-  {
-    region.set |= MMAL_DISPLAY_SET_TRANSFORM;
-    if (m_renderOrientation == 90)
-      region.transform = MMAL_DISPLAY_ROT90;
-    else if (m_renderOrientation == 180)
-      region.transform = MMAL_DISPLAY_ROT180;
-    else if (m_renderOrientation == 270)
-      region.transform = MMAL_DISPLAY_ROT270;
-    else assert(0);
-  }
-
-  if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_TOP_TO_LEFT;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_TOP;
-  else if (video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL && display_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    region.mode = MMAL_DISPLAY_MODE_STEREO_LEFT_TO_LEFT;
+  if (m_renderOrientation == 90)
+    region.transform = MMAL_DISPLAY_ROT90;
+  else if (m_renderOrientation == 180)
+    region.transform = MMAL_DISPLAY_ROT180;
+  else if (m_renderOrientation == 270)
+    region.transform = MMAL_DISPLAY_ROT270;
   else
-    region.mode = MMAL_DISPLAY_MODE_LETTERBOX;
+    region.transform = MMAL_DISPLAY_ROT0;
+
+  if (m_video_stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_TB);
+  else if (m_video_stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_SBS);
+  else
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_MONO);
+
+  if (m_StereoInvert)
+    region.transform = (MMAL_DISPLAYTRANSFORM_T)(region.transform | DISPMANX_STEREOSCOPIC_INVERT);
 
   MMAL_STATUS_T status = mmal_util_set_display_region(m_vout_input, &region);
   if (status != MMAL_SUCCESS)
     CLog::Log(LOGERROR, "%s::%s Failed to set display region (status=%x %s)", CLASSNAME, __func__, status, mmal_status_to_string(status));
 
-  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d mode:%d", CLASSNAME, __func__,
+  CLog::Log(LOGDEBUG, "%s::%s %d,%d,%d,%d -> %d,%d,%d,%d t:%x", CLASSNAME, __func__,
       region.src_rect.x, region.src_rect.y, region.src_rect.width, region.src_rect.height,
-      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.mode);
+      region.dest_rect.x, region.dest_rect.y, region.dest_rect.width, region.dest_rect.height, region.transform);
 }
diff -Naur c/xbmc/cores/VideoRenderers/MMALRenderer.h d/xbmc/cores/VideoRenderers/MMALRenderer.h
--- c/xbmc/cores/VideoRenderers/MMALRenderer.h	2015-10-21 00:51:51.000000000 +0300
+++ d/xbmc/cores/VideoRenderers/MMALRenderer.h	2016-04-06 18:32:52.000000000 +0300
@@ -42,12 +42,25 @@
 
 struct DVDVideoPicture;
 
+class CYUVVideoBuffer
+{
+public:
+  CYUVVideoBuffer();
+  ~CYUVVideoBuffer();
+  // reference counting
+  CYUVVideoBuffer *Acquire();
+  long Release();
+  MMAL_BUFFER_HEADER_T *mmal_buffer;
+protected:
+  long m_refs;
+};
+
 class CMMALRenderer : public CBaseRenderer
 {
   struct YUVBUFFER
   {
     CMMALVideoBuffer *MMALBuffer; // used for hw decoded buffers
-    MMAL_BUFFER_HEADER_T *mmal_buffer;  // used for sw decoded buffers
+    CYUVVideoBuffer  *YUVBuffer;  // used for sw decoded buffers
   };
 public:
   CMMALRenderer();
@@ -105,6 +118,8 @@
   RENDER_STEREO_MODE        m_video_stereo_mode;
   RENDER_STEREO_MODE        m_display_stereo_mode;
   bool                      m_StereoInvert;
+  float                     m_sharpness;
+  int                       m_inflight;
 
   CCriticalSection m_sharedSection;
   MMAL_COMPONENT_T *m_vout;
diff -Naur c/xbmc/dialogs/GUIDialogBusy.cpp d/xbmc/dialogs/GUIDialogBusy.cpp
--- c/xbmc/dialogs/GUIDialogBusy.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/dialogs/GUIDialogBusy.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -68,7 +68,11 @@
     if (dialog)
     {
       dialog->Show();
+#ifdef TARGET_RASPBERRY_PI
+      while(!event.WaitMSec(100))
+#else
       while(!event.WaitMSec(1))
+#endif
       {
         g_windowManager.ProcessRenderLoop(false);
         if (allowCancel && dialog->IsCanceled())
diff -Naur c/xbmc/filesystem/FileDirectoryFactory.cpp d/xbmc/filesystem/FileDirectoryFactory.cpp
--- c/xbmc/filesystem/FileDirectoryFactory.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/filesystem/FileDirectoryFactory.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -39,6 +39,7 @@
 #include "playlists/PlayListFactory.h"
 #include "Directory.h"
 #include "File.h"
+#include "settings/Settings.h"
 #include "FileItem.h"
 #include "utils/StringUtils.h"
 #include "URL.h"
@@ -112,6 +113,8 @@
     return NULL;
   }
 #endif
+  if (CSettings::Get().GetBool("filelists.browsearchives"))
+  {
   if (url.IsFileType("zip"))
   {
     CURL zipURL = URIUtils::CreateArchivePath("zip", url);
@@ -185,6 +188,7 @@
     }
     return NULL;
   }
+  }
   if (url.IsFileType("xsp"))
   { // XBMC Smart playlist - just XML renamed to XSP
     // read the name of the playlist in
diff -Naur c/xbmc/guilib/GraphicContext.cpp d/xbmc/guilib/GraphicContext.cpp
--- c/xbmc/guilib/GraphicContext.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/guilib/GraphicContext.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -432,30 +432,6 @@
   Lock();
 
   RESOLUTION_INFO info_org  = CDisplaySettings::Get().GetResolutionInfo(res);
-  RESOLUTION_INFO info_last = CDisplaySettings::Get().GetResolutionInfo(lastRes);
-
-  RENDER_STEREO_MODE stereo_mode = m_stereoMode;
-
-  // if the new resolution is an actual stereo mode, switch to that
-  // if the old resolution was an actual stereo mode and renderer is still in old 3D mode, switch to no 3d mode
-  if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DTB)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_HORIZONTAL;
-  else if (info_org.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
-    stereo_mode = RENDER_STEREO_MODE_SPLIT_VERTICAL;
-  else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DTB)
-        && m_stereoMode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
-    stereo_mode = RENDER_STEREO_MODE_OFF;
-  else if ((info_last.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
-        && m_stereoMode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
-    stereo_mode = RENDER_STEREO_MODE_OFF;
-
-  if(stereo_mode != m_stereoMode)
-  {
-    m_stereoView     = RENDER_STEREO_VIEW_OFF;
-    m_stereoMode     = stereo_mode;
-    m_nextStereoMode = stereo_mode;
-    CSettings::Get().SetInt("videoscreen.stereoscopicmode", (int)m_stereoMode);
-  }
 
   RESOLUTION_INFO info_mod = GetResInfo(res);
 
diff -Naur c/xbmc/guilib/GUIFadeLabelControl.cpp d/xbmc/guilib/GUIFadeLabelControl.cpp
--- c/xbmc/guilib/GUIFadeLabelControl.cpp	2015-10-21 00:51:49.000000000 +0300
+++ d/xbmc/guilib/GUIFadeLabelControl.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -20,6 +20,8 @@
 
 #include "GUIFadeLabelControl.h"
 
+#include "Application.h"
+
 using namespace std;
 
 CGUIFadeLabelControl::CGUIFadeLabelControl(int parentID, int controlID, float posX, float posY, float width, float height, const CLabelInfo& labelInfo, bool scrollOut, unsigned int timeToDelayAtEnd, bool resetOnLabelChange)
@@ -102,7 +104,7 @@
     m_lastLabel = m_currentLabel;
   }
 
-  if (m_infoLabels.size() > 1 || !m_shortText)
+  if ((m_infoLabels.size() > 1 || !m_shortText) && !g_application.ScreenSaverDisablesAutoScrolling())
   { // have scrolling text
     MarkDirtyRegion();
 
diff -Naur c/xbmc/guilib/GUIFont.cpp d/xbmc/guilib/GUIFont.cpp
--- c/xbmc/guilib/GUIFont.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/guilib/GUIFont.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -22,6 +22,7 @@
 #include "GUIFontTTF.h"
 #include "GraphicContext.h"
 
+#include "Application.h"
 #include "threads/SingleLock.h"
 #include "utils/TimeUtils.h"
 #include "utils/MathUtils.h"
@@ -128,6 +129,9 @@
   //   If the string is smaller than the viewport, then it may be plotted even
   //   more times than that.
   //
+  if (g_application.ScreenSaverDisablesAutoScrolling())
+    return false;
+
   if (scrollInfo.waitTime)
   {
     scrollInfo.waitTime--;
diff -Naur c/xbmc/guilib/GUILabel.cpp d/xbmc/guilib/GUILabel.cpp
--- c/xbmc/guilib/GUILabel.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/guilib/GUILabel.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -21,6 +21,8 @@
 #include "GUILabel.h"
 #include <limits>
 
+#include "Application.h"
+
 CGUILabel::CGUILabel(float posX, float posY, float width, float height, const CLabelInfo& labelInfo, CGUILabel::OVER_FLOW overflow)
     : m_label(labelInfo)
     , m_textLayout(labelInfo.font, overflow == OVER_FLOW_WRAP, height)
@@ -104,7 +106,7 @@
   color_t color = GetColor();
   bool renderSolid = (m_color == COLOR_DISABLED);
   bool overFlows = (m_renderRect.Width() + 0.5f < m_textLayout.GetTextWidth()); // 0.5f to deal with floating point rounding issues
-  if (overFlows && m_scrolling && !renderSolid)
+  if (overFlows && m_scrolling && !renderSolid && !g_application.ScreenSaverDisablesAutoScrolling())
     m_textLayout.RenderScrolling(m_renderRect.x1, m_renderRect.y1, m_label.angle, color, m_label.shadowColor, 0, m_renderRect.Width(), m_scrollInfo);
   else
   {
diff -Naur c/xbmc/guilib/GUITextBox.cpp d/xbmc/guilib/GUITextBox.cpp
--- c/xbmc/guilib/GUITextBox.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/guilib/GUITextBox.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -23,6 +23,7 @@
 #include "utils/XBMCTinyXML.h"
 #include "utils/MathUtils.h"
 #include "utils/StringUtils.h"
+#include "Application.h"
 
 #include <algorithm>
 
@@ -134,7 +135,7 @@
   // update our auto-scrolling as necessary
   if (m_autoScrollTime && m_lines.size() > m_itemsPerPage)
   {
-    if (!m_autoScrollCondition || m_autoScrollCondition->Get())
+    if ((!m_autoScrollCondition || m_autoScrollCondition->Get()) && !g_application.ScreenSaverDisablesAutoScrolling())
     {
       if (m_lastRenderTime)
         m_autoScrollDelayTime += currentTime - m_lastRenderTime;
diff -Naur c/xbmc/guilib/GUIWindowManager.cpp d/xbmc/guilib/GUIWindowManager.cpp
--- c/xbmc/guilib/GUIWindowManager.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/guilib/GUIWindowManager.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -195,7 +195,9 @@
   Add(new CGUIWindowAddonBrowser);
   Add(new CGUIWindowScreensaverDim);
   Add(new CGUIWindowDebugInfo);
+#ifndef TARGET_RASPBERRY_PI
   Add(new CGUIWindowPointer);
+#endif
   Add(new CGUIDialogYesNo);
   Add(new CGUIDialogProgress);
   Add(new CGUIDialogExtendedProgressBar);
@@ -800,7 +802,16 @@
   int currentWindow = GetActiveWindow();
   CGUIWindow *pWindow = GetWindow(currentWindow);
   if (pWindow)
-    CloseWindowSync(pWindow, iWindowID);
+  {
+    if (iWindowID == WINDOW_SCREENSAVER)
+    {
+      pWindow->Close(true, iWindowID);
+    }
+    else
+    {
+      CloseWindowSync(pWindow, iWindowID);
+    }
+  }
   g_infoManager.SetNextWindow(WINDOW_INVALID);
 
   // Add window to the history list (we must do this before we activate it,
diff -Naur c/xbmc/input/linux/LinuxInputDevices.cpp d/xbmc/input/linux/LinuxInputDevices.cpp
--- c/xbmc/input/linux/LinuxInputDevices.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/input/linux/LinuxInputDevices.cpp	2017-01-24 22:44:04.000000000 +0300
@@ -558,22 +558,27 @@
  */
 bool CLinuxInputDevice::RelEvent(const struct input_event& levt, XBMC_Event& devt)
 {
+  bool motion = false;
+  bool wheel  = false;
+
   switch (levt.code)
   {
   case REL_X:
     m_mouseX += levt.value;
     devt.motion.xrel = levt.value;
     devt.motion.yrel = 0;
+    motion = true;
     break;
-
   case REL_Y:
     m_mouseY += levt.value;
     devt.motion.xrel = 0;
     devt.motion.yrel = levt.value;
+    motion = true;
     break;
-
-  case REL_Z:
   case REL_WHEEL:
+    wheel = (levt.value != 0); // process wheel event only when there was some delta
+    break;
+  case REL_Z:
   default:
     CLog::Log(LOGWARNING, "CLinuxInputDevice::RelEvent: Unknown rel event code: %d\n", levt.code);
     return false;
@@ -588,13 +593,35 @@
   m_mouseY = std::max(0, m_mouseY);
 
 
-  devt.type = XBMC_MOUSEMOTION;
-  devt.motion.type = XBMC_MOUSEMOTION;
-  devt.motion.x = m_mouseX;
-  devt.motion.y = m_mouseY;
-  devt.motion.state = 0;
-  devt.motion.which = m_deviceIndex;
-
+  if (motion)
+  {
+    devt.type = XBMC_MOUSEMOTION;
+    devt.motion.type = XBMC_MOUSEMOTION;
+    devt.motion.x = m_mouseX;
+    devt.motion.y = m_mouseY;
+    devt.motion.state = 0;
+    devt.motion.which = m_deviceIndex;
+  }
+  else if (wheel)
+  {
+     devt.type = XBMC_MOUSEBUTTONUP;
+     devt.button.state = XBMC_RELEASED;
+     devt.button.type = devt.type;
+     devt.button.x = m_mouseX;
+     devt.button.y = m_mouseY;
+     devt.button.button = (levt.value<0) ? XBMC_BUTTON_WHEELDOWN:XBMC_BUTTON_WHEELUP;
+
+     /* but WHEEL up enent to the queue */
+     m_equeue.push_back(devt);
+
+     /* prepare and return WHEEL down event */
+     devt.button.state = XBMC_PRESSED;
+     devt.type = XBMC_MOUSEBUTTONDOWN;
+  }
+  else
+  {
+     return false;
+  }
 
   return true;
 }
@@ -693,57 +720,65 @@
 
   XBMC_Event devt;
 
-  while (1)
+  if (m_equeue.empty())
   {
-    bzero(&levt, sizeof(levt));
+    while (1)
+    {
+      bzero(&levt, sizeof(levt));
 
-    bzero(&devt, sizeof(devt));
-    devt.type = XBMC_NOEVENT;
+      bzero(&devt, sizeof(devt));
+      devt.type = XBMC_NOEVENT;
 
-    if(m_devicePreferredId == LI_DEVICE_NONE)
-      return devt;
+      if(m_devicePreferredId == LI_DEVICE_NONE)
+        return devt;
 
-    readlen = read(m_fd, &levt, sizeof(levt));
+      readlen = read(m_fd, &levt, sizeof(levt));
 
-    if (readlen <= 0)
-    {
-      if (errno == ENODEV)
+      if (readlen <= 0)
       {
-        CLog::Log(LOGINFO,"input device was unplugged %s",m_deviceName);
-        m_bUnplugged = true;
+        if (errno == ENODEV)
+        {
+          CLog::Log(LOGINFO,"input device was unplugged %s",m_deviceName);
+          m_bUnplugged = true;
+        }
+
+        break;
       }
 
-      break;
-    }
+      //printf("read event readlen = %d device name %s m_fileName %s\n", readlen, m_deviceName, m_fileName.c_str());
 
-    //printf("read event readlen = %d device name %s m_fileName %s\n", readlen, m_deviceName, m_fileName.c_str());
+      // sanity check if we realy read the event
+      if(readlen != sizeof(levt))
+      {
+        printf("CLinuxInputDevice: read error : %s\n", strerror(errno));
+        break;
+      }
 
-    // sanity check if we realy read the event
-    if(readlen != sizeof(levt))
-    {
-      printf("CLinuxInputDevice: read error : %s\n", strerror(errno));
-      break;
-    }
+      if (!TranslateEvent(levt, devt))
+        continue;
 
-    if (!TranslateEvent(levt, devt))
-      continue;
+      /* Flush previous event with DIEF_FOLLOW? */
+      if (devt.type != XBMC_NOEVENT)
+      {
+        //printf("new event! type = %d\n", devt.type);
+        //printf("key: %d %d %d %c\n", devt.key.keysym.scancode, devt.key.keysym.sym, devt.key.keysym.mod, devt.key.keysym.unicode);
 
-    /* Flush previous event with DIEF_FOLLOW? */
-    if (devt.type != XBMC_NOEVENT)
-    {
-      //printf("new event! type = %d\n", devt.type);
-      //printf("key: %d %d %d %c\n", devt.key.keysym.scancode, devt.key.keysym.sym, devt.key.keysym.mod, devt.key.keysym.unicode);
+        if (m_hasLeds && (m_keyMods != m_lastKeyMods))
+        {
+          SetLed(LED_NUML, m_keyMods & XBMCKMOD_NUM);
+          SetLed(LED_CAPSL, m_keyMods & XBMCKMOD_CAPS);
+          m_lastKeyMods = m_keyMods;
+        }
 
-      if (m_hasLeds && (m_keyMods != m_lastKeyMods))
-      {
-        SetLed(LED_NUML, m_keyMods & XBMCKMOD_NUM);
-        SetLed(LED_CAPSL, m_keyMods & XBMCKMOD_CAPS);
-        m_lastKeyMods = m_keyMods;
+        break;
       }
-
-      break;
     }
   }
+  else
+  {
+     devt = m_equeue.front();
+     m_equeue.pop_front();
+  }
 
   return devt;
 }
diff -Naur c/xbmc/input/linux/LinuxInputDevices.h d/xbmc/input/linux/LinuxInputDevices.h
--- c/xbmc/input/linux/LinuxInputDevices.h	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/input/linux/LinuxInputDevices.h	2017-01-24 22:57:59.773361180 +0300
@@ -22,6 +22,7 @@
 
 #include <vector>
 #include <string>
+#include <deque>
 #include "windowing/XBMC_events.h"
 #include "input/XBMC_keyboard.h"
 #include "threads/SingleLock.h"
@@ -79,6 +80,7 @@
   int m_deviceMaxAxis;
   bool m_bSkipNonKeyEvents;
   bool m_bUnplugged;
+  std::deque<XBMC_Event> m_equeue;
 };
 
 class CLinuxInputDevices
diff -Naur c/xbmc/interfaces/generic/LanguageInvokerThread.cpp d/xbmc/interfaces/generic/LanguageInvokerThread.cpp
--- c/xbmc/interfaces/generic/LanguageInvokerThread.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/interfaces/generic/LanguageInvokerThread.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -50,6 +50,11 @@
   m_args = arguments;
 
   Create();
+  #ifdef TARGET_RASPBERRY_PI
+  /* low prio */
+  SetPriority(GetPriority()-1);
+  #endif
+
   return true;
 }
 
diff -Naur c/xbmc/linux/DllBCM.h d/xbmc/linux/DllBCM.h
--- c/xbmc/linux/DllBCM.h	2015-10-21 00:51:45.000000000 +0300
+++ d/xbmc/linux/DllBCM.h	2016-04-06 18:32:36.000000000 +0300
@@ -48,6 +48,9 @@
   virtual void bcm_host_init() = 0;
   virtual void bcm_host_deinit() = 0;
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height) = 0;
+  virtual int vc_tv_power_off() = 0;
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options) = 0;
+  virtual int vc_tv_hdmi_power_on_preferred() = 0;
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags) = 0;
   virtual int vc_tv_hdmi_power_on_best_3d(uint32_t width, uint32_t height, uint32_t frame_rate,
@@ -92,6 +95,12 @@
     { return ::bcm_host_deinit(); };
   virtual int32_t graphics_get_display_size( const uint16_t display_number, uint32_t *width, uint32_t *height)
     { return ::graphics_get_display_size(display_number, width, height); };
+  virtual int vc_tv_power_off()
+    { return ::vc_tv_power_off(); }
+  virtual int vc_tv_sdtv_power_on(SDTV_MODE_T mode, SDTV_OPTIONS_T *options)
+    { return ::vc_tv_sdtv_power_on(mode, options); }
+  virtual int vc_tv_hdmi_power_on_preferred()
+    { return ::vc_tv_hdmi_power_on_preferred(); }
   virtual int vc_tv_hdmi_power_on_best(uint32_t width, uint32_t height, uint32_t frame_rate,
                                        HDMI_INTERLACED_T scan_mode, EDID_MODE_MATCH_FLAG_T match_flags)
     { return ::vc_tv_hdmi_power_on_best(width, height, frame_rate, scan_mode, match_flags); };
diff -Naur c/xbmc/linux/RBP.cpp d/xbmc/linux/RBP.cpp
--- c/xbmc/linux/RBP.cpp	2015-10-21 00:51:45.000000000 +0300
+++ d/xbmc/linux/RBP.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -23,10 +23,36 @@
 
 #include <assert.h>
 #include "settings/Settings.h"
+#include "settings/AdvancedSettings.h"
 #include "utils/log.h"
 
 #include "cores/omxplayer/OMXImage.h"
 
+#include "guilib/GraphicContext.h"
+#include "settings/DisplaySettings.h"
+
+#include <sys/ioctl.h>
+#include <linux/ioctl.h>
+#include "rpi_user_vcsm.h"
+
+#define MAJOR_NUM 100
+#define IOCTL_MBOX_PROPERTY _IOWR(MAJOR_NUM, 0, char *)
+#define DEVICE_FILE_NAME "/dev/vcio"
+
+typedef struct gpu_mem_ptr_s {
+  void *arm; // Pointer to memory mapped on ARM side
+  int vc_handle;   // Videocore handle of relocatable memory
+  int vcsm_handle; // Handle for use by VCSM
+  int vc;       // Address for use in GPU code
+  int numbytes; // Size of memory block
+  int suballoc;
+} GPU_MEM_PTR_T;
+
+static int mbox_open();
+static void mbox_close(int file_desc);
+static void gpu_free_internal(GPU_MEM_PTR_T *p, int mb);
+static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb);
+
 CRBP::CRBP()
 {
   m_initialized     = false;
@@ -34,6 +60,12 @@
   m_DllBcmHost      = new DllBcmHost();
   m_OMX             = new COMXCore();
   m_display = DISPMANX_NO_HANDLE;
+  m_p = NULL;
+  m_x = 0;
+  m_y = 0;
+  m_enabled = 0;
+  m_mb = mbox_open();
+  vcsm_init();
 }
 
 CRBP::~CRBP()
@@ -43,6 +75,12 @@
   delete m_DllBcmHost;
 }
 
+void CRBP::InitializeSettings()
+{
+  if (m_initialized && g_advancedSettings.m_cacheMemBufferSize == ~0U)
+    g_advancedSettings.m_cacheMemBufferSize = m_arm_mem < 256 ? 1024 * 1024 * 2 : 1024 * 1024 * 20;
+}
+
 bool CRBP::Initialize()
 {
   CSingleLock lock (m_critSection);
@@ -82,6 +120,8 @@
   if (!m_gui_resolution_limit)
     m_gui_resolution_limit = m_gpu_mem < 128 ? 720:1080;
 
+  InitializeSettings();
+
   g_OMXImage.Initialize();
   m_omx_image_init = true;
   return true;
@@ -94,6 +134,7 @@
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Raspberry PI firmware version: %s", response);
   CLog::Log(LOGNOTICE, "ARM mem: %dMB GPU mem: %dMB MPG2:%d WVC1:%d", m_arm_mem, m_gpu_mem, m_codec_mpg2_enabled, m_codec_wvc1_enabled);
+  CLog::Log(LOGNOTICE, "cacheMemBufferSize: %dMB",  g_advancedSettings.m_cacheMemBufferSize >> 20);
   m_DllBcmHost->vc_gencmd(response, sizeof response, "get_config int");
   response[sizeof(response) - 1] = '\0';
   CLog::Log(LOGNOTICE, "Config:\n%s", response);
@@ -105,7 +146,10 @@
 DISPMANX_DISPLAY_HANDLE_T CRBP::OpenDisplay(uint32_t device)
 {
   if (m_display == DISPMANX_NO_HANDLE)
+  {
     m_display = vc_dispmanx_display_open( 0 /*screen*/ );
+    init_cursor();
+  }
   return m_display;
 }
 
@@ -114,6 +158,7 @@
   assert(display == m_display);
   vc_dispmanx_display_close(m_display);
   m_display = DISPMANX_NO_HANDLE;
+  uninit_cursor();
 }
 
 void CRBP::GetDisplaySize(int &width, int &height)
@@ -214,5 +259,245 @@
   m_omx_image_init  = false;
   m_initialized     = false;
   m_omx_initialized = false;
+  uninit_cursor();
+  if (m_mb && m_p)
+    gpu_free_internal(m_p, m_mb);
+  delete m_p;
+  m_p = NULL;
+  if (m_mb)
+    mbox_close(m_mb);
+  m_mb = 0;
+  vcsm_exit();
+}
+
+double CRBP::AdjustHDMIClock(double adjust)
+{
+  char response[80];
+  vc_gencmd(response, sizeof response, "hdmi_adjust_clock %f", adjust);
+  float new_adjust = 1.0f;
+  char *p = strchr(response, '=');
+  if (p)
+    new_adjust = atof(p+1);
+  CLog::Log(LOGDEBUG, "CRBP::%s(%.4f) = %.4f", __func__, adjust, new_adjust);
+  return new_adjust;
+}
+
+
+static int mbox_property(int file_desc, void *buf)
+{
+   int ret_val = ioctl(file_desc, IOCTL_MBOX_PROPERTY, buf);
+
+   if (ret_val < 0) {
+      printf("ioctl_set_msg failed:%d\n", ret_val);
+   }
+   return ret_val;
+}
+
+static int mbox_open()
+{
+   int file_desc;
+
+   // open a char device file used for communicating with kernel mbox driver
+   file_desc = open(DEVICE_FILE_NAME, 0);
+   if (file_desc < 0) {
+      printf("Can't open device file: %s (%d)\n", DEVICE_FILE_NAME, file_desc);
+      printf("Try creating a device file with: sudo mknod %s c %d 0\n", DEVICE_FILE_NAME, MAJOR_NUM);
+   }
+   return file_desc;
+}
+
+static void mbox_close(int file_desc)
+{
+  close(file_desc);
+}
+
+static unsigned mem_lock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000d; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned mem_unlock(int file_desc, unsigned handle)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+
+   p[i++] = 0x3000e; // (the tag id)
+   p[i++] = 4; // (size of the buffer)
+   p[i++] = 4; // (size of the data)
+   p[i++] = handle;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+unsigned int mailbox_set_cursor_info(int file_desc, int width, int height, int format, uint32_t buffer, int hotspotx, int hotspoty)
+{
+   int i=0;
+   unsigned int p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x00008010; // set cursor state
+   p[i++] = 24; // buffer size
+   p[i++] = 24; // data size
+
+   p[i++] = width;
+   p[i++] = height;
+   p[i++] = format;
+   p[i++] = buffer;           // ptr to VC memory buffer. Doesn't work in 64bit....
+   p[i++] = hotspotx;
+   p[i++] = hotspoty;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof(*p); // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+
+}
+
+unsigned int mailbox_set_cursor_position(int file_desc, int enabled, int x, int y)
+{
+   int i=0;
+   unsigned p[32];
+   p[i++] = 0; // size
+   p[i++] = 0x00000000; // process request
+   p[i++] = 0x00008011; // set cursor state
+   p[i++] = 12; // buffer size
+   p[i++] = 12; // data size
+
+   p[i++] = enabled;
+   p[i++] = x;
+   p[i++] = y;
+
+   p[i++] = 0x00000000; // end tag
+   p[0] = i*sizeof *p; // actual size
+
+   mbox_property(file_desc, p);
+   return p[5];
+}
+
+static int gpu_malloc_uncached_internal(int numbytes, GPU_MEM_PTR_T *p, int mb)
+{
+  //printf("%s %d\n", __func__, numbytes);
+
+  p->numbytes = numbytes;
+  p->suballoc = 0;
+  p->vcsm_handle = vcsm_malloc_cache(numbytes, VCSM_CACHE_TYPE_NONE, (char *)"Mouse pointer");
+  assert(p->vcsm_handle);
+  p->vc_handle = vcsm_vc_hdl_from_hdl(p->vcsm_handle);
+  assert(p->vc_handle);
+  p->arm = vcsm_lock(p->vcsm_handle);
+  assert(p->arm);
+  p->vc = mem_lock(mb, p->vc_handle);
+  assert(p->vc);
+  return 0;
 }
+
+static void gpu_free_internal(GPU_MEM_PTR_T *p, int mb)
+{
+  mem_unlock(mb,p->vc_handle);
+  vcsm_unlock_ptr(p->arm);
+  vcsm_free(p->vcsm_handle);
+}
+
+#define T 0
+#define W 0xffffffff
+#define B 0xff000000
+
+const static uint32_t default_cursor_pixels[] =
+{
+   B,B,B,B,B,B,B,B,B,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,W,B,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,B,T,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,B,T,T,T,T,T,T,T,T,T,T,
+   B,W,W,W,W,W,B,T,T,T,T,T,T,T,T,T,
+   B,W,W,B,W,W,W,B,T,T,T,T,T,T,T,T,
+   B,W,B,T,B,W,W,W,B,T,T,T,T,T,T,T,
+   B,B,T,T,T,B,W,W,W,B,T,T,T,T,T,T,
+   B,T,T,T,T,T,B,W,W,W,B,T,T,T,T,T,
+   T,T,T,T,T,T,T,B,W,W,W,B,T,T,T,T,
+   T,T,T,T,T,T,T,T,B,W,W,W,B,T,T,T,
+   T,T,T,T,T,T,T,T,T,B,W,W,W,B,T,T,
+   T,T,T,T,T,T,T,T,T,T,B,W,W,W,B,T,
+   T,T,T,T,T,T,T,T,T,T,T,B,W,W,W,B,
+   T,T,T,T,T,T,T,T,T,T,T,T,B,W,B,T,
+   T,T,T,T,T,T,T,T,T,T,T,T,T,B,T,T
+};
+
+#undef T
+#undef W
+#undef B
+
+void CRBP::init_cursor()
+{
+  //printf("%s\n", __func__);
+  if (!m_mb)
+    return;
+  if (!m_p)
+  {
+    m_p = new GPU_MEM_PTR_T;
+    if (m_p)
+      gpu_malloc_uncached_internal(64 * 64 * 4, m_p, m_mb);
+  }
+  if (m_mb && m_p && m_p->arm && m_p->vc)
+    set_cursor(default_cursor_pixels, 16, 16, 0, 0);
+}
+
+void CRBP::set_cursor(const void *pixels, int width, int height, int hotspot_x, int hotspot_y)
+{
+  if (!m_mb || !m_p || !m_p->arm || !m_p->vc || !pixels || width * height > 64 * 64)
+    return;
+  //printf("%s %dx%d %p\n", __func__, width, height, pixels);
+  memcpy(m_p->arm, pixels, width * height * 4);
+  unsigned int s = mailbox_set_cursor_info(m_mb, width, height, 0, m_p->vc, hotspot_x, hotspot_y);
+  assert(s == 0);
+}
+
+void CRBP::update_cursor(int x, int y, bool enabled)
+{
+  if (!m_mb || !m_p || !m_p->arm || !m_p->vc)
+    return;
+
+  RESOLUTION res = g_graphicsContext.GetVideoResolution();
+  CRect gui(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iWidth, CDisplaySettings::Get().GetResolutionInfo(res).iHeight);
+  CRect display(0, 0, CDisplaySettings::Get().GetResolutionInfo(res).iScreenWidth, CDisplaySettings::Get().GetResolutionInfo(res).iScreenHeight);
+
+  int x2 = x * display.Width()  / gui.Width();
+  int y2 = y * display.Height() / gui.Height();
+
+  //printf("%s %d,%d (%d)\n", __func__, x, y, enabled);
+  if (m_x != x2 || m_y != y2 || m_enabled != enabled)
+    mailbox_set_cursor_position(m_mb, enabled, x2, y2);
+  m_x = x2;
+  m_y = y2;
+  m_enabled = enabled;
+}
+
+void CRBP::uninit_cursor()
+{
+  if (!m_mb || !m_p || !m_p->arm || !m_p->vc)
+    return;
+  //printf("%s\n", __func__);
+  mailbox_set_cursor_position(m_mb, 0, 0, 0);
+}
+
 #endif
diff -Naur c/xbmc/linux/RBP.h d/xbmc/linux/RBP.h
--- c/xbmc/linux/RBP.h	2015-10-21 00:51:45.000000000 +0300
+++ d/xbmc/linux/RBP.h	2016-04-06 18:32:36.000000000 +0300
@@ -41,6 +41,8 @@
 #include "threads/CriticalSection.h"
 #include "threads/Event.h"
 
+struct gpu_mem_ptr_s;
+
 class CRBP
 {
 public:
@@ -48,6 +50,7 @@
   ~CRBP();
 
   bool Initialize();
+  void InitializeSettings();
   void LogFirmwareVerison();
   void Deinitialize();
   int GetArmMem() { return m_arm_mem; }
@@ -63,6 +66,7 @@
   unsigned char *CaptureDisplay(int width, int height, int *stride, bool swap_red_blue, bool video_only = true);
   DllOMX *GetDllOMX() { return m_OMX ? m_OMX->GetDll() : NULL; }
   void WaitVsync();
+  double AdjustHDMIClock(double adjust);
 
 private:
   DllBcmHost *m_DllBcmHost;
@@ -79,6 +83,17 @@
   CEvent     m_vsync;
   class DllLibOMXCore;
   CCriticalSection m_critSection;
+
+  struct gpu_mem_ptr_s *m_p;
+  int m_mb;
+  int m_x;
+  int m_y;
+  bool m_enabled;
+  public:
+  void init_cursor();
+  void set_cursor(const void *pixels, int width, int height, int hotspot_x, int hotspot_y);
+  void update_cursor(int x, int y, bool enabled);
+  void uninit_cursor();
 };
 
 extern CRBP g_RBP;
diff -Naur c/xbmc/linux/rpi_user_vcsm.h d/xbmc/linux/rpi_user_vcsm.h
--- c/xbmc/linux/rpi_user_vcsm.h	1970-01-01 03:00:00.000000000 +0300
+++ d/xbmc/linux/rpi_user_vcsm.h	2016-04-06 18:32:36.000000000 +0300
@@ -0,0 +1,460 @@
+/*****************************************************************************
+* Copyright 2001 - 2011 Broadcom Corporation.  All rights reserved.
+*
+* This program is the proprietary software of Broadcom Corporation and/or
+* its licensors, and may only be used, duplicated, modified or distributed
+* pursuant to the terms and conditions of a separate, written license
+* agreement executed between you and Broadcom (an "Authorized License").
+* Except as set forth in an Authorized License, Broadcom grants no license
+* (express or implied), right to use, or waiver of any kind with respect to
+* the Software, and Broadcom expressly reserves all rights in and to the
+* Software and all intellectual property rights therein.  IF YOU HAVE NO
+* AUTHORIZED LICENSE, THEN YOU HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY
+* WAY, AND SHOULD IMMEDIATELY NOTIFY BROADCOM AND DISCONTINUE ALL USE OF
+* THE SOFTWARE.
+*
+* Except as expressly set forth in the Authorized License,
+* 1. This program, including its structure, sequence and organization,
+*    constitutes the valuable trade secrets of Broadcom, and you shall use
+*    all reasonable efforts to protect the confidentiality thereof, and to
+*    use this information only in connection with your use of Broadcom
+*    integrated circuit products.
+* 2. TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"
+*    AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR
+*    WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH
+*    RESPECT TO THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL
+*    IMPLIED WARRANTIES OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS
+*    FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS,
+*    QUIET ENJOYMENT, QUIET POSSESSION OR CORRESPONDENCE TO DESCRIPTION. YOU
+*    ASSUME THE ENTIRE RISK ARISING OUT OF USE OR PERFORMANCE OF THE SOFTWARE.
+* 3. TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS
+*    LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT,
+*    OR EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO
+*    YOUR USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN
+*    ADVISED OF THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS
+*    OF THE AMOUNT ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER
+*    IS GREATER. THESE LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF
+*    ESSENTIAL PURPOSE OF ANY LIMITED REMEDY.
+*****************************************************************************/
+
+#ifndef __USER_VCSM__H__INCLUDED__
+#define __USER_VCSM__H__INCLUDED__
+
+/* VideoCore Shared Memory - user interface library.
+**
+** This library provides all the necessary abstraction for any application to
+** make use of the shared memory service which is distributed accross a kernel
+** driver and a videocore service.
+**
+** It is an application design decision to choose or not to use this service.
+**
+** The logical flow of operations that a user application needs to follow when
+** using this service is:
+**
+**       1) Initialize the service.
+**       2) Allocate shared memory blocks.
+**       3) Start using the allocated blocks.
+**          - In order to gain ownership on a block, lock the allocated block,
+**            locking a block returns a valid address that the user application
+**            can access.
+**          - When finished with using the block for the current execution cycle
+**            or function, and so when giving up the ownership, unlock the block.
+**       4) A block can be locked/unlocked as many times required - within or outside
+**          of - a specific execution context.
+**       5) To completely release an allocated block, free it.
+**       6) If the service is no longer required, terminate it.
+**
+**
+** Some generic considerations:
+
+** Allocating memory blocks.
+**
+**   Memory blocks can be allocated in different manners depending on the cache
+**   behavior desired.  A given block can either be:
+
+**       - Allocated in a non cached fashion all the way through host and videocore.
+**       - Allocated in a cached fashion on host OR videocore.
+**       - Allocated in a cached fashion on host AND videocore.
+**
+**   It is an application decision to determine how to allocate a block.  Evidently
+**   if the application will be doing substantial read/write accesses to a given block,
+**   it is recommended to allocate the block at least in a 'host cached' fashion for
+**   better results.
+**
+**
+** Locking memory blocks.
+**
+**   When the memory block has been allocated in a host cached fashion, locking the
+**   memory block (and so taking ownership of it) will trigger a cache invalidation.
+**
+**   For the above reason and when using host cached allocation, it is important that
+**   an application properly implements the lock/unlock mechanism to ensure cache will
+**   stay coherent, otherwise there is no guarantee it will at all be.
+**
+**   It is possible to dynamically change the host cache behavior (ie cached or non
+**   cached) of a given allocation without needing to free and re-allocate the block.
+**   This feature can be useful for such application which requires access to the block
+**   only at certain times and not otherwise.  By changing the cache behavior dynamically
+**   the application can optimize performances for a given duration of use.
+**   Such dynamic cache behavior remapping only applies to host cache and not videocore
+**   cache.  If one requires to change the videocore cache behavior, then a new block
+**   must be created to replace the old one.
+**
+**   On successful locking, a valid pointer is returned that the application can use
+**   to access to data inside the block.  There is no guarantee that the pointer will
+**   stay valid following the unlock action corresponding to this lock.
+**
+**
+** Unocking memory blocks.
+**
+**   When the memory block has been allocated in a host cached fashion, unlocking the
+**   memory block (and so forgiving its ownership) will trigger a cache flush unless
+**   explicitely asked not to flush the cache for performances reasons.
+**
+**   For the above reason and when using host cached allocation, it is important that
+**   an application properly implements the lock/unlock mechanism to ensure cache will
+**   stay coherent, otherwise there is no guarantee it will at all be.
+**
+**
+** A complete API is defined below.
+*/
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/* Different status that can be dumped.
+*/
+typedef enum
+{
+   VCSM_STATUS_VC_WALK_ALLOC = 0,   // Walks *all* the allocation on videocore.
+                                    // Result of the walk is seen in the videocore
+                                    // log.
+   VCSM_STATUS_HOST_WALK_MAP,       // Walks the *full* mapping allocation on host
+                                    // driver (ie for all processes).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_HOST_WALK_PID_MAP,   // Walks the per process mapping allocation on host
+                                    // driver (for current process).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_HOST_WALK_PID_ALLOC, // Walks the per process host allocation on host
+                                    // driver (for current process).  Result of
+                                    // the walk is seen in the kernel log.
+   VCSM_STATUS_VC_MAP_ALL,          // Equivalent to both VCSM_STATUS_VC_WALK_ALLOC and
+                                    // VCSM_STATUS_HOST_WALK_MAP.
+                                    //
+   VCSM_STATUS_NONE,                // Must be last - invalid.
+
+} VCSM_STATUS_T;
+
+/* Different kind of cache behavior.
+*/
+typedef enum
+{
+   VCSM_CACHE_TYPE_NONE = 0,        // No caching applies.
+   VCSM_CACHE_TYPE_HOST,            // Allocation is cached on host (user space).
+   VCSM_CACHE_TYPE_VC,              // Allocation is cached on videocore.
+   VCSM_CACHE_TYPE_HOST_AND_VC,     // Allocation is cached on both host and videocore.
+
+} VCSM_CACHE_TYPE_T;
+
+/* Initialize the vcsm processing.
+**
+** Must be called once before attempting to do anything else.
+**
+** Returns 0 on success, -1 on error.
+*/
+int vcsm_init( void );
+
+
+/* Terminates the vcsm processing.
+**
+** Must be called vcsm services are no longer needed, it will
+** take care of removing any allocation under the current process
+** control if deemed necessary.
+*/
+void vcsm_exit( void );
+
+
+/* Queries the status of the the vcsm.
+**
+** Triggers dump of various kind of information, see the
+** different variants specified in VCSM_STATUS_T.
+**
+** Pid is optional.
+*/
+void vcsm_status( VCSM_STATUS_T status, int pid );
+
+
+/* Allocates a non-cached block of memory of size 'size' via the vcsm memory
+** allocator.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+** 
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc( unsigned int size, char *name );
+
+
+/* Allocates a cached block of memory of size 'size' via the vcsm memory
+** allocator, the type of caching requested is passed as argument of the
+** function call.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+** 
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc_cache( unsigned int size, VCSM_CACHE_TYPE_T cache, char *name );
+
+
+/* Shares an allocated block of memory via the vcsm memory allocator.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** On success, the user must invoke vcsm_lock with the returned opaque
+** handle to gain access to the memory associated with the opaque handle.
+** When finished using the memory, the user calls vcsm_unlock_xx (see those
+** function definition for more details on the one that can be used).
+**
+** A well behaved application should make every attempt to lock/unlock
+** only for the duration it needs to access the memory data associated with
+** the opaque handle.
+*/
+unsigned int vcsm_malloc_share( unsigned int handle );
+
+
+/* Resizes a block of memory allocated previously by vcsm_alloc.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** The handle must be unlocked by user prior to attempting any
+** resize action.
+**
+** On error, the original size allocated against the handle
+** remains available the same way it would be following a
+** successful vcsm_malloc.
+*/
+int vcsm_resize( unsigned int handle, unsigned int new_size );
+
+
+/* Frees a block of memory that was successfully allocated by
+** a prior call the vcms_alloc.
+**
+** The handle should be considered invalid upon return from this
+** call.
+**
+** Whether any memory is actually freed up or not as the result of
+** this call will depends on many factors, if all goes well it will
+** be freed.  If something goes wrong, the memory will likely end up
+** being freed up as part of the vcsm_exit process.  In the end the
+** memory is guaranteed to be freed one way or another.
+*/
+void vcsm_free( unsigned int handle );
+
+
+/* Retrieves a videocore opaque handle from a mapped user address
+** pointer.  The videocore handle will correspond to the actual
+** memory mapped in videocore.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** Note: the videocore opaque handle is distinct from the user
+**       opaque handle (allocated via vcsm_malloc) and it is only
+**       significant for such application which knows what to do
+**       with it, for the others it is just a number with little
+**       use since nothing can be done with it (in particular
+**       for safety reason it cannot be used to map anything).
+*/
+unsigned int vcsm_vc_hdl_from_ptr( void *usr_ptr );
+
+
+/* Retrieves a videocore opaque handle from a opaque handle
+** pointer.  The videocore handle will correspond to the actual
+** memory mapped in videocore.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+**
+** Note: the videocore opaque handle is distinct from the user
+**       opaque handle (allocated via vcsm_malloc) and it is only
+**       significant for such application which knows what to do
+**       with it, for the others it is just a number with little
+**       use since nothing can be done with it (in particular
+**       for safety reason it cannot be used to map anything).
+*/
+unsigned int vcsm_vc_hdl_from_hdl( unsigned int handle );
+
+
+/* Retrieves a user opaque handle from a mapped user address
+** pointer.
+**
+** Returns:        0 on error
+**                 a non-zero opaque handle on success.
+*/
+unsigned int vcsm_usr_handle( void *usr_ptr );
+
+
+/* Retrieves a mapped user address from an opaque user
+** handle.
+**
+** Returns:        0 on error
+**                 a non-zero address on success.
+**
+** On success, the address corresponds to the pointer
+** which can access the data allocated via the vcsm_malloc
+** call.
+*/
+void *vcsm_usr_address( unsigned int handle );
+
+
+/* Locks the memory associated with this opaque handle.
+**
+** Returns:        NULL on error
+**                 a valid pointer on success.
+**
+** A user MUST lock the handle received from vcsm_malloc
+** in order to be able to use the memory associated with it.
+**
+** On success, the pointer returned is only valid within
+** the lock content (ie until a corresponding vcsm_unlock_xx
+** is invoked).
+*/
+void *vcsm_lock( unsigned int handle );
+
+
+/* Locks the memory associated with this opaque handle.  The lock
+** also gives a chance to update the *host* cache behavior of the
+** allocated buffer if so desired.  The *videocore* cache behavior
+** of the allocated buffer cannot be changed by this call and such
+** attempt will be ignored.
+**
+** The system will attempt to honour the cache_update mode request,
+** the cache_result mode will provide the final answer on which cache
+** mode is really in use.  Failing to change the cache mode will not
+** result in a failure to lock the buffer as it is an application
+** decision to choose what to do if (cache_result != cache_update)
+**
+** The value returned in cache_result can only be considered valid if
+** the returned pointer is non NULL.  The cache_result pointer may be
+** NULL if the application does not care about the actual outcome of
+** its action with regards to the cache behavior change.
+**
+** Returns:        NULL on error
+**                 a valid pointer on success.
+**
+** A user MUST lock the handle received from vcsm_malloc
+** in order to be able to use the memory associated with it.
+**
+** On success, the pointer returned is only valid within
+** the lock content (ie until a corresponding vcsm_unlock_xx
+** is invoked).
+*/
+void *vcsm_lock_cache( unsigned int handle,
+                       VCSM_CACHE_TYPE_T cache_update,
+                       VCSM_CACHE_TYPE_T *cache_result );
+
+
+/* Unlocks the memory associated with this user mapped address.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking a mapped address, the user should no longer
+** attempt to reference it.
+*/
+int vcsm_unlock_ptr( void *usr_ptr );
+
+
+/* Unlocks the memory associated with this user mapped address.
+** Apply special processing that would override the otherwise
+** default behavior.
+**
+** If 'cache_no_flush' is specified:
+**    Do not flush cache as the result of the unlock (if cache
+**    flush was otherwise applicable in this case).
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking a mapped address, the user should no longer
+** attempt to reference it.
+*/
+int vcsm_unlock_ptr_sp( void *usr_ptr, int cache_no_flush );
+
+
+/* Unlocks the memory associated with this user opaque handle.
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking an opaque handle, the user should no longer
+** attempt to reference the mapped addressed once associated
+** with it.
+*/
+int vcsm_unlock_hdl( unsigned int handle );
+
+
+/* Unlocks the memory associated with this user opaque handle.
+** Apply special processing that would override the otherwise
+** default behavior.
+**
+** If 'cache_no_flush' is specified:
+**    Do not flush cache as the result of the unlock (if cache
+**    flush was otherwise applicable in this case).
+**
+** Returns:        0 on success
+**                 -errno on error.
+**
+** After unlocking an opaque handle, the user should no longer
+** attempt to reference the mapped addressed once associated
+** with it.
+*/
+int vcsm_unlock_hdl_sp( unsigned int handle, int cache_no_flush );
+
+/* Clean and/or invalidate the memory associated with this user opaque handle
+**
+** Returns:        non-zero on error
+**
+** structure contains a list of flush/invalidate commands. Commands are:
+** 0: nop
+** 1: invalidate       given virtual range in L1/L2
+** 2: clean            given virtual range in L1/L2
+** 3: clean+invalidate given virtual range in L1/L2
+** 4: flush all L1/L2
+*/
+struct vcsm_user_clean_invalid_s {
+   struct {
+      unsigned int cmd;
+      unsigned int handle;
+      unsigned int addr;
+      unsigned int size;
+   } s[8];
+};
+
+int vcsm_clean_invalid( struct vcsm_user_clean_invalid_s *s );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __USER_VCSM__H__INCLUDED__ */
+
diff -Naur c/xbmc/peripherals/devices/PeripheralCecAdapter.cpp d/xbmc/peripherals/devices/PeripheralCecAdapter.cpp
--- c/xbmc/peripherals/devices/PeripheralCecAdapter.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/peripherals/devices/PeripheralCecAdapter.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -764,10 +764,16 @@
 
 void CPeripheralCecAdapter::PushCecKeypress(const CecButtonPress &key)
 {
-  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d", __FUNCTION__, key.iButton, key.iDuration);
+  CLog::Log(LOGDEBUG, "%s - received key %2x duration %d (rep:%d size:%d)", __FUNCTION__, key.iButton, key.iDuration, m_configuration.iButtonRepeatRateMs, m_buttonQueue.size());
 
   CSingleLock lock(m_critSection);
-  if (key.iDuration > 0)
+  // avoid the queue getting too long
+  if (m_configuration.iButtonRepeatRateMs && m_buttonQueue.size() > 5)
+  {
+    CLog::Log(LOGDEBUG, "%s - discarded key %2x", __FUNCTION__, key.iButton);
+    return;
+  }
+  if (m_configuration.iButtonRepeatRateMs == 0 && key.iDuration > 0)
   {
     if (m_currentButton.iButton == key.iButton && m_currentButton.iDuration == 0)
     {
@@ -775,6 +781,7 @@
       if (m_bHasButton)
         m_currentButton.iDuration = key.iDuration;
       // ignore this one, since it's already been handled by xbmc
+      CLog::Log(LOGDEBUG, "%s - ignored key %2x", __FUNCTION__, key.iButton);
       return;
     }
     // if we received a keypress with a duration set, try to find the same one without a duration set, and replace it
@@ -785,6 +792,7 @@
         if ((*it).iDuration == 0)
         {
           // replace this entry
+          CLog::Log(LOGDEBUG, "%s - replaced key %2x", __FUNCTION__, key.iButton);
           (*it).iDuration = key.iDuration;
           return;
         }
@@ -794,6 +802,7 @@
     }
   }
 
+  CLog::Log(LOGDEBUG, "%s - added key %2x", __FUNCTION__, key.iButton);
   m_buttonQueue.push_back(key);
 }
 
@@ -1267,6 +1276,20 @@
   m_configuration.bSendInactiveSource = config.bSendInactiveSource;
   bChanged |= SetSetting("send_inactive_source", m_configuration.bSendInactiveSource == 1);
 
+#if defined(CEC_DOUBLE_TAP_TIMEOUT_MS_OLD)
+  m_configuration.iDoubleTapTimeout50Ms = config.iDoubleTapTimeout50Ms;
+  bChanged |= SetSetting("double_tap_timeout_ms", (int)m_configuration.iDoubleTapTimeout50Ms * 50);
+#else
+  m_configuration.iDoubleTapTimeoutMs = config.iDoubleTapTimeoutMs;
+  bChanged |= SetSetting("double_tap_timeout_ms", (int)m_configuration.iDoubleTapTimeoutMs;
+#endif
+
+  m_configuration.iButtonRepeatRateMs = config.iButtonRepeatRateMs;
+  bChanged |= SetSetting("button_repeat_rate_ms", (int)m_configuration.iButtonRepeatRateMs);
+
+  m_configuration.iButtonReleaseDelayMs = config.iButtonReleaseDelayMs;
+  bChanged |= SetSetting("button_release_delay_ms", (int)m_configuration.iButtonReleaseDelayMs);
+
   m_configuration.iFirmwareVersion = config.iFirmwareVersion;
   m_configuration.bShutdownOnStandby = config.bShutdownOnStandby;
 
@@ -1371,6 +1394,8 @@
   // backwards compatibility. will be removed once the next major release of libCEC is out
   m_configuration.iDoubleTapTimeoutMs = GetSettingInt("double_tap_timeout_ms");
 #endif
+  m_configuration.iButtonRepeatRateMs = GetSettingInt("button_repeat_rate_ms");
+  m_configuration.iButtonReleaseDelayMs = GetSettingInt("button_release_delay_ms");
 }
 
 void CPeripheralCecAdapter::ReadLogicalAddresses(const std::string &strString, cec_logical_addresses &addresses)
diff -Naur c/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp d/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp
--- c/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp	2015-10-21 00:51:45.000000000 +0300
+++ d/xbmc/pvr/dialogs/GUIDialogPVRChannelsOSD.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -48,6 +48,7 @@
     CGUIDialog(WINDOW_DIALOG_PVR_OSD_CHANNELS, "DialogPVRChannelsOSD.xml"),
     Observer()
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff -Naur c/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp d/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp
--- c/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp	2015-10-21 00:51:45.000000000 +0300
+++ d/xbmc/pvr/dialogs/GUIDialogPVRGuideOSD.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -35,6 +35,7 @@
 CGUIDialogPVRGuideOSD::CGUIDialogPVRGuideOSD()
     : CGUIDialog(WINDOW_DIALOG_PVR_OSD_GUIDE, "DialogPVRGuideOSD.xml")
 {
+  m_loadType = LOAD_ON_GUI_INIT;
   m_vecItems = new CFileItemList;
 }
 
diff -Naur c/xbmc/settings/AdvancedSettings.cpp d/xbmc/settings/AdvancedSettings.cpp
--- c/xbmc/settings/AdvancedSettings.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/settings/AdvancedSettings.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -43,6 +43,9 @@
 #if defined(TARGET_DARWIN_IOS)
 #include "osx/DarwinUtils.h"
 #endif
+#if defined(TARGET_RASPBERRY_PI)
+#include "linux/RBP.h"
+#endif
 
 using namespace ADDON;
 using namespace XFILE;
@@ -108,6 +111,7 @@
   m_audioHeadRoom = 0;
   m_ac3Gain = 12.0f;
   m_audioApplyDrc = -1.0f;
+  m_maxPllAdjust = 1000;
   m_dvdplayerIgnoreDTSinWAV = false;
 
   //default hold time of 25 ms, this allows a 20 hertz sine to pass undistorted
@@ -350,7 +354,12 @@
   m_bPVRAutoScanIconsUserSet       = false;
   m_iPVRNumericChannelSwitchTimeout = 1000;
 
+#ifdef TARGET_RASPBERRY_PI
+  // want default to be memory dependent, but interface to gpu not available yet, so set in RBP.cpp
+  m_cacheMemBufferSize = ~0;
+#else
   m_cacheMemBufferSize = 1024 * 1024 * 20;
+#endif
   m_networkBufferMode = 0; // Default (buffer all internet streams/filesystems)
   // the following setting determines the readRate of a player data
   // as multiply of the default data read rate
@@ -405,7 +414,9 @@
   #endif
 
   m_userAgent = g_sysinfo.GetUserAgent();
-
+#ifdef TARGET_RASPBERRY_PI
+  g_RBP.InitializeSettings();
+#endif
   m_initialized = true;
 }
 
@@ -463,6 +474,7 @@
   if (pElement)
   {
     XMLUtils::GetFloat(pElement, "ac3downmixgain", m_ac3Gain, -96.0f, 96.0f);
+    XMLUtils::GetInt(pElement, "maxplladjust", m_maxPllAdjust, 0, 1000000);
     XMLUtils::GetInt(pElement, "headroom", m_audioHeadRoom, 0, 12);
     XMLUtils::GetString(pElement, "defaultplayer", m_audioDefaultPlayer);
     // 101 on purpose - can be used to never automark as watched
diff -Naur c/xbmc/settings/AdvancedSettings.h d/xbmc/settings/AdvancedSettings.h
--- c/xbmc/settings/AdvancedSettings.h	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/settings/AdvancedSettings.h	2016-04-06 18:32:36.000000000 +0300
@@ -141,6 +141,7 @@
 
     int m_audioHeadRoom;
     float m_ac3Gain;
+    int m_maxPllAdjust;
     std::string m_audioDefaultPlayer;
     float m_audioPlayCountMinimumPercent;
     bool m_dvdplayerIgnoreDTSinWAV;
diff -Naur c/xbmc/settings/DisplaySettings.cpp d/xbmc/settings/DisplaySettings.cpp
--- c/xbmc/settings/DisplaySettings.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/settings/DisplaySettings.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -674,6 +674,9 @@
     vector<RESOLUTION_WHR> resolutions = g_Windowing.ScreenResolutions(info.iScreen, info.fRefreshRate);
     for (vector<RESOLUTION_WHR>::const_iterator resolution = resolutions.begin(); resolution != resolutions.end(); ++resolution)
     {
+if (resolution->ResInfo_Index == RES_DESKTOP)
+      list.push_back(make_pair(StringUtils::Format("DESKTOP"), resolution->ResInfo_Index));
+else
       list.push_back(make_pair(
         StringUtils::Format("%dx%d%s", resolution->width, resolution->height,
                             ModeFlagsToString(resolution->flags, false).c_str()),
diff -Naur c/xbmc/utils/Archive.h d/xbmc/utils/Archive.h
--- c/xbmc/utils/Archive.h	2015-10-21 00:51:47.000000000 +0300
+++ d/xbmc/utils/Archive.h	2016-04-06 18:32:36.000000000 +0300
@@ -154,9 +154,17 @@
      * than waiting until we attempt to put more data into an already full buffer */
     if (m_BufferRemain > size)
     {
+      switch (size)
+      {
+      case 1: *m_BufferPos++ = *ptr; m_BufferRemain--; break;
+      case 2: *(uint16_t *) m_BufferPos = *(const uint16_t *) ptr; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) m_BufferPos = *(const uint32_t *) ptr; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(m_BufferPos, ptr, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
@@ -171,9 +179,17 @@
     /* Note, refilling the buffer is deferred until we know we need to read more from it */
     if (m_BufferRemain >= size)
     {
+      switch (size)
+      {
+      case 1: *ptr = *m_BufferPos++; m_BufferRemain--; break;
+      case 2: *(uint16_t *) ptr = *(const uint16_t *) m_BufferPos; m_BufferPos += 2; m_BufferRemain -= 2; break;
+      case 4: *(uint32_t *) ptr = *(const uint32_t *) m_BufferPos; m_BufferPos += 4; m_BufferRemain -= 4; break;
+      default:
       memcpy(ptr, m_BufferPos, size);
       m_BufferPos += size;
       m_BufferRemain -= size;
+      break;
+      }
       return *this;
     }
     else
diff -Naur c/xbmc/utils/log.cpp d/xbmc/utils/log.cpp
--- c/xbmc/utils/log.cpp	2015-10-21 00:51:47.000000000 +0300
+++ d/xbmc/utils/log.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -24,6 +24,7 @@
 #include "threads/Thread.h"
 #include "utils/StringUtils.h"
 #include "CompileInfo.h"
+#include "utils/TimeUtils.cpp"
 
 static const char* const levelNames[] =
 {"DEBUG", "INFO", "NOTICE", "WARNING", "ERROR", "SEVERE", "FATAL", "NONE"};
@@ -198,19 +199,31 @@
 
 bool CLog::WriteLogString(int logLevel, const std::string& logString)
 {
+#if defined(TARGET_LINUX)
+  static const char* prefixFormat = "%02.2d:%02.2d:%02.2d %10.6f T:%" PRIu64" %7s: ";
+#else
   static const char* prefixFormat = "%02.2d:%02.2d:%02.2d T:%" PRIu64" %7s: ";
-
+#endif
   std::string strData(logString);
   /* fixup newline alignment, number of spaces should equal prefix length */
   StringUtils::Replace(strData, "\n", "\n                                            ");
 
   int hour, minute, second;
   s_globals.m_platform.GetCurrentLocalTime(hour, minute, second);
-  
+
+#if defined(TARGET_LINUX)
+  struct timespec now;
+  clock_gettime(CLOCK_MONOTONIC, &now);
+  float Now = now.tv_sec + now.tv_nsec * 1e-9;
+#endif
+
   strData = StringUtils::Format(prefixFormat,
                                   hour,
                                   minute,
                                   second,
+#if defined(TARGET_LINUX)
+                                  Now,
+#endif
                                   (uint64_t)CThread::GetCurrentThreadId(),
                                   levelNames[logLevel]) + strData;
 
diff -Naur c/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp d/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp
--- c/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/video/dialogs/GUIDialogAudioSubtitleSettings.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -62,7 +62,9 @@
 CGUIDialogAudioSubtitleSettings::CGUIDialogAudioSubtitleSettings()
   : CGUIDialogSettingsManualBase(WINDOW_DIALOG_AUDIO_OSD_SETTINGS, "VideoOSDSettings.xml"),
     m_passthrough(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogAudioSubtitleSettings::~CGUIDialogAudioSubtitleSettings()
 { }
diff -Naur c/xbmc/video/dialogs/GUIDialogSubtitles.cpp d/xbmc/video/dialogs/GUIDialogSubtitles.cpp
--- c/xbmc/video/dialogs/GUIDialogSubtitles.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/video/dialogs/GUIDialogSubtitles.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -98,7 +98,7 @@
 CGUIDialogSubtitles::CGUIDialogSubtitles(void)
     : CGUIDialog(WINDOW_DIALOG_SUBTITLES, "DialogSubtitles.xml")
 {
-  m_loadType  = KEEP_IN_MEMORY;
+  m_loadType  = LOAD_ON_GUI_INIT;
   m_subtitles = new CFileItemList;
   m_serviceItems = new CFileItemList;
   m_pausedOnRun = false;
diff -Naur c/xbmc/video/dialogs/GUIDialogVideoOSD.cpp d/xbmc/video/dialogs/GUIDialogVideoOSD.cpp
--- c/xbmc/video/dialogs/GUIDialogVideoOSD.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/video/dialogs/GUIDialogVideoOSD.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -30,7 +30,7 @@
 CGUIDialogVideoOSD::CGUIDialogVideoOSD(void)
     : CGUIDialog(WINDOW_DIALOG_VIDEO_OSD, "VideoOSD.xml")
 {
-  m_loadType = KEEP_IN_MEMORY;
+  m_loadType = LOAD_ON_GUI_INIT;
 }
 
 CGUIDialogVideoOSD::~CGUIDialogVideoOSD(void)
diff -Naur c/xbmc/video/dialogs/GUIDialogVideoSettings.cpp d/xbmc/video/dialogs/GUIDialogVideoSettings.cpp
--- c/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2015-10-21 00:51:46.000000000 +0300
+++ d/xbmc/video/dialogs/GUIDialogVideoSettings.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -63,7 +63,9 @@
 CGUIDialogVideoSettings::CGUIDialogVideoSettings()
     : CGUIDialogSettingsManualBase(WINDOW_DIALOG_VIDEO_OSD_SETTINGS, "VideoOSDSettings.xml"),
       m_viewModeChanged(false)
-{ }
+{
+  m_loadType = LOAD_ON_GUI_INIT;
+}
 
 CGUIDialogVideoSettings::~CGUIDialogVideoSettings()
 { }
diff -Naur c/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp d/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp
--- c/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -28,6 +28,9 @@
 #include "linux/RBP.h"
 #include "utils/StringUtils.h"
 #include "settings/Settings.h"
+#include "guilib/GraphicContext.h"
+#include "guilib/StereoscopicsManager.h"
+#include "rendering/RenderSystem.h"
 #include <cassert>
 
 #ifndef __VIDEOCORE4__
@@ -60,7 +63,10 @@
 # define DLOG(fmt, args...)
 #endif
 
+#if defined(TARGET_RASPBERRY_PI)
 static void SetResolutionString(RESOLUTION_INFO &res);
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect);
+#endif
 
 CEGLNativeTypeRaspberryPI::CEGLNativeTypeRaspberryPI()
 {
@@ -187,7 +193,7 @@
   for (int i = 0; i < (int)resolutions.size(); i++)
   {
     if(resolutions[i].iScreenWidth == res.iScreenWidth && resolutions[i].iScreenHeight == res.iScreenHeight && resolutions[i].fRefreshRate == res.fRefreshRate &&
-      (resolutions[i].dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)) == (res.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB)))
+      (resolutions[i].dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK))
     {
        return i;
     }
@@ -203,8 +209,7 @@
   int i = FindMatchingResolution(res, resolutions);
   if (i>=0)
   {  // don't replace a progressive resolution with an interlaced one of same resolution
-     if (!(res.dwFlags & D3DPRESENTFLAG_INTERLACED))
-       resolutions[i] = res;
+     resolutions[i] = res;
   }
   else
   {
@@ -214,27 +219,79 @@
 }
 #endif
 
+#include <dirent.h>
+
+pid_t proc_find(const char* name)
+{
+    DIR* dir;
+    struct dirent* ent;
+    char buf[512];
+
+    long  pid;
+    char pname[100] = {0,};
+    char state;
+    FILE *fp=NULL;
+
+    if (!(dir = opendir("/proc"))) {
+        perror("can't open /proc");
+        return -1;
+    }
+
+    while((ent = readdir(dir)) != NULL) {
+        long lpid = atol(ent->d_name);
+        if(lpid < 0)
+            continue;
+        snprintf(buf, sizeof(buf), "/proc/%ld/stat", lpid);
+        fp = fopen(buf, "r");
+
+        if (fp) {
+            if ( (fscanf(fp, "%ld (%[^)]) %c", &pid, pname, &state)) != 3 ){
+                printf("fscanf failed \n");
+                fclose(fp);
+                closedir(dir);
+                return -1;
+            }
+            if (!strcmp(pname, name)) {
+                fclose(fp);
+                closedir(dir);
+                return (pid_t)lpid;
+            }
+            fclose(fp);
+        }
+    }
+
+    closedir(dir);
+    return -1;
+}
+
+
 bool CEGLNativeTypeRaspberryPI::SetNativeResolution(const RESOLUTION_INFO &res)
 {
 #if defined(TARGET_RASPBERRY_PI)
   if(!m_DllBcmHost || !m_nativeWindow)
     return false;
 
+  while (proc_find("hello_video.bin") >= 0)
+    Sleep(100);
+
   DestroyDispmaxWindow();
 
-  if(!m_fixedMode && GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  RENDER_STEREO_MODE stereo_mode = g_graphicsContext.GetStereoMode();
+  if(GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
   {
     sem_init(&m_tv_synced, 0, 0);
     m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
 
-    if (res.dwFlags & (D3DPRESENTFLAG_MODE3DSBS|D3DPRESENTFLAG_MODE3DTB))
+    if (stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL || stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
     {
       /* inform TV of any 3D settings. Note this property just applies to next hdmi mode change, so no need to call for 2D modes */
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_3D_STRUCTURE;
-      if (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS)
+      if (CSettings::Get().GetBool("videoplayer.framepacking") && CSettings::Get().GetBool("videoplayer.supportmvc"))
+        property.param1 = HDMI_3D_FORMAT_FRAME_PACKING;
+      else if (stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
         property.param1 = HDMI_3D_FORMAT_SBS_HALF;
-      else if (res.dwFlags & D3DPRESENTFLAG_MODE3DTB)
+      else if (stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
         property.param1 = HDMI_3D_FORMAT_TB_HALF;
       else
         property.param1 = HDMI_3D_FORMAT_NONE;
@@ -257,19 +314,44 @@
 
     if (success == 0)
     {
-      CLog::Log(LOGDEBUG, "EGL set HDMI mode (%d,%d)=%d%s%s\n",
+      CLog::Log(LOGDEBUG, "EGL set HDMI mode (%d,%d)=%d %s\n",
                           GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success,
-                          (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ? " SBS":"",
-                          (res.dwFlags & D3DPRESENTFLAG_MODE3DTB) ? " TB":"");
+                          CStereoscopicsManager::Get().ConvertGuiStereoModeToString(stereo_mode));
 
       sem_wait(&m_tv_synced);
     }
     else
     {
-      CLog::Log(LOGERROR, "EGL failed to set HDMI mode (%d,%d)=%d%s%s\n",
+      CLog::Log(LOGERROR, "EGL failed to set HDMI mode (%d,%d)=%d %s\n",
                           GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success,
-                          (res.dwFlags & D3DPRESENTFLAG_MODE3DSBS) ? " SBS":"",
-                          (res.dwFlags & D3DPRESENTFLAG_MODE3DTB) ? " TB":"");
+                          CStereoscopicsManager::Get().ConvertGuiStereoModeToString(stereo_mode));
+    }
+    m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
+    sem_destroy(&m_tv_synced);
+
+    m_desktopRes = res;
+  }
+  else if(!GETFLAGS_GROUP(res.dwFlags) && GETFLAGS_MODE(res.dwFlags))
+  {
+    sem_init(&m_tv_synced, 0, 0);
+    m_DllBcmHost->vc_tv_register_callback(CallbackTvServiceCallback, this);
+
+    SDTV_OPTIONS_T options;
+    options.aspect = get_sdtv_aspect_from_display_aspect((float)res.iScreenWidth / (float)res.iScreenHeight);
+
+    int success = m_DllBcmHost->vc_tv_sdtv_power_on((SDTV_MODE_T)GETFLAGS_MODE(res.dwFlags), &options);
+
+    if (success == 0)
+    {
+      CLog::Log(LOGDEBUG, "EGL set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
+
+      sem_wait(&m_tv_synced);
+    }
+    else
+    {
+      CLog::Log(LOGERROR, "EGL failed to set SDTV mode (%d,%d)=%d\n",
+                          GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), success);
     }
     m_DllBcmHost->vc_tv_unregister_callback(CallbackTvServiceCallback);
     sem_destroy(&m_tv_synced);
@@ -305,6 +387,13 @@
   DISPMANX_TRANSFORM_T transform = DISPMANX_NO_ROTATE;
   DISPMANX_UPDATE_HANDLE_T dispman_update = m_DllBcmHost->vc_dispmanx_update_start(0);
 
+  if (stereo_mode == RENDER_STEREO_MODE_SPLIT_VERTICAL)
+    transform = DISPMANX_STEREOSCOPIC_SBS;
+  else if (stereo_mode == RENDER_STEREO_MODE_SPLIT_HORIZONTAL)
+    transform = DISPMANX_STEREOSCOPIC_TB;
+  else
+    transform = DISPMANX_STEREOSCOPIC_MONO;
+
   CLog::Log(LOGDEBUG, "EGL set resolution %dx%d -> %dx%d @ %.2f fps (%d,%d) flags:%x aspect:%.2f\n",
       m_width, m_height, dst_rect.width, dst_rect.height, res.fRefreshRate, GETFLAGS_GROUP(res.dwFlags), GETFLAGS_MODE(res.dwFlags), (int)res.dwFlags, res.fPixelRatio);
 
@@ -407,10 +496,27 @@
   res.iWidth = gui_width;
   res.iHeight = gui_height;
 
-  res.strMode = StringUtils::Format("%dx%d (%dx%d) @ %.2f%s%s%s - Full Screen", res.iScreenWidth, res.iScreenHeight, res.iWidth, res.iHeight, res.fRefreshRate,
-    res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "",
-    res.dwFlags & D3DPRESENTFLAG_MODE3DTB   ? " 3DTB" : "",
-    res.dwFlags & D3DPRESENTFLAG_MODE3DSBS  ? " 3DSBS" : "");
+  res.strMode = StringUtils::Format("%dx%d (%dx%d) @ %.2f%s - Full Screen", res.iScreenWidth, res.iScreenHeight, res.iWidth, res.iHeight, res.fRefreshRate,
+    res.dwFlags & D3DPRESENTFLAG_INTERLACED ? "i" : "");
+}
+
+static SDTV_ASPECT_T get_sdtv_aspect_from_display_aspect(float display_aspect)
+{
+  SDTV_ASPECT_T aspect;
+  const float delta = 1e-3;
+  if(fabs(get_display_aspect_ratio(SDTV_ASPECT_16_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_16_9;
+  }
+  else if(fabs(get_display_aspect_ratio(SDTV_ASPECT_14_9) - display_aspect) < delta)
+  {
+    aspect = SDTV_ASPECT_14_9;
+  }
+  else
+  {
+    aspect = SDTV_ASPECT_4_3;
+  }
+  return aspect;
 }
 #endif
 
@@ -422,8 +528,6 @@
   if(!m_DllBcmHost)
     return false;
 
-  m_fixedMode               = false;
-
   /* read initial desktop resolution before probe resolutions.
    * probing will replace the desktop resolution when it finds the same one.
    * we raplace it because probing will generate more detailed 
@@ -447,24 +551,13 @@
       m_desktopRes.iScreenWidth = tv_state.display.hdmi.width;
       m_desktopRes.iScreenHeight= tv_state.display.hdmi.height;
       m_desktopRes.dwFlags      = MAKEFLAGS(tv_state.display.hdmi.group, tv_state.display.hdmi.mode, tv_state.display.hdmi.scan_mode);
-      m_desktopRes.fPixelRatio  = get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
-      // Also add 3D flags
-      if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_SBS_HALF)
-      {
-        m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        m_desktopRes.fPixelRatio *= 2.0;
-      }
-      else if (tv_state.display.hdmi.format_3d == HDMI_3D_FORMAT_TB_HALF)
-      {
-        m_desktopRes.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        m_desktopRes.fPixelRatio *= 0.5;
-      }
+      m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((HDMI_ASPECT_T)tv_state.display.hdmi.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
       HDMI_PROPERTY_PARAM_T property;
       property.property = HDMI_PROPERTY_PIXEL_CLOCK_TYPE;
       vc_tv_hdmi_get_property(&property);
       m_desktopRes.fRefreshRate = property.param1 == HDMI_PIXEL_CLOCK_TYPE_NTSC ? tv_state.display.hdmi.frame_rate * (1000.0f/1001.0f) : tv_state.display.hdmi.frame_rate;
     }
-    else // sdtv
+    else if ((tv_state.state & ( VC_SDTV_NTSC | VC_SDTV_PAL )) != 0) // sdtv
     {
       m_desktopRes.iScreen      = 0;
       m_desktopRes.bFullScreen  = true;
@@ -472,9 +565,21 @@
       m_desktopRes.iHeight      = tv_state.display.sdtv.height;
       m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
       m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
-      m_desktopRes.dwFlags      = D3DPRESENTFLAG_INTERLACED;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, tv_state.display.sdtv.mode, 1);
       m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
-      m_desktopRes.fPixelRatio  = get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
+      m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
+    }
+    else if ((tv_state.state & VC_LCD_ATTACHED_DEFAULT) != 0) // lcd
+    {
+      m_desktopRes.iScreen      = 0;
+      m_desktopRes.bFullScreen  = true;
+      m_desktopRes.iWidth       = tv_state.display.sdtv.width;
+      m_desktopRes.iHeight      = tv_state.display.sdtv.height;
+      m_desktopRes.iScreenWidth = tv_state.display.sdtv.width;
+      m_desktopRes.iScreenHeight= tv_state.display.sdtv.height;
+      m_desktopRes.dwFlags      = MAKEFLAGS(HDMI_RES_GROUP_INVALID, 0, 0);
+      m_desktopRes.fRefreshRate = (float)tv_state.display.sdtv.frame_rate;
+      m_desktopRes.fPixelRatio  = tv_state.display.hdmi.display_options.aspect == 0 ? 1.0f : get_display_aspect_ratio((SDTV_ASPECT_T)tv_state.display.sdtv.display_options.aspect) / ((float)m_desktopRes.iScreenWidth / (float)m_desktopRes.iScreenHeight);
     }
 
     SetResolutionString(m_desktopRes);
@@ -486,18 +591,16 @@
     CLog::Log(LOGDEBUG, "EGL initial desktop resolution %s (%.2f)\n", m_desktopRes.strMode.c_str(), m_desktopRes.fPixelRatio);
   }
 
-  GetSupportedModes(HDMI_RES_GROUP_CEA, resolutions);
-  GetSupportedModes(HDMI_RES_GROUP_DMT, resolutions);
-
-  if(resolutions.size() == 0)
+  if(GETFLAGS_GROUP(m_desktopRes.dwFlags) && GETFLAGS_MODE(m_desktopRes.dwFlags))
+  {
+    GetSupportedModes(HDMI_RES_GROUP_CEA, resolutions);
+    GetSupportedModes(HDMI_RES_GROUP_DMT, resolutions);
+  }
   {
     AddUniqueResolution(m_desktopRes, resolutions);
     CLog::Log(LOGDEBUG, "EGL probe resolution %s:%x\n", m_desktopRes.strMode.c_str(), m_desktopRes.dwFlags);
   }
 
-  if(resolutions.size() < 2)
-    m_fixedMode = true;
-
   DLOG("CEGLNativeTypeRaspberryPI::ProbeResolutions\n");
   return true;
 #else
@@ -584,51 +687,22 @@
       res.fPixelRatio   = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res.iScreenWidth / (float)res.iScreenHeight);
       res.iSubtitles    = (int)(0.965 * res.iHeight);
 
+      if (!m_desktopRes.dwFlags && prefer_group == group && prefer_mode == tv->code)
+        m_desktopRes = res;
+
+      if (res.dwFlags & D3DPRESENTFLAG_INTERLACED)
+        continue;
+
       AddUniqueResolution(res, resolutions);
       CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f) %s%s:%x\n", i, res.strMode.c_str(), res.fPixelRatio,
           tv->native ? "N" : "", tv->scan_mode ? "I" : "", tv->code);
 
-      if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
+      if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 48 || tv->frame_rate == 60 || tv->frame_rate == 72)
       {
         RESOLUTION_INFO res2 = res;
         res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
         AddUniqueResolution(res2, resolutions);
       }
-
-      // Also add 3D versions of modes
-      if (tv->struct_3d_mask & HDMI_3D_STRUCT_SIDE_BY_SIDE_HALF_HORIZONTAL)
-      {
-        RESOLUTION_INFO res2 = res;
-        res2.dwFlags |= D3DPRESENTFLAG_MODE3DSBS;
-        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 2.0f;
-        res2.iSubtitles    = (int)(0.965 * res2.iHeight);
-
-        AddUniqueResolution(res2, resolutions);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-        if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
-        {
-          res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
-          AddUniqueResolution(res2, resolutions);
-        }
-      }
-      if (tv->struct_3d_mask & HDMI_3D_STRUCT_TOP_AND_BOTTOM)
-      {
-        RESOLUTION_INFO res2 = res;
-        res2.dwFlags |= D3DPRESENTFLAG_MODE3DTB;
-        res2.fPixelRatio    = get_display_aspect_ratio((HDMI_ASPECT_T)tv->aspect_ratio) / ((float)res2.iScreenWidth / (float)res2.iScreenHeight);
-        res2.fPixelRatio   *= 0.5f;
-        res2.iSubtitles    = (int)(0.965 * res2.iHeight);
-
-        AddUniqueResolution(res2, resolutions);
-        CLog::Log(LOGDEBUG, "EGL mode %d: %s (%.2f)\n", i, res2.strMode.c_str(), res2.fPixelRatio);
-        if (tv->frame_rate == 24 || tv->frame_rate == 30 || tv->frame_rate == 60)
-        {
-          res2.fRefreshRate  = (float)tv->frame_rate * (1000.0f/1001.0f);
-          AddUniqueResolution(res2, resolutions);
-        }
-
-      }
     }
   }
   if (supported_modes)
diff -Naur c/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h d/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h
--- c/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/egl/EGLNativeTypeRaspberryPI.h	2016-04-06 18:32:36.000000000 +0300
@@ -59,7 +59,6 @@
   DISPMANX_ELEMENT_HANDLE_T     m_dispman_element;
   TV_GET_STATE_RESP_T           m_tv_state;
   sem_t                         m_tv_synced;
-  bool                          m_fixedMode;
   RESOLUTION_INFO               m_desktopRes;
   int                           m_width;
   int                           m_height;
diff -Naur c/xbmc/windowing/egl/WinSystemEGL.cpp d/xbmc/windowing/egl/WinSystemEGL.cpp
--- c/xbmc/windowing/egl/WinSystemEGL.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/egl/WinSystemEGL.cpp	2016-04-06 18:32:36.000000000 +0300
@@ -287,7 +287,7 @@
     (current_resolution.dwFlags & D3DPRESENTFLAG_MODEMASK) == (res.dwFlags & D3DPRESENTFLAG_MODEMASK))
   {
     CLog::Log(LOGDEBUG, "CWinSystemEGL::CreateNewWindow: No need to create a new window");
-    return true;
+//xxx    return true;
   }
 
   m_bFullScreen   = fullScreen;
@@ -531,35 +531,6 @@
   return m_config;
 }
 
-// the logic in this function should match whether CBaseRenderer::FindClosestResolution picks a 3D mode
-bool CWinSystemEGL::Support3D(int width, int height, uint32_t mode) const
-{
-  RESOLUTION_INFO &curr = CDisplaySettings::Get().GetResolutionInfo(g_graphicsContext.GetVideoResolution());
-
-  // if we are using automatic hdmi mode switching
-  if (CSettings::Get().GetInt("videoplayer.adjustrefreshrate") != ADJUST_REFRESHRATE_OFF)
-  {
-    int searchWidth = curr.iScreenWidth;
-    int searchHeight = curr.iScreenHeight;
-
-    // only search the custom resolutions
-    for (unsigned int i = (int)RES_DESKTOP; i < CDisplaySettings::Get().ResolutionInfoSize(); i++)
-    {
-      RESOLUTION_INFO res = CDisplaySettings::Get().GetResolutionInfo(i);
-      if(res.iScreenWidth == searchWidth && res.iScreenHeight == searchHeight && (res.dwFlags & mode))
-        return true;
-    }
-  }
-  // otherwise just consider current mode
-  else
-  {
-     if (curr.dwFlags & mode)
-       return true;
-  }
-
-  return false;
-}
-
 bool CWinSystemEGL::ClampToGUIDisplayLimits(int &width, int &height)
 {
   width = width > m_nWidth ? m_nWidth : width;
diff -Naur c/xbmc/windowing/egl/WinSystemEGL.h d/xbmc/windowing/egl/WinSystemEGL.h
--- c/xbmc/windowing/egl/WinSystemEGL.h	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/egl/WinSystemEGL.h	2016-04-06 18:32:36.000000000 +0300
@@ -59,7 +59,6 @@
   virtual void  Register(IDispResource *resource);
   virtual void  Unregister(IDispResource *resource);
 
-  virtual bool  Support3D(int width, int height, uint32_t mode)     const;
   virtual bool  ClampToGUIDisplayLimits(int &width, int &height);
 
   EGLConfig     GetEGLConfig();
diff -Naur c/xbmc/windowing/WinEventsLinux.cpp d/xbmc/windowing/WinEventsLinux.cpp
--- c/xbmc/windowing/WinEventsLinux.cpp	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/WinEventsLinux.cpp	2016-04-06 18:32:52.000000000 +0300
@@ -30,11 +30,31 @@
 #include "utils/log.h"
 #include "powermanagement/PowerManager.h"
 
+#ifdef TARGET_RASPBERRY_PI
+#include "utils/TimeUtils.h"
+#include "guilib/Resolution.h"
+#include "addons/Skin.h"
+#include "utils/XMLUtils.h"
+#include "utils/StringUtils.h"
+#include "filesystem/File.h"
+#include "guilib/iimage.h"
+#include "guilib/XBTF.h"
+#include "guilib/imagefactory.h"
+#include "guilib/TextureManager.h"
+#include "linux/RBP.h"
+#include "input/InputManager.h"
+#endif
+
 bool CWinEventsLinux::m_initialized = false;
 CLinuxInputDevices CWinEventsLinux::m_devices;
 
 CWinEventsLinux::CWinEventsLinux()
 {
+#ifdef TARGET_RASPBERRY_PI
+  m_last_mouse_move_time = 0;
+  m_mouse_state = -1;
+  memset(m_cursors, 0, sizeof m_cursors);
+#endif
 }
 
 void CWinEventsLinux::RefreshDevices()
@@ -48,19 +68,154 @@
   return false;
 }
 
+#ifdef TARGET_RASPBERRY_PI
+void *CWinEventsLinux::LoadImage(const std::string texturePath, int &width, int &height)
+{
+  void *pixels = NULL;
+  // Read image into memory to use our vfs
+  XFILE::CFile file;
+  XFILE::auto_buffer buf;
+
+  if (file.LoadFile(texturePath, buf) <= 0)
+    return NULL;
+
+  IImage *pImage = ImageFactory::CreateLoader(texturePath);
+  if (pImage != NULL && pImage->LoadImageFromMemory((unsigned char *)buf.get(), buf.size(), width, height))
+  {
+    width = pImage->Width();
+    height = pImage->Height();
+    if (width > 0 && height > 0)
+    {
+      pixels = malloc(width * height * 4);
+      if (!pixels)
+        return NULL;
+      if (!pImage->Decode((unsigned char *)pixels, width * 4, XB_FMT_A8R8G8B8))
+      {
+        free(pixels);
+        return NULL;
+      }
+    }
+  }
+  return pixels;
+}
+
+bool CWinEventsLinux::LoadXML(const std::string strFileName)
+{
+  RESOLUTION_INFO m_coordsRes; // resolution that the window coordinates are in.
+  // Find appropriate skin folder + resolution to load from
+  std::string strFileNameLower = strFileName;
+  StringUtils::ToLower(strFileNameLower);
+  std::string strLowerPath = g_SkinInfo->GetSkinPath(strFileNameLower, &m_coordsRes);
+  std::string strPath = g_SkinInfo->GetSkinPath(strFileName, &m_coordsRes);
+
+  TiXmlElement* pRootElement = NULL;
+  CXBMCTinyXML xmlDoc;
+  std::string strPathLower = strPath;
+  StringUtils::ToLower(strPathLower);
+  if (!xmlDoc.LoadFile(strPath) && !xmlDoc.LoadFile(strPathLower) && !xmlDoc.LoadFile(strLowerPath))
+  {
+    CLog::Log(LOGERROR, "unable to load:%s, Line %d\n%s", strPath.c_str(), xmlDoc.ErrorRow(), xmlDoc.ErrorDesc());
+    return false;
+  }
+  pRootElement = (TiXmlElement*)xmlDoc.RootElement()->Clone();
+  //printf("%s: load:%s,%s,%s\n", __func__, strPath.c_str(), strPathLower.c_str(), strLowerPath.c_str());
+
+  if (!pRootElement)
+    return false;
+
+  if (strcmpi(pRootElement->Value(), "window"))
+  {
+    CLog::Log(LOGERROR, "file : XML file doesnt contain <window>");
+    return false;
+  }
+
+  TiXmlElement *pChild = pRootElement->FirstChildElement();
+  while (pChild)
+  {
+    if (strcmpi(pChild->Value(), "controls") == 0)
+    {
+      TiXmlElement *pControl = pChild->FirstChildElement();
+      while (pControl)
+      {
+        //printf("%s:2 %s\n", __func__, pControl->Value());
+        if (strcmpi(pControl->Value(), "control") == 0)
+        {
+          std::string strStringValue;
+          if (XMLUtils::GetString(pControl, "texture", strStringValue))
+          {
+            const char* idAttr = pControl->Attribute("id");
+            int index = idAttr ? atoi(idAttr)-1 : -1;
+            if (index >= 0 && index < (int)(sizeof m_cursors/sizeof *m_cursors))
+            {
+              if (m_cursors[index].pixels)
+                free(m_cursors[index].pixels);
+              std::string path = g_TextureManager.GetTexturePath(strStringValue);
+              m_cursors[index].width = m_cursors[index].height = 64; // max
+              m_cursors[index].pixels = LoadImage(path, m_cursors[index].width, m_cursors[index].height);
+              //printf("%s: texture: %d %s %dx%d %p\n", __func__, index, path.c_str(), m_cursors[index].width, m_cursors[index].height, m_cursors[index].pixels);
+            }
+          }
+        }
+        pControl = pControl->NextSiblingElement();
+      }
+    }
+    pChild = pChild->NextSiblingElement();
+  }
+  delete pRootElement;
+  return true;
+}
+#endif
+
 bool CWinEventsLinux::MessagePump()
 {
   if (!m_initialized)
   {
     m_devices.InitAvailable();
     m_initialized = true;
+#ifdef TARGET_RASPBERRY_PI
+    LoadXML("Pointer.xml");
+#endif
   }
 
   bool ret = false;
   XBMC_Event event = {0};
+#ifdef TARGET_RASPBERRY_PI
+  bool active = CInputManager::Get().IsMouseActive();
+  int64_t Now = CurrentHostCounter();
+  if (!active)
+  {
+    if (m_mouse_state != -1)
+    {
+      g_RBP.update_cursor(0, 0, 0);
+      m_mouse_state = -1;
+    }
+  }
+  else
+  {
+    int state = CInputManager::Get().GetMouseState() - 1;
+    if (m_mouse_state != state)
+    {
+      //printf("%s: %d->%d\n", __func__, m_mouse_state, state);
+      if (state >= 0 && state < (int)(sizeof m_cursors/sizeof *m_cursors) && m_cursors[state].pixels)
+      {
+        g_RBP.set_cursor(m_cursors[state].pixels, m_cursors[state].width, m_cursors[state].height, 0, 0);
+      }
+      m_mouse_state = state;
+    }
+  }
+#endif
   while (1)
   {
     event = m_devices.ReadEvent();
+#ifdef TARGET_RASPBERRY_PI
+    if (active && (event.type == XBMC_MOUSEMOTION || event.type == XBMC_MOUSEBUTTONDOWN || event.type == XBMC_MOUSEBUTTONUP))
+    {
+      if (event.type == XBMC_MOUSEMOTION)
+        g_RBP.update_cursor(event.motion.x, event.motion.y, 1);
+      m_last_mouse_move_time = Now;
+      //printf("%s: %d,%d %d %d,%d (%d,%d) act:%d\n", __func__, event.motion.type, event.motion.which, event.motion.state, event.motion.x, event.motion.y, event.motion.xrel, event.motion.yrel, CInputManager::Get().IsMouseActive());
+    }
+#endif
     if (event.type != XBMC_NOEVENT)
     {
       ret |= g_application.OnEvent(event);
@@ -71,6 +226,13 @@
     }
   }
 
+#ifdef TARGET_RASPBERRY_PI
+  if (active && Now - m_last_mouse_move_time > 5 * 1000000000LL)
+  {
+    g_RBP.update_cursor(0, 0, 0);
+    m_mouse_state = -1;
+  }
+#endif
   return ret;
 }
 
diff -Naur c/xbmc/windowing/WinEventsLinux.h d/xbmc/windowing/WinEventsLinux.h
--- c/xbmc/windowing/WinEventsLinux.h	2015-10-21 00:51:50.000000000 +0300
+++ d/xbmc/windowing/WinEventsLinux.h	2016-04-06 18:32:36.000000000 +0300
@@ -42,6 +42,17 @@
 private:
   static bool m_initialized;
   static CLinuxInputDevices m_devices;
+#ifdef TARGET_RASPBERRY_PI
+  bool LoadXML(const std::string strFileName);
+  void *LoadImage(const std::string texturePath, int &width, int &height);
+  int64_t m_last_mouse_move_time;
+  struct
+  {
+    void *pixels;
+    int width, height;
+  } m_cursors[4];
+  int m_mouse_state;
+#endif
 };
 
 #endif
